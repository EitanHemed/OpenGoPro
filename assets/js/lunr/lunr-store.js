var store = [
        {
            "title": "Bluetooth Low Energy (BLE) Specification v2.0: ",
            "excerpt": "About This Page This page describes the format, capabilities, and use of Bluetooth Low Energy (BLE) as it pertains to communicating with GoPro cameras. Messages are sent using either TLV or Protobuf format. General Communicating with a GoPro camera via Bluetooth Low Energy involves writing to Bluetooth characteristics and, typically, waiting for a response notification from a corresponding characteristic. The camera organizes its Generic Attribute Profile (GATT) table by broad features: AP control, control &amp; query, etc. Note: All byte ordering is in Big Endian unless otherwise noted. Supported Cameras Below is a table of cameras that support GoPro's public BLE API: Model ID Model Code Marketing Name Minimal Firmware Version 60 H22.03 HERO11 Black Mini v01.10.00 58 H22.01 HERO11 Black v01.10.00 57 H21.01 HERO10 Black v01.10.00 55 HD9.01 HERO9 Black v01.70.00 Services and Characteristics Note: GP-XXXX is shorthand for GoPro's 128-bit UUIDs: b5f9xxxx-aa8d-11e3-9046-0002a5d5c51b Service UUID Service Characteristic UUID Description Permissions GP-0001 GoPro WiFi Access Point GP-0002 WiFi AP SSID Read / Write GP-0003 WiFi AP Password Read / Write GP-0004 WiFi AP Power Write GP-0005 WiFi AP State Read / Indicate GP-0090 GoPro Camera Management GP-0091 Network Management Command Write GP-0092 Network Management Response Notify FEA6 Control &amp; Query GP-0072 Command Write GP-0073 Command Response Notify GP-0074 Settings Write GP-0075 Settings Response Notify GP-0076 Query Write GP-0077 Query Response Notify Packet Headers The Bluetooth Low Energy protocol limits messages to 20 bytes per packet. To accommodate this limitation, GoPro cameras use the packet header format below. All lengths are in bytes. Messages sent to and received from the camera are expected to be packetized and sent in 20 byte chunks. Messages received from the camera will always use the header with the smallest possible message length. For example, a three byte response will use the 5-bit General header, not the 13-bit or 16-bit Extended headers. Messages sent to the camera can use either the 5-bit General header or the 13-bit Extended header. Packet Header Format Byte 1 Byte 2 (optional) Byte 3 (optional) 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 0: Start 00: General Message Length: 5 bits 0: Start 01: Extended (13-bit) Message Length: 13 bits 0: Start 10: Extended (16-bit) Message Length: 16 bits 0: Start 11: Reserved 1: Continuation Counter (4-bit) Note: Continuation packet counters start at 0x0 and reset after 0xF. Example: Packetizing a 5-bit General Message Message Length: 17 bytes Message: 01:02:03:04:05:06:07:08:09:0A:0B:0C:0D:0E:0F:10:11 Packet Type Byte(s) Description 1 Header 11 (0) start packet (00) 5-bit General message (10001) message length: 17 Payload 01:02:03:04:05:06:07:08:09:0A:0B:0C:0D:0E:0F:10:11 Message Example: Packetizing a 13-bit Extended Message Message Length: 50 bytes Message: 01:02:03:04:05:06:07:08:09:0A:0B:0C:0D:0E:0F:10:11:12:13:14:15:16:17:18:19:1A:1B:1C:1D:1E:1F:20:21:22:23:24:25:26:27:28:29:2A:2B:2C:2D:2E:2F:30:31:32 Packet Type Byte(s) Description 1 Header 20:32 (0) start packet (01) 13-bit Extended message (0000000110010) message length: 50 Payload 01:02:03:04:05:06:07:08:09:0A:0B:0C:0D:0E:0F:10:11:12 Message (chunk 1 of 3) 2 Header 80 (0) continuation packet (000) ignored (0000) counter: 0 Payload 13:14:15:16:17:18:19:1A:1B:1C:1D:1E:1F:20:21:22:23:24:25 Message (chunk 2 of 3) 3 Header 81 (0) continuation packet (000) ignored (0001) counter: 1 Payload 26:27:28:29:2A:2B:2C:2D:2E:2F:30:31:32 Message (chunk 3 of 3) Example: Depacketizing a Mutli-Packet Message Packets Received: 5 Once the packet headers are identified and removed from each packet, the complete response message can be assembled by concatenating the remaining packet data in the order it was received. Packet Byte(s) Header 1 20:57:01:02:03:04:05:06:07:08:09:0A:0B:0C:0D:0E:0F:10:11:12 20:57 (0) start packet (01) 13-bit Extended message (0000001010111) message length: 87 2 80:13:14:15:16:17:18:19:1A:1B:1C:1D:1E:1F:20:21:22:23:24:25 80 (1) continuation packet (000) ignored (0000) counter: 0 3 81:26:27:28:29:2A:2B:2C:2D:2E:2F:30:31:32:33:34:35:36:37:38 81 (1) continuation packet (000) ignored (0001) counter: 1 4 82:39:3A:3B:3C:3D:3E:3F:40:41:42:43:44:45:46:47:48:49:4A:4B 82 (1) continuation packet (000) ignored (0010) counter: 2 5 83:4C:4D:4E:4F:50:51:52:53:54:55:56:57 83 (1) continuation packet (000) ignored (0011) counter: 3 Discovery, Connection and Pairing Advertisements The camera will send BLE advertisements while it is ON and for the first 8 hours after the camera is put to sleep. During this time, the camera is discoverable and can be connected to. If the camera is in sleep mode, connecting to it will cause the camera to wake and boot up. Pairing In order to communicate with a GoPro camera via BLE, a client must first be paired with the camera. The pairing procedure must be done once for each new client. If the camera is factory reset, all clients will need to pair again. To pair with the camera, use the UI to put it into pairing mode, connect via BLE and then initiate pairing. The camera will whitelist the client so subsequent connections do not require pairing. Steps Discovery of and connection to the GoPro camera can be done as follows: Put the camera into pairing mode Scan to discover peripherals (which can be narrowed by limiting to peripherals that advertise service FEA6) Connect to the peripheral Finish pairing with the peripheral Discover all advertised services and characteristics Subscribe to notifications from all characteristics that have the notify flag set Sending and Receiving Messages In order to enable two-way communication with a GoPro camera, clients must connect to the camera and subscribe to characteristics that have the notify flag set. Messages are sent to the camera by writing to a write-enabled UUID and then waiting for a notification from the corresponding response UUID. Response notifications indicate whether the message was valid and will be (asynchronously) processed. For example, to send a camera control command, a client should write to GP-0072 and then wait for a response notification from GP-0073. Depending on the camera's state, it may not be ready to accept specific commands. This ready state is dependent on the System Busy and the Encoding Active status flags. For example: System Busy flag is set while loading presets, changing settings, formatting sdcard, ... Encoding Active flag is set while capturing photo/video media If the system is not ready, it should reject an incoming command; however, best practice is to always wait for the System Busy and Encode Active flags to be unset before sending messages other than get status/setting queries. Parsing Responses In order to communicate fully with the camera, the user will need to be able to parse response and event notifications in TLV or Protobuf format as needed. TLV and Protobuf responses have very different formats. Parsing TLV data requires a parser to be written locally. Parsing Protobuf data can be done using code generated from Protobuf files linked in this document. Typically, the camera will send TLV responses/events for commands sent in TLV format and Protobuf responses/events for commands sent in Protobuf format. The pseudocode and flowcharts below refer to the following tables: Protobuf IDs Table Protobuf Commands Table Command Response Format Settings Response Format Query Response Format Pseudocode Below is pseudocode describing how to determine whether a respose is TLV or Protobuf and then parse it appropriately. Camera sends response R (array of bytes) from UUID U (string) with payload P (array of bytes) // Is it a Protobuf response? for each row in the Protobuf IDs table { F (int) = Feature ID A (array of int) = Action IDs if P[0] == F and P[1] in A { R is a protobuf message Match Feature ID P[0] and Action ID P[1] to a Response message in the Protobuf Commands Table Use matched Response message to parse payload into useful data structure Exit } } // Nope. It is a TLV response if U == GP-0072 (Command) { Parse using Command Response Format table } else if U == GP-0074 (Settings) { Parse using Settings Response Format table } else if U == GP-0076 (Query) { Parse using Query Response Format table } Exit Flowchart Below is a flowchart describing how to determine whether a respose is TLV or Protobuf and then parse it appropriately. Receive response RExtract payload P P[0] == Feature ID from row N of Protobuf IDs TableANDP[1] in Action IDs list from row N of Protobuf IDs Table yesnoR is a protobuf messageR is a TLV messageResponse RResponse UUIDR is a Command responseR is a Settings responseR is a Query responseParse accordinglyFeature ID = P[0]Action ID = P[1]Use: Protobuf Commands TableParse using appropriate protobuf messageKnowledge!GP-0072(Control)GP-0076(Query)GP-0074(Settings)TLV messageProtobuf message Keep Alive In order to maximize battery life, GoPro cameras automatically go to sleep after some time. This logic is handled by a combination of an Auto Power Down setting which most (but not all) cameras support and a Keep Alive message that the user can regularly send to the camera. The camera will automatically go to sleep if both timers reach zero. The Auto Power Down timer is reset when the user taps the LCD screen, presses a button on the camera or programmatically (un)sets the shutter, sets a setting, or loads a Preset. The Keep Alive timer is reset when the user sends a keep alive message. The best practice to prevent the camera from inadvertently going to sleep is to start sending Keep Alive messages every 3.0 seconds after a connection is established. Command UUID Write Response UUID Response GP-0074 03:5B:01:42 GP-0075 02:5B:00 Limitations HERO11 Black Mini The camera will reject requests to change settings while encoding; for example, if Hindsight feature is active, the user cannot change settings HERO11 Black The camera will reject requests to change settings while encoding; for example, if Hindsight feature is active, the user cannot change settings HERO10 Black The camera will reject requests to change settings while encoding; for example, if Hindsight feature is active, the user cannot change settings HERO9 Black The camera will reject requests to change settings while encoding; for example, if Hindsight feature is active, the user cannot change settings General Unless changed by the user, GoPro cameras will automatically power off after some time (e.g. 5min, 15min, 30min). The Auto Power Down watchdog timer can be reset by sending periodic keep-alive messages to the camera. It is recommended to send a keep-alive at least once every 120 seconds. In general, querying the value for a setting that is not associated with the current preset/core mode results in an undefined value. For example, the user should not try to query the current Photo Digital Lenses (FOV) value while in Standard preset (Video mode). Type Length Value GoPro's BLE protocol comes in two flavors: TLV (Type Length Value) and Protobuf. This section describes TLV style messaging. Note: All TLV messages (payloads) must be packetized and wrapped with Packet Headers as outlined in this document. Commands The table below contains command IDs supported by Open GoPro. Command messages are sent to GP-0072 and responses/notifications are received on GP-0073. Command ID Description 0x01 Set shutter 0x05 Sleep 0x0D Set Date/Time 0x0E Get Date/Time 0x0F Set Local Date/Time 0x10 Get Local Date/Time 0x15 Set Livestream Mode 0x17 AP Control 0x18 Media: HiLight Moment 0x3C Get Hardware Info 0x3E Presets: Load Group 0x40 Presets: Load 0x50 Analytics 0x51 Open GoPro Command Format Header/Length Command ID Parameter Length Parameter Value 1-2 bytes 1 byte 1 byte Variable length Command Response The GoPro camera sends responses to most commands received, indicating whether the command was valid and will be processed or not. Unless indicated otherwise in the Quick Reference table below, command responses use the format below. Command Response Format Header/Length Command ID Response Code Response 1-2 bytes 1 byte 1 byte Variable length Command Response Error Codes Error Code Description 0 Success 1 Error 2 Invalid Parameter 3..255 Reserved Commands Quick Reference Below is a table of commands that can be sent to the camera and how to send them. ✔ Indicates support for all Open GoPro firmware versions. ❌ Indicates a lack of support for all Open GoPro firmware versions. &gt;= vXX.YY.ZZ indicates support for firmware versions equal to or newer than vXX.YY.ZZ ID Command Description Request Response HERO11 Black Mini HERO11 Black HERO10 Black HERO9 Black 0x01 Set shutter Shutter: off 03:01:01:00 02:01:00 ✔ ✔ ✔ ✔ 0x01 Set shutter Shutter: on 03:01:01:01 02:01:00 ✔ ✔ ✔ ✔ 0x05 Sleep Put camera to sleep 01:05 02:05:00 ✔ ✔ ✔ ✔ 0x0D Set Date/Time Set date/time to 2023-01-31 03:04:05 09:0D:07:07:E7:01:1F:03:04:05 02:0D:00 ✔ ✔ ✔ ✔ 0x0E Get Date/Time Get date/time 01:0E Complex ✔ ✔ ✔ ✔ 0x0F Set Local Date/Time Set local date/time to: 2023-01-31 03:04:05 (utc-02:00) (dst: on) 0C:0F:0A:07:E7:01:1F:03:04:05:FF:88:01 02:0F:00 ✔ ✔ ❌ ❌ 0x10 Get Local Date/Time Get local date/time 01:10 Complex ✔ ✔ ❌ ❌ 0x15 Set Livestream Mode Set live stream mode: url: xxx, encode: true, window size: windowsize.size_720, cert: none 20:15:F1:79:0A:03:78:78:78:10:01:18:07:38:7B:40:95:06:48:C8:80:03:50:00 02:15:00 ✔ ✔ ✔ ✔ 0x17 AP Control WiFi AP: off 03:17:01:00 02:17:00 ✔ ✔ ✔ ✔ 0x17 AP Control WiFi AP: on 03:17:01:01 02:17:00 ✔ ✔ ✔ ✔ 0x18 Media: HiLight Moment Hilight moment during encoding 01:18 02:18:00 ✔ ✔ ✔ ✔ 0x3C Get Hardware Info Get camera hardware info 01:3C Complex ✔ ✔ ✔ ✔ 0x3E Presets: Load Group Video 04:3E:02:03:E8 02:3E:00 ✔ ✔ ✔ ✔ 0x3E Presets: Load Group Photo 04:3E:02:03:E9 02:3E:00 ❌ ✔ ✔ ✔ 0x3E Presets: Load Group Timelapse 04:3E:02:03:EA 02:3E:00 ❌ ✔ ✔ ✔ 0x40 Presets: Load Example preset id: 0x1234ABCD 06:40:04:12:34:AB:CD 02:40:00 ✔ ✔ ✔ ✔ 0x50 Analytics Set third party client 01:50 02:50:00 ✔ ✔ ✔ ✔ 0x51 Open GoPro Get version 01:51 Complex ✔ ✔ ✔ ✔ Complex Command Inputs Set Local Date/Time The timezone is a two byte UTC offset in minutes and must be sent in Two's Complement form. Complex Command Responses Below are clarifications for complex camera responses Get Hardware Info Response Packet Response Byte(s) Description 1 20 Start packet 51 Response length 3C:00 Command 3C sent successfully 04 Length of model number 00:00:00:37 Model ID 0B Length of model id 48:45:52:4F:58:20:42:6C:61:63 \"HEROX Blac\" 2 80 Continuation packet 6B \"k\" 04 Length of board type 30:78:30:35 \"0x05\" 0F Length of firmware version 48:44:58:2E:58:58:2E:58:58:2E:58:58 \"HDX.XX.XX.XX\" 3 81 Continuation packet (1) 2E:58:58 \".XX\" 0E Length of serial number 58:58:58:58:58:58:58:58:58:58:58:58:58:58 \"XXXXXXXXXXXXXX\" 0A Length of AP SSID 4 82 Continuation packet (2) 47:50:32:34:35:30:58:58:58:58 \"GP2450XXXX\" 0C AP MAC Address length 58:58:58:58:58:58:58:58 \"XXXXXXXX\" 5 83 Continuation packet (3) 58:58:58:58 \"XXXX\" Open GoPro Version Given the response 06:51:00:01:01:01:00, the Open GoPro version would be vXX.YY. Response Byte(s) Description 06 Packet length 51 Command ID 00 Status (OK) 01 Length of major version 01 Major version: 1 01 Length of minor version 00 Minor version: 0 Get Date/Time Given the response 0B:0E:00:08:07:E5:01:02:03:04:05:06, the date/time would be 2022-01-02 03:04:05 (Saturday). Response Byte(s) Description 0B Packet length 0E Command ID 00 Status (OK) 08 Date length (bytes) 07:E6 Year 01 Month 02 Day 03 Hour 04 Minute 05 Second 06 Day of the week (Sun=0, Sat=6) Get Local Date/Time (with Timezone and DST) Given the response 0D:10:00:0A:07:E6:01:02:03:04:05:FE:20:01, the date/time would be 2022-01-02 03:04:05-0800 (DST: ON). Response Byte(s) Description 0D Packet length 10 Command ID 00 Status (OK) 0A Date length (bytes) 07:E6 Year 01 Month 02 Day 03 Hour 04 Minute 05 Second FE:20 UTC offset in minutes (Two's Complement) 01 DST: ON Settings GoPro settings can be configured using the GP-Settings (GP-0074) UUID. Setting status is returned on GP-Settings-Status (GP-0075) UUID. Settings Request Format This will configure a setting on the camera. Only one setting may be sent on a packet (GATT notify or write-no-response), although multiple packets may be sent back-to-back. Request Length Setting ID Setting Value Length Setting Value 1-2 bytes 1 byte 1 byte (variable length) Settings Response Format Response Length Setting ID Response Code 1 byte 1 byte 1 byte Settings Quick Reference All settings are sent to UUID GP-0074. All values are hexadecimal and length are in bytes. ✔ Indicates support for all Open GoPro firmware versions. ❌ Indicates a lack of support for all Open GoPro firmware versions. &gt;= vXX.YY.ZZ indicates support for firmware versions equal to or newer than vXX.YY.ZZ Setting ID Setting Option Request Response HERO11 Black Mini HERO11 Black HERO10 Black HERO9 Black 2 Resolution Set video resolution (id: 2) to 4k (id: 1) 03:02:01:01 02:02:00 ✔ ✔ ✔ ✔ 2 Resolution Set video resolution (id: 2) to 2.7k (id: 4) 03:02:01:04 02:02:00 ✔ ✔ ✔ ✔ 2 Resolution Set video resolution (id: 2) to 2.7k 4:3 (id: 6) 03:02:01:06 02:02:00 ✔ ✔ ✔ ✔ 2 Resolution Set video resolution (id: 2) to 1440 (id: 7) 03:02:01:07 02:02:00 ❌ ❌ ❌ ✔ 2 Resolution Set video resolution (id: 2) to 1080 (id: 9) 03:02:01:09 02:02:00 ✔ ✔ ✔ ✔ 2 Resolution Set video resolution (id: 2) to 4k 4:3 (id: 18) 03:02:01:12 02:02:00 ✔ ✔ ✔ ✔ 2 Resolution Set video resolution (id: 2) to 5k (id: 24) 03:02:01:18 02:02:00 ❌ ❌ ❌ ✔ 2 Resolution Set video resolution (id: 2) to 5k 4:3 (id: 25) 03:02:01:19 02:02:00 ❌ ❌ ✔ ❌ 2 Resolution Set video resolution (id: 2) to 5.3k 8:7 (id: 26) 03:02:01:1A 02:02:00 ✔ ✔ ❌ ❌ 2 Resolution Set video resolution (id: 2) to 5.3k 4:3 (id: 27) 03:02:01:1B 02:02:00 ✔ ✔ ❌ ❌ 2 Resolution Set video resolution (id: 2) to 4k 8:7 (id: 28) 03:02:01:1C 02:02:00 ✔ ✔ ❌ ❌ 2 Resolution Set video resolution (id: 2) to 5.3k (id: 100) 03:02:01:64 02:02:00 ✔ ✔ ✔ ❌ 3 Frames Per Second Set video fps (id: 3) to 240 (id: 0) 03:03:01:00 02:03:00 ✔ ✔ ✔ ✔ 3 Frames Per Second Set video fps (id: 3) to 120 (id: 1) 03:03:01:01 02:03:00 ✔ ✔ ✔ ✔ 3 Frames Per Second Set video fps (id: 3) to 100 (id: 2) 03:03:01:02 02:03:00 ✔ ✔ ✔ ✔ 3 Frames Per Second Set video fps (id: 3) to 60 (id: 5) 03:03:01:05 02:03:00 ✔ ✔ ✔ ✔ 3 Frames Per Second Set video fps (id: 3) to 50 (id: 6) 03:03:01:06 02:03:00 ✔ ✔ ✔ ✔ 3 Frames Per Second Set video fps (id: 3) to 30 (id: 8) 03:03:01:08 02:03:00 ✔ ✔ ✔ ✔ 3 Frames Per Second Set video fps (id: 3) to 25 (id: 9) 03:03:01:09 02:03:00 ✔ ✔ ✔ ✔ 3 Frames Per Second Set video fps (id: 3) to 24 (id: 10) 03:03:01:0A 02:03:00 ✔ ✔ ✔ ✔ 3 Frames Per Second Set video fps (id: 3) to 200 (id: 13) 03:03:01:0D 02:03:00 ✔ ✔ ✔ ✔ 59 Auto Power Down Set auto power down (id: 59) to never (id: 0) 03:3B:01:00 01:3B:00 \\&gt;= v02.10.00 ✔ ✔ ✔ 59 Auto Power Down Set auto power down (id: 59) to 1 min (id: 1) 03:3B:01:01 01:3B:00 \\&gt;= v02.10.00 \\&gt;= v02.01.00 ❌ ❌ 59 Auto Power Down Set auto power down (id: 59) to 5 min (id: 4) 03:3B:01:04 01:3B:00 \\&gt;= v02.10.00 ✔ ✔ ✔ 59 Auto Power Down Set auto power down (id: 59) to 15 min (id: 6) 03:3B:01:06 01:3B:00 ❌ ✔ ✔ ✔ 59 Auto Power Down Set auto power down (id: 59) to 30 min (id: 7) 03:3B:01:07 01:3B:00 ❌ ✔ ✔ ✔ 59 Auto Power Down Set auto power down (id: 59) to 8 seconds (id: 11) 03:3B:01:0B 01:3B:00 \\&gt;= v02.10.00 ❌ ❌ ❌ 59 Auto Power Down Set auto power down (id: 59) to 30 seconds (id: 12) 03:3B:01:0C 01:3B:00 \\&gt;= v02.10.00 ❌ ❌ ❌ 121 Video Digital Lenses Set video digital lenses (id: 121) to wide (id: 0) 03:79:01:00 02:79:00 ✔ ✔ ✔ ✔ 121 Video Digital Lenses Set video digital lenses (id: 121) to narrow (id: 2) 03:79:01:02 02:79:00 ❌ ❌ ✔ ✔ 121 Video Digital Lenses Set video digital lenses (id: 121) to superview (id: 3) 03:79:01:03 02:79:00 ✔ ✔ ✔ ✔ 121 Video Digital Lenses Set video digital lenses (id: 121) to linear (id: 4) 03:79:01:04 02:79:00 ✔ ✔ ✔ ✔ 121 Video Digital Lenses Set video digital lenses (id: 121) to max superview (id: 7) 03:79:01:07 02:79:00 \\&gt;= v02.00.00 ✔ ✔ ✔ 121 Video Digital Lenses Set video digital lenses (id: 121) to linear + horizon leveling (id: 8) 03:79:01:08 02:79:00 ✔ ✔ ✔ ✔ 121 Video Digital Lenses Set video digital lenses (id: 121) to hyperview (id: 9) 03:79:01:09 02:79:00 ✔ ✔ ❌ ❌ 121 Video Digital Lenses Set video digital lenses (id: 121) to linear + horizon lock (id: 10) 03:79:01:0A 02:79:00 ✔ ✔ ❌ ❌ 122 Photo Digital Lenses Set photo digital lenses (id: 122) to narrow (id: 19) 03:7A:01:13 02:7A:00 ❌ ❌ ✔ ✔ 122 Photo Digital Lenses Set photo digital lenses (id: 122) to max superview (id: 100) 03:7A:01:64 02:7A:00 ❌ ✔ ✔ ✔ 122 Photo Digital Lenses Set photo digital lenses (id: 122) to wide (id: 101) 03:7A:01:65 02:7A:00 ❌ ✔ ✔ ✔ 122 Photo Digital Lenses Set photo digital lenses (id: 122) to linear (id: 102) 03:7A:01:66 02:7A:00 ❌ ✔ ✔ ✔ 123 Time Lapse Digital Lenses Set time lapse digital lenses (id: 123) to narrow (id: 19) 03:7B:01:13 02:7B:00 ❌ ❌ ✔ ✔ 123 Time Lapse Digital Lenses Set time lapse digital lenses (id: 123) to max superview (id: 100) 03:7B:01:64 02:7B:00 ❌ ✔ ✔ ❌ 123 Time Lapse Digital Lenses Set time lapse digital lenses (id: 123) to wide (id: 101) 03:7B:01:65 02:7B:00 ❌ ✔ ✔ ✔ 123 Time Lapse Digital Lenses Set time lapse digital lenses (id: 123) to linear (id: 102) 03:7B:01:66 02:7B:00 ❌ ✔ ✔ ✔ 128 Media Format Set media format (id: 128) to time lapse video (id: 13) 03:80:01:0D 02:80:00 ❌ ✔ ✔ ✔ 128 Media Format Set media format (id: 128) to time lapse photo (id: 20) 03:80:01:14 02:80:00 ❌ ✔ ✔ ✔ 128 Media Format Set media format (id: 128) to night lapse photo (id: 21) 03:80:01:15 02:80:00 ❌ ✔ ✔ ✔ 128 Media Format Set media format (id: 128) to night lapse video (id: 26) 03:80:01:1A 02:80:00 ❌ ✔ ✔ ✔ 134 Anti-Flicker Set setup anti flicker (id: 134) to 60hz (id: 2) 03:86:01:02 02:86:00 ✔ ✔ ✔ ✔ 134 Anti-Flicker Set setup anti flicker (id: 134) to 50hz (id: 3) 03:86:01:03 02:86:00 ✔ ✔ ✔ ✔ 135 Hypersmooth Set video hypersmooth (id: 135) to off (id: 0) 03:87:01:00 02:87:00 ✔ ✔ ✔ ✔ 135 Hypersmooth Set video hypersmooth (id: 135) to on (id: 1) 03:87:01:01 02:87:00 ✔ ✔ ❌ ✔ 135 Hypersmooth Set video hypersmooth (id: 135) to high (id: 2) 03:87:01:02 02:87:00 ❌ ❌ ✔ ✔ 135 Hypersmooth Set video hypersmooth (id: 135) to boost (id: 3) 03:87:01:03 02:87:00 ✔ ✔ ✔ ✔ 135 Hypersmooth Set video hypersmooth (id: 135) to auto boost (id: 4) 03:87:01:04 02:87:00 ✔ ✔ ❌ ❌ 135 Hypersmooth Set video hypersmooth (id: 135) to standard (id: 100) 03:87:01:64 02:87:00 ❌ ❌ ✔ ❌ 150 Horizon Leveling Set video horizon levelling (id: 150) to off (id: 0) 03:96:01:00 02:96:00 \\&gt;= v02.00.00 ✔ ❌ ❌ 150 Horizon Leveling Set video horizon levelling (id: 150) to on (id: 1) 03:96:01:01 02:96:00 \\&gt;= v02.00.00 ❌ ❌ ❌ 150 Horizon Leveling Set video horizon levelling (id: 150) to locked (id: 2) 03:96:01:02 02:96:00 ❌ ✔ ❌ ❌ 151 Horizon Leveling Set photo horizon levelling (id: 151) to off (id: 0) 03:97:01:00 02:97:00 ❌ ✔ ❌ ❌ 151 Horizon Leveling Set photo horizon levelling (id: 151) to locked (id: 2) 03:97:01:02 02:97:00 ❌ ✔ ❌ ❌ 162 Max Lens Set max lens (id: 162) to off (id: 0) 03:A2:01:00 02:A2:00 ❌ ✔ \\&gt;= v01.20.00 ✔ 162 Max Lens Set max lens (id: 162) to on (id: 1) 03:A2:01:01 02:A2:00 ❌ ✔ \\&gt;= v01.20.00 ✔ 173 Video Performance Mode Set video performance mode (id: 173) to maximum video performance (id: 0) 03:AD:01:00 02:AD:00 ❌ ❌ \\&gt;= v01.16.00 ❌ 173 Video Performance Mode Set video performance mode (id: 173) to extended battery (id: 1) 03:AD:01:01 02:AD:00 ❌ ❌ \\&gt;= v01.16.00 ❌ 173 Video Performance Mode Set video performance mode (id: 173) to tripod / stationary video (id: 2) 03:AD:01:02 02:AD:00 ❌ ❌ \\&gt;= v01.16.00 ❌ 175 Controls Set controls (id: 175) to easy (id: 0) 03:AF:01:00 02:AF:00 ✔ ✔ ❌ ❌ 175 Controls Set controls (id: 175) to pro (id: 1) 03:AF:01:01 02:AF:00 ✔ ✔ ❌ ❌ 176 Speed Set speed (id: 176) to 8x ultra slo-mo (id: 0) 03:B0:01:00 02:B0:00 ❌ ✔ ❌ ❌ 176 Speed Set speed (id: 176) to 4x super slo-mo (id: 1) 03:B0:01:01 02:B0:00 ❌ ✔ ❌ ❌ 176 Speed Set speed (id: 176) to 2x slo-mo (id: 2) 03:B0:01:02 02:B0:00 ❌ ✔ ❌ ❌ 176 Speed Set speed (id: 176) to 1x (low light) (id: 3) 03:B0:01:03 02:B0:00 ❌ ✔ ❌ ❌ 176 Speed Set speed (id: 176) to 4x super slo-mo (ext. batt) (id: 4) 03:B0:01:04 02:B0:00 ❌ ✔ ❌ ❌ 176 Speed Set speed (id: 176) to 2x slo-mo (ext. batt) (id: 5) 03:B0:01:05 02:B0:00 ❌ ✔ ❌ ❌ 176 Speed Set speed (id: 176) to 1x (ext. batt, low light) (id: 6) 03:B0:01:06 02:B0:00 ❌ ✔ ❌ ❌ 176 Speed Set speed (id: 176) to 8x ultra slo-mo (50hz) (id: 7) 03:B0:01:07 02:B0:00 ❌ ✔ ❌ ❌ 176 Speed Set speed (id: 176) to 4x super slo-mo (50hz) (id: 8) 03:B0:01:08 02:B0:00 ❌ ✔ ❌ ❌ 176 Speed Set speed (id: 176) to 2x slo-mo (50hz) (id: 9) 03:B0:01:09 02:B0:00 ❌ ✔ ❌ ❌ 176 Speed Set speed (id: 176) to 1x (low light, 50hz) (id: 10) 03:B0:01:0A 02:B0:00 ❌ ✔ ❌ ❌ 176 Speed Set speed (id: 176) to 4x super slo-mo (ext. batt, 50hz) (id: 11) 03:B0:01:0B 02:B0:00 ❌ ✔ ❌ ❌ 176 Speed Set speed (id: 176) to 2x slo-mo (ext. batt, 50hz) (id: 12) 03:B0:01:0C 02:B0:00 ❌ ✔ ❌ ❌ 176 Speed Set speed (id: 176) to 1x (ext. batt, low light, 50hz) (id: 13) 03:B0:01:0D 02:B0:00 ❌ ✔ ❌ ❌ 176 Speed Set speed (id: 176) to 8x ultra slo-mo (ext. batt) (id: 14) 03:B0:01:0E 02:B0:00 ❌ \\&gt;= v02.01.00 ❌ ❌ 176 Speed Set speed (id: 176) to 8x ultra slo-mo (ext. batt, 50hz) (id: 15) 03:B0:01:0F 02:B0:00 ❌ \\&gt;= v02.01.00 ❌ ❌ 176 Speed Set speed (id: 176) to 8x ultra slo-mo (long. batt) (id: 16) 03:B0:01:10 02:B0:00 ❌ \\&gt;= v02.01.00 ❌ ❌ 176 Speed Set speed (id: 176) to 4x super slo-mo (long. batt) (id: 17) 03:B0:01:11 02:B0:00 ❌ \\&gt;= v02.01.00 ❌ ❌ 176 Speed Set speed (id: 176) to 2x slo-mo (long. batt) (id: 18) 03:B0:01:12 02:B0:00 ❌ \\&gt;= v02.01.00 ❌ ❌ 176 Speed Set speed (id: 176) to 1x (long. batt, low light) (id: 19) 03:B0:01:13 02:B0:00 ❌ \\&gt;= v02.01.00 ❌ ❌ 176 Speed Set speed (id: 176) to 8x ultra slo-mo (long. batt, 50hz) (id: 20) 03:B0:01:14 02:B0:00 ❌ \\&gt;= v02.01.00 ❌ ❌ 176 Speed Set speed (id: 176) to 4x super slo-mo (long. batt, 50hz) (id: 21) 03:B0:01:15 02:B0:00 ❌ \\&gt;= v02.01.00 ❌ ❌ 176 Speed Set speed (id: 176) to 2x slo-mo (long. batt, 50hz) (id: 22) 03:B0:01:16 02:B0:00 ❌ \\&gt;= v02.01.00 ❌ ❌ 176 Speed Set speed (id: 176) to 1x (long. batt, low light, 50hz) (id: 23) 03:B0:01:17 02:B0:00 ❌ \\&gt;= v02.01.00 ❌ ❌ 176 Speed Set speed (id: 176) to 2x slo-mo (4k) (id: 24) 03:B0:01:18 02:B0:00 ❌ \\&gt;= v02.01.00 ❌ ❌ 176 Speed Set speed (id: 176) to 4x super slo-mo (2.7k) (id: 25) 03:B0:01:19 02:B0:00 ❌ \\&gt;= v02.01.00 ❌ ❌ 176 Speed Set speed (id: 176) to 2x slo-mo (4k, 50hz) (id: 26) 03:B0:01:1A 02:B0:00 ❌ \\&gt;= v02.01.00 ❌ ❌ 176 Speed Set speed (id: 176) to 4x super slo-mo (2.7k, 50hz) (id: 27) 03:B0:01:1B 02:B0:00 ❌ \\&gt;= v02.01.00 ❌ ❌ 177 Enable Night Photo Set enable night photo (id: 177) to off (id: 0) 03:B1:01:00 02:B1:00 ❌ ✔ ❌ ❌ 177 Enable Night Photo Set enable night photo (id: 177) to on (id: 1) 03:B1:01:01 02:B1:00 ❌ ✔ ❌ ❌ 178 Wireless Band Set wireless band (id: 178) to 2.4ghz (id: 0) 03:B2:01:00 02:B2:00 ✔ ✔ ❌ ❌ 178 Wireless Band Set wireless band (id: 178) to 5ghz (id: 1) 03:B2:01:01 02:B2:00 ✔ ✔ ❌ ❌ 179 Trail Length Set trail length (id: 179) to short (id: 1) 03:B3:01:01 02:B3:00 ✔ ✔ ❌ ❌ 179 Trail Length Set trail length (id: 179) to long (id: 2) 03:B3:01:02 02:B3:00 ✔ ✔ ❌ ❌ 179 Trail Length Set trail length (id: 179) to max (id: 3) 03:B3:01:03 02:B3:00 ✔ ✔ ❌ ❌ 180 Video Mode Set video mode (id: 180) to highest quality (id: 0) 03:B4:01:00 02:B4:00 ❌ ✔ ❌ ❌ 180 Video Mode Set video mode (id: 180) to extended battery (id: 1) 03:B4:01:01 02:B4:00 ❌ ✔ ❌ ❌ 180 Video Mode Set video mode (id: 180) to extended battery (green icon) (id: 101) 03:B4:01:65 02:B4:00 ❌ \\&gt;= v02.01.00 ❌ ❌ 180 Video Mode Set video mode (id: 180) to longest battery (green icon) (id: 102) 03:B4:01:66 02:B4:00 ❌ \\&gt;= v02.01.00 ❌ ❌ Camera Capabilities Camera capabilities usually change from one camera to another and often change from one release to the next. Below are documents that detail whitelists for basic video settings for every supported camera release. Note about Dependency Ordering and Blacklisting Capability documents define supported camera states. Each state is comprised of a set of setting options that are presented in dependency order. This means each state is guaranteed to be attainable if and only if the setting options are set in the order presented. Failure to adhere to dependency ordering may result in the camera's blacklist rules rejecting a set-setting command. Example Camera Command 1 Command 2 Command 3 Command 4 Command 5 Guaranteed Valid? HERO10 Black Res: 1080 Anti-Flicker: 60Hz (NTSC) FPS: 240 FOV: Wide Hypersmooth: OFF ✔ HERO10 Black FPS: 240 Anti-Flicker: 60Hz (NTSC) Res: 1080 FOV: Wide Hypersmooth: OFF ❌ In the example above, the first set of commands will always work for basic video presets such as Standard. In the second example, suppose the camera's Video Resolution was previously set to 4K. If the user tries to set Video FPS to 240, it will fail because 4K/240fps is not supported. Capability Documents Documents Product Release capabilities.xlsx capabilities.json HERO11 Black Mini v02.10.00 v02.00.00 v01.10.00 HERO11 Black v02.01.00 v01.20.00 v01.12.00 v01.10.00 HERO10 Black v01.50.00 v01.46.00 v01.42.00 v01.40.00 v01.30.00 v01.20.00 v01.16.00 v01.10.00 HERO9 Black v01.72.00 v01.70.00 Spreadsheet Format The capabilities spreadsheet contains worksheets for every supported release. Each row in a worksheet represents a whitelisted state and is presented in dependency order as outlined above. JSON Format The capabilities JSON contains a set of whitelist states for every supported release. Each state is comprised of a list of objects that contain setting and option IDs necessary to construct set-setting commands and are given in dependency order as outlined above. Below is a simplified example of the capabilities JSON file; a formal schema is also available here: capabilities_schema.json { \"(PRODUCT_NAME)\": { \"(RELEASE_VERSION)\": { \"states\": [ [ {\"setting_name\": \"(str)\", \"setting_id\": (int), \"option_name\": \"(str)\", \"option_id\": (int)}, ... ], ... ], }, ... }, ... } Query The camera provides two basic types of state information: Camera status and settings. Camera status info includes information such as the current preset/mode, whether the system is busy or encoding, remaining sdcard space, etc. Settings info gives the currently selected option for each setting; for example, this includes the current video resolution, frame rate, digital lens (FOV), etc. Queries are sent to to GP-0076 and responses are received on GP-0077. Query Command Format Header/Length Query ID Array of IDs 1-2 bytes 1 byte Variable Length Query Commands Note: omitting :xx:... from any (un)register command will result in being (un)registered for all associated values. Query ID Query Request Notes 0x12 Get setting value(s) nn:12:xx:... nn -&gt; message length xx -&gt; setting ID 0x12 Get all setting values 01:12 0x13 Get status value(s) nn:13:xx:... nn -&gt; message length xx -&gt; status ID 0x13 Get all status values 01:13 0x32 Get available option IDs for setting(s) nn:32:xx:... nn -&gt; message length xx -&gt; setting ID 0x32 Get available option IDs for all settings 01:32 0x52 Register for setting(s) value updates nn:52:xx:... nn -&gt; message length xx -&gt; setting ID 0x53 Register for status value updates nn:53:xx:... nn -&gt; message length xx -&gt; status ID 0x62 Register for available option updates for setting(s) nn:62:xx:... nn -&gt; message length xx -&gt; setting ID 0x72 Unregister for setting updates nn:72:xx:... nn -&gt; message length xx -&gt; setting ID 0x73 Unregister for status updates nn:73:xx:... nn -&gt; message length xx -&gt; status ID 0x82 Unregister for available option updates for setting(s) nn:82:xx:... nn -&gt; message length xx -&gt; setting ID 0x92 Async notification when setting changes 0x93 Async notification when status changes 0xA2 Async notification when available option(s) changed Query Response Format There are two types of response notifications: Type 1: Notfication sent in direct response to a get-value or register command Type 2: Notification sent in response to data changing (must be registered to receive) Message Length Query ID Command Status Status ID Status Value Length Status Value 1-2 bytes 1 byte 1 byte 1 byte 1 byte 1-255 bytes Multi-Value Responses When receiving a query response that contains information about more than one setting/status the Status ID, Status Value Length, and Status Value fields become collectively repeatable. Example: [MESSAGE LENGTH]:[QUERY ID]:[COMMAND STATUS]:[ID1]:[LENGTH1]:[VALUE1]:[ID2]:[LENGTH2]:[VALUE2]:... Query ID in Notifications In order to discern between a Type 1 and a Type 2 response, the camera changes the Query ID for Type 2: Query Query ID in Command Query ID in Notification Register for setting(s) value updates 0x52 0x92 Register for status value updates 0x53 0x93 Register for available option updates for setting(s) 0x62 0xA2 Status IDs Below is a table of supported status IDs. ✔ Indicates support for all Open GoPro firmware versions. ❌ Indicates a lack of support for all Open GoPro firmware versions. &gt;= vXX.YY.ZZ indicates support for firmware versions equal to or newer than vXX.YY.ZZ Status ID Name Description Type Values HERO11 Black Mini HERO11 Black HERO10 Black HERO9 Black 1 Internal battery present Is the system's internal battery present? boolean 0: False 1: True ✔ ✔ ✔ ✔ 2 Internal battery level Rough approximation of internal battery level in bars integer 0: Zero 1: One 2: Two 3: Three ✔ ✔ ✔ ✔ 6 System hot Is the system currently overheating? boolean 0: False 1: True ✔ ✔ ✔ ✔ 8 System busy Is the camera busy? boolean 0: False 1: True ✔ ✔ ✔ ✔ 9 Quick capture active Is Quick Capture feature enabled? boolean 0: False 1: True ✔ ✔ ✔ ✔ 10 Encoding active Is the system encoding right now? boolean 0: False 1: True ✔ ✔ ✔ ✔ 11 Lcd lock active Is LCD lock active? boolean 0: False 1: True ✔ ✔ ✔ ✔ 13 Video progress counter When encoding video, this is the duration (seconds) of the video so far; 0 otherwise integer * ✔ ✔ ✔ ✔ 17 Enable Are Wireless Connections enabled? boolean 0: False 1: True ✔ ✔ ✔ ✔ 19 State The pairing state of the camera integer 0: Never Started 1: Started 2: Aborted 3: Cancelled 4: Completed ✔ ✔ ✔ ✔ 20 Type The last type of pairing that the camera was engaged in integer 0: Not Pairing 1: Pairing App 2: Pairing Remote Control 3: Pairing Bluetooth Device ✔ ✔ ✔ ✔ 21 Pair time Time (milliseconds) since boot of last successful pairing complete action integer * ✔ ✔ ✔ ✔ 22 State State of current scan for WiFi Access Points. Appears to only change for CAH-related scans integer 0: Never started 1: Started 2: Aborted 3: Canceled 4: Completed ✔ ✔ ✔ ✔ 23 Scan time msec The time, in milliseconds since boot that the WiFi Access Point scan completed integer * ✔ ✔ ✔ ✔ 24 Provision status WiFi AP provisioning state integer 0: Never started 1: Started 2: Aborted 3: Canceled 4: Completed ✔ ✔ ✔ ✔ 26 Remote control version Wireless remote control version integer * ✔ ✔ ✔ ✔ 27 Remote control connected Is a wireless remote control connected? boolean 0: False 1: True ✔ ✔ ✔ ✔ 28 Pairing Wireless Pairing State integer * ✔ ✔ ✔ ✔ 29 Wlan ssid Provisioned WIFI AP SSID. On BLE connection, value is big-endian byte-encoded int string * ✔ ✔ ✔ ✔ 30 Ap ssid Camera's WIFI SSID. On BLE connection, value is big-endian byte-encoded int string * ✔ ✔ ✔ ✔ 31 App count The number of wireless devices connected to the camera integer * ✔ ✔ ✔ ✔ 32 Enable Is Preview Stream enabled? boolean 0: False 1: True ✔ ✔ ✔ ✔ 33 Sd status Primary Storage Status integer -1: Unknown 0: OK 1: SD Card Full 2: SD Card Removed 3: SD Card Format Error 4: SD Card Busy 8: SD Card Swapped ✔ ✔ ✔ ✔ 34 Remaining photos How many photos can be taken before sdcard is full integer * ❌ ✔ ✔ ✔ 35 Remaining video time How many minutes of video can be captured with current settings before sdcard is full integer * ✔ ✔ ✔ ✔ 36 Num group photos How many group photos can be taken with current settings before sdcard is full integer * ❌ ✔ ✔ ✔ 37 Num group videos Total number of group videos on sdcard integer * ✔ ✔ ✔ ✔ 38 Num total photos Total number of photos on sdcard integer * ✔ ✔ ✔ ✔ 39 Num total videos Total number of videos on sdcard integer * ✔ ✔ ✔ ✔ 41 Ota status The current status of Over The Air (OTA) update integer 0: Idle 1: Downloading 2: Verifying 3: Download Failed 4: Verify Failed 5: Ready 6: GoPro App: Downloading 7: GoPro App: Verifying 8: GoPro App: Download Failed 9: GoPro App: Verify Failed 10: GoPro App: Ready ✔ ✔ ✔ ✔ 42 Download cancel request pending Is there a pending request to cancel a firmware update download? boolean 0: False 1: True ✔ ✔ ✔ ✔ 45 Camera locate active Is locate camera feature active? boolean 0: False 1: True ✔ ✔ ✔ ✔ 49 Multi shot count down The current timelapse interval countdown value (e.g. 5...4...3...2...1...) integer * ✔ ✔ ✔ ✔ 54 Remaining space Remaining space on the sdcard in Kilobytes integer * ✔ ✔ ✔ ✔ 55 Supported Is preview stream supported in current recording/mode/secondary-stream? boolean 0: False 1: True ✔ ✔ ✔ ✔ 56 Wifi bars WiFi signal strength in bars integer * ✔ ✔ ✔ ✔ 58 Num hilights The number of hilights in encoding video (set to 0 when encoding stops) integer * ✔ ✔ ✔ ✔ 59 Last hilight time msec Time since boot (msec) of most recent hilight in encoding video (set to 0 when encoding stops) integer * ✔ ✔ ✔ ✔ 60 Next poll msec The min time between camera status updates (msec). Do not poll for status more often than this integer * ✔ ✔ ✔ ✔ 64 Remaining timelapse time How many min of Timelapse video can be captured with current settings before sdcard is full integer * ✔ ✔ ✔ ✔ 65 Exposure select type Liveview Exposure Select Mode integer 0: Disabled 1: Auto 2: ISO Lock 3: Hemisphere ❌ ✔ ✔ ✔ 66 Exposure select x Liveview Exposure Select: y-coordinate (percent) percent 0-100 ❌ ✔ ✔ ✔ 67 Exposure select y Liveview Exposure Select: y-coordinate (percent) percent 0-100 ❌ ✔ ✔ ✔ 68 Gps status Does the camera currently have a GPS lock? boolean 0: False 1: True ✔ ✔ ✔ ✔ 69 Ap state Is the WiFi radio enabled? boolean 0: False 1: True ✔ ✔ ✔ ✔ 70 Internal battery percentage Internal battery level (percent) percent 0-100 ✔ ✔ ✔ ✔ 74 Acc mic status Microphone Accesstory status integer 0: Microphone mod not connected 1: Microphone mod connected 2: Microphone mod connected and microphone plugged into Microphone mod ✔ ✔ ✔ ✔ 75 Digital zoom Digital Zoom level (percent) percent 0-100 ✔ ✔ ✔ ✔ 76 Wireless band Wireless Band integer 0: 2.4 GHz 1: 5 GHz 2: Max ✔ ✔ ✔ ✔ 77 Digital zoom active Is Digital Zoom feature available? boolean 0: False 1: True ✔ ✔ ✔ ✔ 78 Mobile friendly video Are current video settings mobile friendly? (related to video compression and frame rate) boolean 0: False 1: True ✔ ✔ ✔ ✔ 79 First time use Is the camera currently in First Time Use (FTU) UI flow? boolean 0: False 1: True ❌ ❌ ✔ ✔ 81 Band 5ghz avail Is 5GHz wireless band available? boolean 0: False 1: True ✔ ✔ ✔ ✔ 82 System ready Is the system ready to accept commands? boolean 0: False 1: True ✔ ✔ ✔ ✔ 83 Batt okay for ota Is the internal battery charged sufficiently to start Over The Air (OTA) update? boolean 0: False 1: True ✔ ✔ ✔ ✔ 85 Video low temp alert Is the camera getting too cold to continue recording? boolean 0: False 1: True ✔ ✔ ✔ ✔ 86 Actual orientation The rotational orientation of the camera integer 0: 0 degrees (upright) 1: 180 degrees (upside down) 2: 90 degrees (laying on right side) 3: 270 degrees (laying on left side) ✔ ✔ ✔ ✔ 88 Zoom while encoding Is this camera capable of zooming while encoding (static value based on model, not settings) boolean 0: False 1: True ✔ ✔ ✔ ✔ 89 Current mode Current flatmode ID integer * ✔ ✔ ✔ ✔ 93 Active video presets Current Video Preset (ID) integer * ✔ ✔ ✔ ✔ 94 Active photo presets Current Photo Preset (ID) integer * ❌ ✔ ✔ ✔ 95 Active timelapse presets Current Timelapse Preset (ID) integer * ✔ ✔ ✔ ✔ 96 Active presets group Current Preset Group (ID) integer * ✔ ✔ ✔ ✔ 97 Active preset Current Preset (ID) integer * ✔ ✔ ✔ ✔ 98 Preset modified Preset Modified Status, which contains an event ID and a preset (group) ID integer * ✔ ✔ ✔ ✔ 99 Remaining live bursts How many Live Bursts can be captured before sdcard is full integer * ❌ ✔ ✔ ✔ 100 Num total live bursts Total number of Live Bursts on sdcard integer * ❌ ✔ ✔ ✔ 101 Capture delay active Is Capture Delay currently active (i.e. counting down)? boolean 0: False 1: True ✔ ✔ ✔ ✔ 102 Media mod mic status Media mod State integer 0: Media mod microphone removed 2: Media mod microphone only 3: Media mod microphone with external microphone ✔ ✔ ✔ ✔ 103 Timewarp speed ramp active Time Warp Speed integer 0: 15x 1: 30x 2: 60x 3: 150x 4: 300x 5: 900x 6: 1800x 7: 2x 8: 5x 9: 10x 10: Auto 11: 1x (realtime) 12: 1/2x (slow-motion) ✔ ✔ ✔ ✔ 104 Linux core active Is the system's Linux core active? boolean 0: False 1: True ❌ ❌ ✔ ✔ 105 Camera lens type Camera lens type (reflects changes to setting 162) integer 0: Default 1: Max Lens ✔ ✔ ✔ ✔ 106 Video hindsight capture active Is Video Hindsight Capture Active? boolean 0: False 1: True ❌ ✔ ✔ ✔ 107 Scheduled preset Scheduled Capture Preset ID integer * ❌ ✔ ✔ ✔ 108 Scheduled enabled Is Scheduled Capture set? boolean 0: False 1: True ❌ ✔ ✔ ✔ 110 Media mod status Media Mode Status (bitmasked) integer 0: 000 = Selfie mod: 0, HDMI: 0, Media Mod Connected: False 1: 001 = Selfie mod: 0, HDMI: 0, Media Mod Connected: True 2: 010 = Selfie mod: 0, HDMI: 1, Media Mod Connected: False 3: 011 = Selfie mod: 0, HDMI: 1, Media Mod Connected: True 4: 100 = Selfie mod: 1, HDMI: 0, Media Mod Connected: False 5: 101 = Selfie mod: 1, HDMI: 0, Media Mod Connected: True 6: 110 = Selfie mod: 1, HDMI: 1, Media Mod Connected: False 7: 111 = Selfie mod: 1, HDMI: 1, Media Mod Connected: True ❌ ✔ ✔ ✔ 111 Sd rating check error Does sdcard meet specified minimum write speed? boolean 0: False 1: True ✔ ✔ ✔ ❌ 112 Sd write speed error Number of sdcard write speed errors since device booted integer * ✔ ✔ ✔ ❌ 113 Turbo transfer Is Turbo Transfer active? boolean 0: False 1: True ✔ ✔ ✔ ✔ 114 Camera control status Camera control status ID integer 0: Camera Idle: No one is attempting to change camera settings 1: Camera Control: Camera is in a menu or changing settings. To intervene, app must request control 2: Camera External Control: An outside entity (app) has control and is in a menu or modifying settings ✔ ✔ ✔ ❌ 115 Usb connected Is the camera connected to a PC via USB? boolean 0: False 1: True ✔ ✔ ✔ ❌ 116 Allow control over usb Camera control over USB state integer 0: Disabled 1: Enabled ✔ ✔ \\&gt;= v01.30.00 ❌ 117 Total sd space kb Total SD card capacity in kilobytes integer * ✔ ✔ ❌ ❌ Protobuf In order to maximize BLE bandwidth, some messages and their corresponding notifications utilize Google Protobuf (Protocol Buffers). Open GoPro currently uses Protocol Buffers Version 2. Note: All Protobuf messages (i.e. payloads, which are serialized protobuf objects) must be packetized and wrapped with Packet Headers as outlined in this document. Protobuf Message Format Protobuf communications with the camera differ from TLV-style communications. Rather than having a Type, Length, and Value, GoPro protobuf messages utilize the following: Feature ID: Indicates command type (e.g. command, setting, query) Action ID: Specific camera action; value indicates whether message was sent or an (aync) notification was received Value: Serialized protobuf object Requests Sent Message Length Feature ID Action ID Protobuf Bytestream 1-2 bytes 1 byte 1 byte Variable Length Notifications Received Message Length Feature ID Response Action ID Protobuf Bytestream 1-2 bytes 1 byte 1 byte Variable Length See Parsing Responses for details on how to detect and parse a protobuf response. Protobuf IDs Below is a table that links Protobuf Feature/Action IDs together with the UUIDs to write to and Response UUIDs to read notifications from. For additional details, see Services and Characteristics. Feature Feature ID Action IDs UUID Response UUID Network Management 0x02 0x02, 0x03, 0x04, 0x05, 0x0B, 0x0C, 0x82, 0x83, 0x84, 0x85 GP-0091 GP-0092 Command 0xF1 0x69, 0x6B, 0x78, 0x79, 0xE9, 0xEB, 0xF8, 0xF9 GP-0072 GP-0073 Query 0xF5 0x72, 0x74, 0xF2, 0xF3, 0xF4, 0xF5 GP-0076 GP-0077 Protobuf Commands Below is a table of protobuf commands that can be sent to the camera and their expected response. ✔ Indicates support for all Open GoPro firmware versions. ❌ Indicates a lack of support for all Open GoPro firmware versions. &gt;= vXX.YY.ZZ indicates support for firmware versions equal to or newer than vXX.YY.ZZ Feature ID Action ID Response Action ID Description Request Response HERO11 Black Mini HERO11 Black HERO10 Black HERO9 Black 0x02 0x02 0x82 Start scan RequestStartScan ResponseStartScanning ✔ ✔ ✔ ✔ 0x0B Async status update NotifStartScanning ✔ ✔ ✔ ✔ 0x03 0x83 Get ap entries RequestGetApEntries ResponseGetApEntries ✔ ✔ ✔ ✔ 0x04 0x84 Connect RequestConnect ResponseConnect ✔ ✔ ✔ ✔ 0x0C Async status update ResponseConnect ✔ ✔ ✔ ✔ 0x05 0x85 Connect new RequestConnectNew ResponseConnectNew ✔ ✔ ✔ ✔ 0x0C Async status update NotifProvisioningState ✔ ✔ ✔ ✔ 0xF1 0x69 0xE9 Request set camera control status RequestSetCameraControlStatus ResponseGeneric ✔ ✔ \\&gt;= v01.20.00 ❌ 0x6B 0xEB Request set turbo active RequestSetTurboActive ResponseGeneric ✔ ✔ ✔ ✔ 0x78 0xF8 Request release network RequestReleaseNetwork ResponseGeneric ✔ ✔ ✔ ✔ 0x79 0xF9 Request set live stream RequestSetLiveStreamMode ResponseGeneric ✔ ✔ ✔ ✔ 0xF5 0x72 0xF2 Request get preset status RequestGetPresetStatus NotifyPresetStatus ✔ ✔ ✔ ✔ 0xF3 Async status update NotifyPresetStatus ✔ ✔ ✔ ✔ 0x74 0xF4 Request get live stream status RequestGetLiveStreamStatus NotifyLiveStreamStatus ✔ ✔ ✔ ✔ 0xF5 Async status update NotifyLiveStreamStatus ✔ ✔ ✔ ✔ Features Below are details about Open GoPro features. Presets The camera organizes modes of operation into presets. A preset is a logical wrapper around a specific camera mode, title, icon, and a set of settings that enhance different styles of capturing media. Depending on the camera's state, different collections of presets will be available for immediate loading and use. Below is a table of settings that affect the current preset collection and thereby which presets can be loaded: ID Setting 162 Max Lens 173 Video Performance Mode 175 Controls 177 Enable Night Photo 180 Video Mode To determine which presets are available for immediate use, get Preset Status. Preset Status All cameras support basic query and subscription mechanics that allow the user to: Get hierarchical data describing the Preset Groups, Presets, and Settings that are available in the camera's current state (Un)register to be notified when a Preset is modified (e.g. resolution changes from 1080p to 4K) or a Preset Group is modified (e.g. presets are reordered/created/deleted) Preset Status should not be confused with camera status: Preset Status contains information about current preset groups and presets Camera status contains numerous statuses about current settings and camera system state Preset Groups Each Preset Group contains an ID, whether additional presets can be added, and an array of existing Presets. Presets Each Preset contains information about its ID, associated core mode, title, icon, whether it's a user-defined preset, whether the preset has been modified from its factory-default state (for factory-default presets only) and an array of Settings associated with the Preset. Important Note: The Preset ID is required to load a Preset via the Presets: Load command. For details on which cameras are supported and how to get Preset Status, see Protobuf Commands. Global Behaviors In order to prevent undefined behavior between the camera and a connected app, simultaneous use of the camera and a connected app is discouraged. Best practice for synchronizing user/app control is to use the Set Camera Control Status command and corresponding Camera Control Status (CCS) camera statuses in alignment with the finite state machine below: IDLEControl Status: IdleCAMERA_CONTROLControl Status: Camera ControlEXTERNAL_CONTROLControl Status: External ControlApp sets CCS: IdleUser interacts with cameraUser returns camera to idle screenApp sets CCS: IdleApp sets CCS: External ControlApp sets CCS: IdleUser interacts with cameraUser interacts with cameraApp sets CCS: External ControlUser interacts with camera Control Status ID IDLE 0 CONTROL 1 EXTERNAL_CONTROL 2 Set Camera Control Status This command is used to tell the camera that the app (i.e. External Control) wishes to claim control of the camera. This causes the camera to immediately exit any contextual menus and return to the idle screen. Any interaction with the camera's physical buttons will cause the camera to reclaim control and update control status accordingly. If the user returns the camera UI to the idle screen, the camera updates control status to Idle. Note: The entity currently claiming control of the camera is advertised in camera status 114 Information about whether the camera is in a contextual menu or not is advertised in camera status 63. For details on which cameras are supported and how to set Camera Control Status, see Protobuf Commands. Interface with Access Points The camera supports connecting to access points in Station Mode (STA). This is necessary for features such as Live Streaming, where the camera needs an Internet connection. While in this mode, HTTP command and control of the camera is not available on some cameras. Scanning for Access Points In order to scan for Access Points, use the flow below. See Protobuf Commands for command details. CentralCentralGP-0091GP-0091GP-0092GP-0092RequestStartScanResponseStartScanningscanning_state: EnumScanning.SCANNING_STARTEDloop[until scanning_state == EnumScanning.SCANNING_SUCCESS]Indicates scan is completeSave scan_id, total_entriesNotifStartScanningRequestGetApEntriesUse scan_id, total_entriesResponseGetApEntriesEach ScanEntry contains SSID, signal strength, freq Scan Results The ResponseGetApEntries message contains information about each discovered device. This information includes the success of the scan, the scan id used in the original request, and a ScanEntry message, whose definition is nested inside ResponseGetApEntries. A ScanEntry includes information about a discovered device including its SSID, relative signal strength, signal frequency, and a bitmasked scan_entry_flags value whose individual bits are defined by EnumScanEntryFlags. Note: When scan_entry_flags contains SCAN_FLAG_CONFIGURED, it is an indication that this network has already been provisioned. Connect to a New Access Point To provision and connect the camera to a new Access Point, use RequestConnectNew. Note: This should only be done once to provision the AP; subsequent connections should use RequestConnect. CentralCentralGP-0091GP-0091GP-0092GP-0092Scan for Access PointsRequestConnectNewResponseConnectNewprovisioning_state: EnumProvisioning.PROVISIONING_STARTEDloop[until provisioning_state == EnumProvisioning.PROVISIONING_SUCCESS_NEW_AP]NotifProvisionState Connect to a Provisioned Access Point To connect the camera to a provisioned Access Point, scan for Access Points and connect using RequestConnect: CentralCentralGP-0091GP-0091GP-0092GP-0092Scan for Access PointsRequestConnectResponseConnectprovisioning_state: EnumProvisioning.PROVISIONING_STARTEDloop[until provisioning_state == EnumProvisioning.PROVISIONING_SUCCESS_NEW_AP]NotifProvisionState Disconnect from an Access Point To disconnect from a connected Access Point and return the camera to AP mode, use RequestReleaseNetwork. CentralCentralGP-0091GP-0091GP-0092GP-0092Scan for Access PointsConnect to a New/Provisioned Access Point(Camera: STA Mode)RequestReleaseNetworkResponseGeneric(Camera: AP Mode) Turbo Transfer Some cameras support Turbo Transfer mode, which allows media to be downloaded over WiFi more rapidly. This is done by temporarily modifying low-level settings in the OS to prioritize WiFi offload speeds. When Turbo Transfer is active, theh camera displays an OSD indicating that media is being transferred in order to prevent the user from inadvertently changing settings or capturing media. Turbo Transfer should only be used during media offload. It is recommended that the user check for and--if necessary--disable Turbo Transfer on connect. Developers can query whether the camera is currently in Turbo Transfer Mode from camera status 113. Note: Pressing MODE/POWER or Shutter buttons on the camera will deactivate Turbo Transfer feature. Some cameras are already optimized for WiFi transfer and do not gain additional speed from this feature. For details on which cameras are supported and how to enable and disable Turbo Transfer, see Protobuf Commands. Live Streaming The camera supports the ability to stream to social media platforms such as Twitch, YouTube, and Facebook or any other site that accepts RTMP URLs. For additional details about getting started with RTMP, see How to Stream. Overview Live streaming with camera is accomplished as follows: Put the camera into Station Mode and connect it to an access point (see Interface With Access Points) Set the Live Stream Mode Poll for Live Stream Status until the camera indicates it is ready Set any desired settings (e.g. Hypersmooth) Set the shutter to begin live streaming Unset the shutter to stop live streaming Live Streaming Sequence CentralCentralGP-0091GP-0091GP-0092GP-0092GP-0072GP-0072GP-0073GP-0073GP-0074GP-0074GP-0075GP-0075GP-0076GP-0076GP-0077GP-0077Set Live Stream ModeRequestSetLiveStreamModeResponseGenericPoll Live Stream Status until readyloop[until LIVE_STREAM_STATE_READY]RequestGetLiveStreamStatusNotifyLiveStreamStatusSet desired settingsloop[until Desired camera state attained]Set settingResponseStart live streaming!Set shutterresponseStop live streamingUnset shutterresponse Set Live Stream Mode Setting the live stream mode is accomplished by sending a RequestSetLiveStreamMode command. Command and enum details are available in Protobuf Comands. Parameter Type Description url string RTMP url used to stream. Set to empty string to invalidate/cancel stream encode bool Whether to encode video to sdcard while streaming or not window_size EnumWindowSize Streaming video resolution cert string Certificate from a trusted root for streaming services that use encryption minimum_bitrate int32 Desired minimum streaming bitrate (min possible: 800) maximum_bitrate int32 Desired maximum streaming bitrate (max possible: 8000) starting_bitrate int32 Initial streaming bitrate (honored if 800 &lt;= value &lt;= 8000) lens EnumLens Streaming Field of View Get Live Stream Status Current status of the live stream is obtained by sending a RequestGetLiveStreamStatus command to the camera. This command serves two purposes: Get current state of the live stream (Un)register to be notified when live stream state changes Responses and notifications come as a NotifyLiveStreamStatus message with properties outlined in the table below. Command and enum details are available in Protobuf Comands. Parameter Type Description live_stream_status EnumLiveStreamStatus Basic streaming state (idle, ready, streaming, failed, etc) live_stream_error EnumLiveStreamError Error codes for specific streaming errors live_stream_encode bool Whether camera is encoding video to sdcard while encoding or not live_stream_bitrate int32 Current streaming bitrate (Kbps) live_stream_window_size_supported_array EnumWindowSize Defines supported streaming resolutions live_stream_encode_supported bool Does this camera support encoding while streaming? live_stream_max_lens_unsupported bool Does camera lack support for streaming with Max Lens feature? live_stream_minimum_stream_bitrate int32 Minimum possible bitrate (static) (Kbps) live_stream_maximum_stream_bitrate int32 Maximum possible bitrate (static) (Kbps) live_stream_lens_supported bool Does camera support multiple streaming FOVs? live_stream_lens_supported_array EnumLens Defines supported Field of View values",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/ble_2_0#"
        },
        {
            "title": "Demos: ",
            "excerpt": "Bash Over the Air Firmware Update Demo A bash script to perform an over-the-air (OTA) firmware update C Cpp GoPro C/C++ Demos Two C / C++ demos to send media commands and start/stop the preview GoPro Low Latency Stream Demo Low latency webcam/preview stream Csharp GoProCSharpSample A C demo for discovering, pairing, connecting and controlling a camera CSharp Webcam Demo A C demo to demonstrate webcam functionality Python Multi Webcam A python demo for configuring and viewing multiple webcams from one computing device Open GoPro Python SDK A Python package to easily exercise the Open GoPro API’s + CLI’s for taking pictures, videos, etc Swift Swift Enable WiFi Demo A swift demo for discovering, connecting and enabling Wi-Fi on a GoPro camera",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/demos#"
        },
        {
            "title": "FAQ and Known Issues: ",
            "excerpt": "Frequently Asked Questions (FAQ) If you have somehow stumbled here first, note that there are specifications, demos, and tutorials which expand upon much of the information here. These can be found, among other places, from the home page. Connectivity What is the distance from the camera that BLE will still work? It is standard Bluetooth 4.0 range and it depends on external factors such as: Interference: anything interfering with the signal will shorten the range. The type of device that the camera is connected to: BT classification distinguishes 3 device classes based on their power levels. Depending on the class of the connected device, the range varies from less than 10 meters to 100 meters. Can I connect using WiFi only? Theoretically yes, if you already know the SSID, password, and the camera’s WiFi AP has been enabled. However, practically no because BLE is required in order to discover this information and configure the AP. Can I connect using BLE only? Yes, however there is some functionality that is not possible over BLE such as accessing the media list and downloading files. How many devices can connect to the camera? Simultaneously, only one device can connect at a time. However, the camera stores BLE security keys and other connection information so it is possible to connect multiple devices sequentially. General Is preview turned off during record for all video settings? Yes, preview is disabled during record on all video settings. How can I view the live stream? In VLC, for example, you need to open network stream udp://@0.0.0.0:8554. You may see some latency due to VLC caching. See the Preview Stream tutorial for more information. Which cameras are supported by Open GoPro? The answer at a high level is &gt;= Hero 9. However, there are also certain firmware requirements. For a complete answer, see the Specification. Troubleshooting If you are able to consistently reproduce a problem, please file a bug on Github Issues Why is the camera not advertising? If you have not yet paired to the camera with the desired device, then you need to first set the camera into pairing mode (Connections-&gt;Connect Device-&gt;Quick App). If you have already paired, then the camera should be advertising and ready to connect. If it is not advertising, it is possible you are already connected to it from a previous session. To be sure, power cycle both the camera and the peer device. Workaround for intermittent Wifi AP Connection failure On &gt;= Hero 11, try disabling and then re-enabling the camera’s Wifi AP using the AP Control BLE Command Known Issues Relevant to All Supported Cameras Webcam does not enter idle mode once plugged in The webcam state will be wrongly reported as idle after a new USB connection. The best workaround for this is to call Webcam Start followed by Webcam Stop after connecting USB in order to attain the true idle state. Intermittent failure to connect to the cameras Wifi Access Point On rare occasions, connections to the camera’s Wifi AP will continuously fail until the camera is reset. It is possible to workaround this as described in Troubleshooting Spurious Protobuf Notifications sent once camera is connected in Station mode Once the camera has been connected in station mode (STA), it will start sending protobuf notifications with action ID 0xFF. These should be ignored. Hero 11 (v01.10.00) Specific Wired Communication is broken after update mode This is fixed by Resetting Connections and then re-pairing.",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/faq#"
        },
        {
            "title": "HTTP Specification v2.0: ",
            "excerpt": "Overview The GoPro API allows developers to create apps and utilities that interact with and control a GoPro camera. What can you do with the GoPro API? The GoPro API allows you to control and query the camera: Capture photo/video media Get media list Change settings Get and set the date/time Get camera status Get media metadata (file size, width, height, duration, tags, etc) and more! Supported Cameras Below is a table of cameras that support GoPro's public HTTP API: Model ID Model Code Marketing Name Minimal Firmware Version 60 H22.03 HERO11 Black Mini v01.10.00 58 H22.01 HERO11 Black v01.10.00 57 H21.01 HERO10 Black v01.10.00 55 HD9.01 HERO9 Black v01.70.00 The Basics Connection WiFi Connection to the camera via WiFi requires that the camera's WiFi Access Point be enabled. This can be done by connecting to the camera via Bluetooth Low Energy (BLE) and sending the AP Control command: WIFI AP ON. USB OpenGoPro systems that utilize USB must support the Network Control Model (NCM) protocol. Connecting via USB requires the following steps: Physically connect the camera's USB-C port to your system Send HTTP command to enable wired USB control Authentication WiFi Once the WiFi Access Point has been turned on, authentication with the camera simply requries connecting with the correct SSID and password. This information can be obtained in two ways: Put the camera into pairing mode and tap the info button in the top-right corner of the screen. Read the SSID/password directly via Bluetooth Low Energy. See Services and Characteristics seciton in BLE Specification for details. USB No authentication is necessary. Socket Address WiFi The socket address for WiFi connections is 10.5.5.9:8080. USB The socket address for USB connections is 172.2X.1YZ.51:8080 where: X is the 100's digit from the camera serial number Y is the 10's digit from the camera serial number Z is the 1's digit from the camera serial number The camera's serial number can be obtained in any of the following ways: Reading the sticker inside the camera's battery enclosure Camera UI: Preferences &gt;&gt; About &gt;&gt; Camera Info Bluetooth Low Energy by reading directly from Hardware Info . See Commands in BLE Specification for details. For example, if the camera's serial number is C0000123456789, the IP address for USB connections would be 172.27.189.51. Alternatively, the IP address can be discovered via mDNS as the camera registers the _gopro-web service. Request and Response Formats Most commands are sent via HTTP/GET and require no special headers. Responses come in two parts: The standard HTTP return codes and JSON containing any additional information. The typical use case is that the camera accepts a valid command, returns HTTP/200 (OK) and empty JSON (i.e. { }) and begins asynchronously working on the command. If an error occurs, the camera will return a standard HTTP error code and JSON with helpful error/debug information. Depending on the command sent, the camera can return JSON, binary, or Protobuf data. Some examples are listed below: Command Return Type Get Camera State JSON Get Media Info JSON Get Media GPMF Binary Get Media List JSON Get Media Screennail (JPEG) Binary Get Media Thumbnail (JPEG) Binary Get Presets JSON Sending Commands Depending on the camera's state, it may not be ready to accept specific commands. This ready state is dependent on the System Busy and the Encoding Active status flags. For example: System Busy flag is set while loading presets, changing settings, formatting sdcard, ... Encoding Active flag is set while capturing photo/video media If the system is not ready, it should reject an incoming command; however, best practice is to always wait for the System Busy and Encode Active flags to be unset before sending messages other than camera status queries. For details regarding camera state, see Status Codes. Keep Alive In order to maximize battery life, GoPro cameras automatically go to sleep after some time. This logic is handled by a combination of an Auto Power Down setting which most (but not all) cameras support and a Keep Alive message that the user can regularly send to the camera. The camera will automatically go to sleep if both timers reach zero. The Auto Power Down timer is reset when the user taps the LCD screen, presses a button on the camera or programmatically (un)sets the shutter, sets a setting, or loads a Preset. The Keep Alive timer is reset when the user sends a keep alive message. The best practice to prevent the camera from inadvertently going to sleep is to start sending Keep Alive messages every 3.0 seconds after a connection is established. Command HTTP/GET Description /gopro/camera/keep_alive Send keep-alive Commands Using the Open GoPro API, a client can perform various command, control, and query operations! Commands Quick Reference Below is a table of commands that can be sent to the camera and how to send them. ✔ Indicates support for all Open GoPro firmware versions. ❌ Indicates a lack of support for all Open GoPro firmware versions. &gt;= vXX.YY.ZZ indicates support for firmware versions equal to or newer than vXX.YY.ZZ Command Description HTTP Method Endpoint HERO11 Black Mini HERO11 Black HERO10 Black HERO9 Black Analytics Set third party client GET /gopro/camera/analytics/set_client_info ✔ ✔ \\&gt;= v01.30.00 \\&gt;= v01.70.00 Camera: Get State Get camera state (status + settings) GET /gopro/camera/state ✔ ✔ ✔ ✔ Digital Zoom Digital zoom 50% GET /gopro/camera/digital_zoom?percent=50 ✔ ✔ ✔ ✔ Get Date/Time Get date/time GET /gopro/camera/get_date_time ✔ ✔ \\&gt;= v01.30.00 \\&gt;= v01.70.00 Keep-alive Send keep-alive GET /gopro/camera/keep_alive ✔ ✔ ✔ ✔ Media: GPMF Get GPMF data (JPG) GET /gopro/media/gpmf?path=100GOPRO/XXX.JPG ✔ ✔ ✔ ✔ Media: GPMF Get GPMF data (MP4) GET /gopro/media/gpmf?path=100GOPRO/XXX.MP4 ✔ ✔ ✔ ✔ Media: HiLight (Add) Add hilight to 100GOPRO/xxx.JPG GET /gopro/media/hilight/file?path=100GOPRO/XXX.JPG ✔ ✔ \\&gt;= v01.30.00 \\&gt;= v01.70.00 Media: HiLight (Add) Add hilight to 100GOPRO/xxx.MP4 at offset 2500 ms GET /gopro/media/hilight/file?path=100GOPRO/XXX.MP4&amp;ms=2500 ✔ ✔ \\&gt;= v01.30.00 \\&gt;= v01.70.00 Media: HiLight (Remove) Remove hilight from 100GOPRO/xxx.JPG GET /gopro/media/hilight/remove?path=100GOPRO/XXX.JPG ✔ ✔ \\&gt;= v01.30.00 \\&gt;= v01.70.00 Media: HiLight (Remove) Remove hilight from 100GOPRO/xxx.MP4 at offset 2500ms GET /gopro/media/hilight/remove?path=100GOPRO/XXX.MP4&amp;ms=2500 ✔ ✔ \\&gt;= v01.30.00 \\&gt;= v01.70.00 Media: HiLight Moment Hilight moment during encoding GET /gopro/media/hilight/moment ✔ ✔ \\&gt;= v01.30.00 ❌ Media: Info Get media info (JPG) GET /gopro/media/info?path=100GOPRO/XXX.JPG ✔ ✔ ✔ ✔ Media: Info Get media info (MP4) GET /gopro/media/info?path=100GOPRO/XXX.MP4 ✔ ✔ ✔ ✔ Media: List Get media list GET /gopro/media/list ✔ ✔ ✔ ✔ Media: Screennail Get screennail for \"100GOPRO/xxx.JPG\" GET /gopro/media/screennail?path=100GOPRO/XXX.JPG ✔ ✔ ✔ ✔ Media: Screennail Get screennail for \"100GOPRO/xxx.MP4\" GET /gopro/media/screennail?path=100GOPRO/XXX.MP4 ✔ ✔ ✔ ✔ Media: Telemetry Get telemetry track data (JPG) GET /gopro/media/telemetry?path=100GOPRO/XXX.JPG ✔ ✔ ✔ ✔ Media: Telemetry Get telemetry track data (MP4) GET /gopro/media/telemetry?path=100GOPRO/XXX.MP4 ✔ ✔ ✔ ✔ Media: Thumbnail Get thumbnail for \"100GOPRO/xxx.JPG\" GET /gopro/media/thumbnail?path=100GOPRO/XXX.JPG ✔ ✔ ✔ ✔ Media: Thumbnail Get thumbnail for \"100GOPRO/xxx.MP4\" GET /gopro/media/thumbnail?path=100GOPRO/XXX.MP4 ✔ ✔ ✔ ✔ Media: Turbo Transfer Turbo transfer: off GET /gopro/media/turbo_transfer?p=0 ✔ ✔ ✔ ✔ Media: Turbo Transfer Turbo transfer: on GET /gopro/media/turbo_transfer?p=1 ✔ ✔ ✔ ✔ OTA Update Soft update: upload 12345 bytes starting at offset 67890 POST /gp/gpSoftUpdate (plus data) ✔ ✔ ✔ ✔ OTA Update Soft update: mark upload complete POST /gp/gpSoftUpdate (plus data) ✔ ✔ ✔ ✔ OTA Update Ota update: show canceled/failed ui on the camera GET /gp/gpSoftUpdate?request=canceled ✔ ✔ ✔ ✔ OTA Update Ota update: delete cached update files GET /gp/gpSoftUpdate?request=delete ✔ ✔ ✔ ✔ OTA Update Ota update: get current update state GET /gp/gpSoftUpdate?request=progress ✔ ✔ ✔ ✔ OTA Update Ota update: display update ui on camera GET /gp/gpSoftUpdate?request=showui ✔ ✔ ✔ ✔ OTA Update Ota update: initiate firmware update GET /gp/gpSoftUpdate?request=start ✔ ✔ ✔ ✔ Open GoPro Get version GET /gopro/version ✔ ✔ ✔ ✔ Presets: Get Status Get preset status GET /gopro/camera/presets/get ✔ ✔ ✔ ✔ Presets: Load Example preset id: 0x1234ABCD GET /gopro/camera/presets/load?id=305441741 ✔ ✔ ✔ ✔ Presets: Load Group Video GET /gopro/camera/presets/set_group?id=1000 ✔ ✔ ✔ ✔ Presets: Load Group Photo GET /gopro/camera/presets/set_group?id=1001 ❌ ✔ ✔ ✔ Presets: Load Group Timelapse GET /gopro/camera/presets/set_group?id=1002 ❌ ✔ ✔ ✔ Set Camera Control Status Set camera control status to idle GET /gopro/camera/control/set_ui_controller?p=0 ✔ ✔ \\&gt;= v01.20.00 ❌ Set Camera Control Status Set camera control status to external_control GET /gopro/camera/control/set_ui_controller?p=2 ✔ ✔ \\&gt;= v01.20.00 ❌ Set Date/Time Set date/time to 2023-01-31 03:04:05 GET /gopro/camera/set_date_time?date=2023_1_31&amp;time=3_4_5 ✔ ✔ \\&gt;= v01.30.00 \\&gt;= v01.70.00 Set Local Date/Time Set local date/time to: 2023-01-31 03:04:05 (utc-02:00) (dst: on) GET /gopro/camera/set_date_time?date=2023_1_31&amp;time=3_4_5&amp;tzone=-120&amp;dst=1 ✔ ✔ ❌ ❌ Set shutter Shutter: on GET /gopro/camera/shutter/start ✔ ✔ ✔ ❌ Set shutter Shutter: off GET /gopro/camera/shutter/stop ✔ ✔ ✔ ❌ Stream: Start Start preview stream GET /gopro/camera/stream/start ✔ ✔ ✔ ✔ Stream: Stop Stop preview stream GET /gopro/camera/stream/stop ✔ ✔ ✔ ✔ Webcam: Exit Exit webcam mode GET /gopro/webcam/exit ❌ ✔ ✔ ❌ Webcam: Preview Start preview stream GET /gopro/webcam/preview ❌ ✔ ✔ ❌ Webcam: Start Start webcam GET /gopro/webcam/start ❌ ✔ \\&gt;= v01.40.00 ❌ Webcam: Start Start webcam GET /gopro/webcam/start?port=12345 ❌ \\&gt;= v02.01.00 ❌ ❌ Webcam: Start Start webcam (res: resolution_1080, fov: wide) GET /gopro/webcam/start?res=12&amp;fov=0 ❌ ✔ ✔ ❌ Webcam: Status Get webcam status GET /gopro/webcam/status ❌ ✔ ✔ ❌ Webcam: Stop Stop webcam GET /gopro/webcam/stop ❌ ✔ ✔ ❌ Webcam: Version Get webcam api version GET /gopro/webcam/version ❌ ✔ ✔ ❌ Wired USB Control Disable wired usb control GET /gopro/camera/control/wired_usb?p=0 ✔ ✔ \\&gt;= v01.30.00 ❌ Wired USB Control Enable wired usb control GET /gopro/camera/control/wired_usb?p=1 ✔ ✔ \\&gt;= v01.30.00 ❌ Settings GoPro cameras have hundreds of setting options to choose from, all of which can be set using a single endpoint. The endpoint is configured with a setting id and an option value. Note that setting option values are not globally unique. While most option values are enumerated values, some are complex bitmasked values. Settings Quick Reference Below is a table of setting options detailing how to set every option supported by Open GoPro cameras. ✔ Indicates support for all Open GoPro firmware versions. ❌ Indicates a lack of support for all Open GoPro firmware versions. &gt;= vXX.YY.ZZ indicates support for firmware versions equal to or newer than vXX.YY.ZZ Setting ID Setting Option HTTP Method Endpoint HERO11 Black Mini HERO11 Black HERO10 Black HERO9 Black 2 Resolution Set video resolution (id: 2) to 4k (id: 1) GET /gopro/camera/setting?setting=2&amp;option=1 ✔ ✔ ✔ ✔ 2 Resolution Set video resolution (id: 2) to 2.7k (id: 4) GET /gopro/camera/setting?setting=2&amp;option=4 ✔ ✔ ✔ ✔ 2 Resolution Set video resolution (id: 2) to 2.7k 4:3 (id: 6) GET /gopro/camera/setting?setting=2&amp;option=6 ✔ ✔ ✔ ✔ 2 Resolution Set video resolution (id: 2) to 1440 (id: 7) GET /gopro/camera/setting?setting=2&amp;option=7 ❌ ❌ ❌ ✔ 2 Resolution Set video resolution (id: 2) to 1080 (id: 9) GET /gopro/camera/setting?setting=2&amp;option=9 ✔ ✔ ✔ ✔ 2 Resolution Set video resolution (id: 2) to 4k 4:3 (id: 18) GET /gopro/camera/setting?setting=2&amp;option=18 ✔ ✔ ✔ ✔ 2 Resolution Set video resolution (id: 2) to 5k (id: 24) GET /gopro/camera/setting?setting=2&amp;option=24 ❌ ❌ ❌ ✔ 2 Resolution Set video resolution (id: 2) to 5k 4:3 (id: 25) GET /gopro/camera/setting?setting=2&amp;option=25 ❌ ❌ ✔ ❌ 2 Resolution Set video resolution (id: 2) to 5.3k 8:7 (id: 26) GET /gopro/camera/setting?setting=2&amp;option=26 ✔ ✔ ❌ ❌ 2 Resolution Set video resolution (id: 2) to 5.3k 4:3 (id: 27) GET /gopro/camera/setting?setting=2&amp;option=27 ✔ ✔ ❌ ❌ 2 Resolution Set video resolution (id: 2) to 4k 8:7 (id: 28) GET /gopro/camera/setting?setting=2&amp;option=28 ✔ ✔ ❌ ❌ 2 Resolution Set video resolution (id: 2) to 5.3k (id: 100) GET /gopro/camera/setting?setting=2&amp;option=100 ✔ ✔ ✔ ❌ 3 Frames Per Second Set video fps (id: 3) to 240 (id: 0) GET /gopro/camera/setting?setting=3&amp;option=0 ✔ ✔ ✔ ✔ 3 Frames Per Second Set video fps (id: 3) to 120 (id: 1) GET /gopro/camera/setting?setting=3&amp;option=1 ✔ ✔ ✔ ✔ 3 Frames Per Second Set video fps (id: 3) to 100 (id: 2) GET /gopro/camera/setting?setting=3&amp;option=2 ✔ ✔ ✔ ✔ 3 Frames Per Second Set video fps (id: 3) to 60 (id: 5) GET /gopro/camera/setting?setting=3&amp;option=5 ✔ ✔ ✔ ✔ 3 Frames Per Second Set video fps (id: 3) to 50 (id: 6) GET /gopro/camera/setting?setting=3&amp;option=6 ✔ ✔ ✔ ✔ 3 Frames Per Second Set video fps (id: 3) to 30 (id: 8) GET /gopro/camera/setting?setting=3&amp;option=8 ✔ ✔ ✔ ✔ 3 Frames Per Second Set video fps (id: 3) to 25 (id: 9) GET /gopro/camera/setting?setting=3&amp;option=9 ✔ ✔ ✔ ✔ 3 Frames Per Second Set video fps (id: 3) to 24 (id: 10) GET /gopro/camera/setting?setting=3&amp;option=10 ✔ ✔ ✔ ✔ 3 Frames Per Second Set video fps (id: 3) to 200 (id: 13) GET /gopro/camera/setting?setting=3&amp;option=13 ✔ ✔ ✔ ✔ 43 Webcam Digital Lenses Set webcam digital lenses (id: 43) to wide (id: 0) GET /gopro/camera/setting?setting=43&amp;option=0 ✔ ✔ ✔ ✔ 43 Webcam Digital Lenses Set webcam digital lenses (id: 43) to narrow (id: 2) GET /gopro/camera/setting?setting=43&amp;option=2 ✔ ✔ ✔ ✔ 43 Webcam Digital Lenses Set webcam digital lenses (id: 43) to superview (id: 3) GET /gopro/camera/setting?setting=43&amp;option=3 ✔ ✔ ✔ ✔ 43 Webcam Digital Lenses Set webcam digital lenses (id: 43) to linear (id: 4) GET /gopro/camera/setting?setting=43&amp;option=4 ✔ ✔ ✔ ✔ 59 Auto Power Down Set auto power down (id: 59) to never (id: 0) GET /gopro/camera/setting?setting=59&amp;option=0 \\&gt;= v02.10.00 ✔ ✔ ✔ 59 Auto Power Down Set auto power down (id: 59) to 1 min (id: 1) GET /gopro/camera/setting?setting=59&amp;option=1 \\&gt;= v02.10.00 \\&gt;= v02.01.00 ❌ ❌ 59 Auto Power Down Set auto power down (id: 59) to 5 min (id: 4) GET /gopro/camera/setting?setting=59&amp;option=4 \\&gt;= v02.10.00 ✔ ✔ ✔ 59 Auto Power Down Set auto power down (id: 59) to 15 min (id: 6) GET /gopro/camera/setting?setting=59&amp;option=6 ❌ ✔ ✔ ✔ 59 Auto Power Down Set auto power down (id: 59) to 30 min (id: 7) GET /gopro/camera/setting?setting=59&amp;option=7 ❌ ✔ ✔ ✔ 59 Auto Power Down Set auto power down (id: 59) to 8 seconds (id: 11) GET /gopro/camera/setting?setting=59&amp;option=11 \\&gt;= v02.10.00 ❌ ❌ ❌ 59 Auto Power Down Set auto power down (id: 59) to 30 seconds (id: 12) GET /gopro/camera/setting?setting=59&amp;option=12 \\&gt;= v02.10.00 ❌ ❌ ❌ 121 Video Digital Lenses Set video digital lenses (id: 121) to wide (id: 0) GET /gopro/camera/setting?setting=121&amp;option=0 ✔ ✔ ✔ ✔ 121 Video Digital Lenses Set video digital lenses (id: 121) to narrow (id: 2) GET /gopro/camera/setting?setting=121&amp;option=2 ❌ ❌ ✔ ✔ 121 Video Digital Lenses Set video digital lenses (id: 121) to superview (id: 3) GET /gopro/camera/setting?setting=121&amp;option=3 ✔ ✔ ✔ ✔ 121 Video Digital Lenses Set video digital lenses (id: 121) to linear (id: 4) GET /gopro/camera/setting?setting=121&amp;option=4 ✔ ✔ ✔ ✔ 121 Video Digital Lenses Set video digital lenses (id: 121) to max superview (id: 7) GET /gopro/camera/setting?setting=121&amp;option=7 \\&gt;= v02.00.00 ✔ ✔ ✔ 121 Video Digital Lenses Set video digital lenses (id: 121) to linear + horizon leveling (id: 8) GET /gopro/camera/setting?setting=121&amp;option=8 ✔ ✔ ✔ ✔ 121 Video Digital Lenses Set video digital lenses (id: 121) to hyperview (id: 9) GET /gopro/camera/setting?setting=121&amp;option=9 ✔ ✔ ❌ ❌ 121 Video Digital Lenses Set video digital lenses (id: 121) to linear + horizon lock (id: 10) GET /gopro/camera/setting?setting=121&amp;option=10 ✔ ✔ ❌ ❌ 122 Photo Digital Lenses Set photo digital lenses (id: 122) to narrow (id: 19) GET /gopro/camera/setting?setting=122&amp;option=19 ❌ ❌ ✔ ✔ 122 Photo Digital Lenses Set photo digital lenses (id: 122) to max superview (id: 100) GET /gopro/camera/setting?setting=122&amp;option=100 ❌ ✔ ✔ ✔ 122 Photo Digital Lenses Set photo digital lenses (id: 122) to wide (id: 101) GET /gopro/camera/setting?setting=122&amp;option=101 ❌ ✔ ✔ ✔ 122 Photo Digital Lenses Set photo digital lenses (id: 122) to linear (id: 102) GET /gopro/camera/setting?setting=122&amp;option=102 ❌ ✔ ✔ ✔ 123 Time Lapse Digital Lenses Set time lapse digital lenses (id: 123) to narrow (id: 19) GET /gopro/camera/setting?setting=123&amp;option=19 ❌ ❌ ✔ ✔ 123 Time Lapse Digital Lenses Set time lapse digital lenses (id: 123) to max superview (id: 100) GET /gopro/camera/setting?setting=123&amp;option=100 ❌ ✔ ✔ ❌ 123 Time Lapse Digital Lenses Set time lapse digital lenses (id: 123) to wide (id: 101) GET /gopro/camera/setting?setting=123&amp;option=101 ❌ ✔ ✔ ✔ 123 Time Lapse Digital Lenses Set time lapse digital lenses (id: 123) to linear (id: 102) GET /gopro/camera/setting?setting=123&amp;option=102 ❌ ✔ ✔ ✔ 128 Media Format Set media format (id: 128) to time lapse video (id: 13) GET /gopro/camera/setting?setting=128&amp;option=13 ❌ ✔ ✔ ✔ 128 Media Format Set media format (id: 128) to time lapse photo (id: 20) GET /gopro/camera/setting?setting=128&amp;option=20 ❌ ✔ ✔ ✔ 128 Media Format Set media format (id: 128) to night lapse photo (id: 21) GET /gopro/camera/setting?setting=128&amp;option=21 ❌ ✔ ✔ ✔ 128 Media Format Set media format (id: 128) to night lapse video (id: 26) GET /gopro/camera/setting?setting=128&amp;option=26 ❌ ✔ ✔ ✔ 134 Anti-Flicker Set setup anti flicker (id: 134) to 60hz (id: 2) GET /gopro/camera/setting?setting=134&amp;option=2 ✔ ✔ ✔ ✔ 134 Anti-Flicker Set setup anti flicker (id: 134) to 50hz (id: 3) GET /gopro/camera/setting?setting=134&amp;option=3 ✔ ✔ ✔ ✔ 135 Hypersmooth Set video hypersmooth (id: 135) to off (id: 0) GET /gopro/camera/setting?setting=135&amp;option=0 ✔ ✔ ✔ ✔ 135 Hypersmooth Set video hypersmooth (id: 135) to on (id: 1) GET /gopro/camera/setting?setting=135&amp;option=1 ✔ ✔ ❌ ✔ 135 Hypersmooth Set video hypersmooth (id: 135) to high (id: 2) GET /gopro/camera/setting?setting=135&amp;option=2 ❌ ❌ ✔ ✔ 135 Hypersmooth Set video hypersmooth (id: 135) to boost (id: 3) GET /gopro/camera/setting?setting=135&amp;option=3 ✔ ✔ ✔ ✔ 135 Hypersmooth Set video hypersmooth (id: 135) to auto boost (id: 4) GET /gopro/camera/setting?setting=135&amp;option=4 ✔ ✔ ❌ ❌ 135 Hypersmooth Set video hypersmooth (id: 135) to standard (id: 100) GET /gopro/camera/setting?setting=135&amp;option=100 ❌ ❌ ✔ ❌ 150 Horizon Leveling Set video horizon levelling (id: 150) to off (id: 0) GET /gopro/camera/setting?setting=150&amp;option=0 \\&gt;= v02.00.00 ✔ ❌ ❌ 150 Horizon Leveling Set video horizon levelling (id: 150) to on (id: 1) GET /gopro/camera/setting?setting=150&amp;option=1 \\&gt;= v02.00.00 ❌ ❌ ❌ 150 Horizon Leveling Set video horizon levelling (id: 150) to locked (id: 2) GET /gopro/camera/setting?setting=150&amp;option=2 ❌ ✔ ❌ ❌ 151 Horizon Leveling Set photo horizon levelling (id: 151) to off (id: 0) GET /gopro/camera/setting?setting=151&amp;option=0 ❌ ✔ ❌ ❌ 151 Horizon Leveling Set photo horizon levelling (id: 151) to locked (id: 2) GET /gopro/camera/setting?setting=151&amp;option=2 ❌ ✔ ❌ ❌ 162 Max Lens Set max lens (id: 162) to off (id: 0) GET /gopro/camera/setting?setting=162&amp;option=0 ❌ ✔ \\&gt;= v01.20.00 ✔ 162 Max Lens Set max lens (id: 162) to on (id: 1) GET /gopro/camera/setting?setting=162&amp;option=1 ❌ ✔ \\&gt;= v01.20.00 ✔ 173 Video Performance Mode Set video performance mode (id: 173) to maximum video performance (id: 0) GET /gopro/camera/setting?setting=173&amp;option=0 ❌ ❌ \\&gt;= v01.16.00 ❌ 173 Video Performance Mode Set video performance mode (id: 173) to extended battery (id: 1) GET /gopro/camera/setting?setting=173&amp;option=1 ❌ ❌ \\&gt;= v01.16.00 ❌ 173 Video Performance Mode Set video performance mode (id: 173) to tripod / stationary video (id: 2) GET /gopro/camera/setting?setting=173&amp;option=2 ❌ ❌ \\&gt;= v01.16.00 ❌ 175 Controls Set controls (id: 175) to easy (id: 0) GET /gopro/camera/setting?setting=175&amp;option=0 ✔ ✔ ❌ ❌ 175 Controls Set controls (id: 175) to pro (id: 1) GET /gopro/camera/setting?setting=175&amp;option=1 ✔ ✔ ❌ ❌ 176 Speed Set speed (id: 176) to 8x ultra slo-mo (id: 0) GET /gopro/camera/setting?setting=176&amp;option=0 ❌ ✔ ❌ ❌ 176 Speed Set speed (id: 176) to 4x super slo-mo (id: 1) GET /gopro/camera/setting?setting=176&amp;option=1 ❌ ✔ ❌ ❌ 176 Speed Set speed (id: 176) to 2x slo-mo (id: 2) GET /gopro/camera/setting?setting=176&amp;option=2 ❌ ✔ ❌ ❌ 176 Speed Set speed (id: 176) to 1x (low light) (id: 3) GET /gopro/camera/setting?setting=176&amp;option=3 ❌ ✔ ❌ ❌ 176 Speed Set speed (id: 176) to 4x super slo-mo (ext. batt) (id: 4) GET /gopro/camera/setting?setting=176&amp;option=4 ❌ ✔ ❌ ❌ 176 Speed Set speed (id: 176) to 2x slo-mo (ext. batt) (id: 5) GET /gopro/camera/setting?setting=176&amp;option=5 ❌ ✔ ❌ ❌ 176 Speed Set speed (id: 176) to 1x (ext. batt, low light) (id: 6) GET /gopro/camera/setting?setting=176&amp;option=6 ❌ ✔ ❌ ❌ 176 Speed Set speed (id: 176) to 8x ultra slo-mo (50hz) (id: 7) GET /gopro/camera/setting?setting=176&amp;option=7 ❌ ✔ ❌ ❌ 176 Speed Set speed (id: 176) to 4x super slo-mo (50hz) (id: 8) GET /gopro/camera/setting?setting=176&amp;option=8 ❌ ✔ ❌ ❌ 176 Speed Set speed (id: 176) to 2x slo-mo (50hz) (id: 9) GET /gopro/camera/setting?setting=176&amp;option=9 ❌ ✔ ❌ ❌ 176 Speed Set speed (id: 176) to 1x (low light, 50hz) (id: 10) GET /gopro/camera/setting?setting=176&amp;option=10 ❌ ✔ ❌ ❌ 176 Speed Set speed (id: 176) to 4x super slo-mo (ext. batt, 50hz) (id: 11) GET /gopro/camera/setting?setting=176&amp;option=11 ❌ ✔ ❌ ❌ 176 Speed Set speed (id: 176) to 2x slo-mo (ext. batt, 50hz) (id: 12) GET /gopro/camera/setting?setting=176&amp;option=12 ❌ ✔ ❌ ❌ 176 Speed Set speed (id: 176) to 1x (ext. batt, low light, 50hz) (id: 13) GET /gopro/camera/setting?setting=176&amp;option=13 ❌ ✔ ❌ ❌ 176 Speed Set speed (id: 176) to 8x ultra slo-mo (ext. batt) (id: 14) GET /gopro/camera/setting?setting=176&amp;option=14 ❌ \\&gt;= v02.01.00 ❌ ❌ 176 Speed Set speed (id: 176) to 8x ultra slo-mo (ext. batt, 50hz) (id: 15) GET /gopro/camera/setting?setting=176&amp;option=15 ❌ \\&gt;= v02.01.00 ❌ ❌ 176 Speed Set speed (id: 176) to 8x ultra slo-mo (long. batt) (id: 16) GET /gopro/camera/setting?setting=176&amp;option=16 ❌ \\&gt;= v02.01.00 ❌ ❌ 176 Speed Set speed (id: 176) to 4x super slo-mo (long. batt) (id: 17) GET /gopro/camera/setting?setting=176&amp;option=17 ❌ \\&gt;= v02.01.00 ❌ ❌ 176 Speed Set speed (id: 176) to 2x slo-mo (long. batt) (id: 18) GET /gopro/camera/setting?setting=176&amp;option=18 ❌ \\&gt;= v02.01.00 ❌ ❌ 176 Speed Set speed (id: 176) to 1x (long. batt, low light) (id: 19) GET /gopro/camera/setting?setting=176&amp;option=19 ❌ \\&gt;= v02.01.00 ❌ ❌ 176 Speed Set speed (id: 176) to 8x ultra slo-mo (long. batt, 50hz) (id: 20) GET /gopro/camera/setting?setting=176&amp;option=20 ❌ \\&gt;= v02.01.00 ❌ ❌ 176 Speed Set speed (id: 176) to 4x super slo-mo (long. batt, 50hz) (id: 21) GET /gopro/camera/setting?setting=176&amp;option=21 ❌ \\&gt;= v02.01.00 ❌ ❌ 176 Speed Set speed (id: 176) to 2x slo-mo (long. batt, 50hz) (id: 22) GET /gopro/camera/setting?setting=176&amp;option=22 ❌ \\&gt;= v02.01.00 ❌ ❌ 176 Speed Set speed (id: 176) to 1x (long. batt, low light, 50hz) (id: 23) GET /gopro/camera/setting?setting=176&amp;option=23 ❌ \\&gt;= v02.01.00 ❌ ❌ 176 Speed Set speed (id: 176) to 2x slo-mo (4k) (id: 24) GET /gopro/camera/setting?setting=176&amp;option=24 ❌ \\&gt;= v02.01.00 ❌ ❌ 176 Speed Set speed (id: 176) to 4x super slo-mo (2.7k) (id: 25) GET /gopro/camera/setting?setting=176&amp;option=25 ❌ \\&gt;= v02.01.00 ❌ ❌ 176 Speed Set speed (id: 176) to 2x slo-mo (4k, 50hz) (id: 26) GET /gopro/camera/setting?setting=176&amp;option=26 ❌ \\&gt;= v02.01.00 ❌ ❌ 176 Speed Set speed (id: 176) to 4x super slo-mo (2.7k, 50hz) (id: 27) GET /gopro/camera/setting?setting=176&amp;option=27 ❌ \\&gt;= v02.01.00 ❌ ❌ 177 Enable Night Photo Set enable night photo (id: 177) to off (id: 0) GET /gopro/camera/setting?setting=177&amp;option=0 ❌ ✔ ❌ ❌ 177 Enable Night Photo Set enable night photo (id: 177) to on (id: 1) GET /gopro/camera/setting?setting=177&amp;option=1 ❌ ✔ ❌ ❌ 178 Wireless Band Set wireless band (id: 178) to 2.4ghz (id: 0) GET /gopro/camera/setting?setting=178&amp;option=0 ✔ ✔ ❌ ❌ 178 Wireless Band Set wireless band (id: 178) to 5ghz (id: 1) GET /gopro/camera/setting?setting=178&amp;option=1 ✔ ✔ ❌ ❌ 179 Trail Length Set trail length (id: 179) to short (id: 1) GET /gopro/camera/setting?setting=179&amp;option=1 ✔ ✔ ❌ ❌ 179 Trail Length Set trail length (id: 179) to long (id: 2) GET /gopro/camera/setting?setting=179&amp;option=2 ✔ ✔ ❌ ❌ 179 Trail Length Set trail length (id: 179) to max (id: 3) GET /gopro/camera/setting?setting=179&amp;option=3 ✔ ✔ ❌ ❌ 180 Video Mode Set video mode (id: 180) to highest quality (id: 0) GET /gopro/camera/setting?setting=180&amp;option=0 ❌ ✔ ❌ ❌ 180 Video Mode Set video mode (id: 180) to extended battery (id: 1) GET /gopro/camera/setting?setting=180&amp;option=1 ❌ ✔ ❌ ❌ 180 Video Mode Set video mode (id: 180) to extended battery (green icon) (id: 101) GET /gopro/camera/setting?setting=180&amp;option=101 ❌ \\&gt;= v02.01.00 ❌ ❌ 180 Video Mode Set video mode (id: 180) to longest battery (green icon) (id: 102) GET /gopro/camera/setting?setting=180&amp;option=102 ❌ \\&gt;= v02.01.00 ❌ ❌ Camera Capabilities Camera capabilities usually change from one camera to another and often change from one release to the next. Below are documents that detail whitelists for basic video settings for every supported camera release. Note about Dependency Ordering and Blacklisting Capability documents define supported camera states. Each state is comprised of a set of setting options that are presented in dependency order. This means each state is guaranteed to be attainable if and only if the setting options are set in the order presented. Failure to adhere to dependency ordering may result in the camera's blacklist rules rejecting a set-setting command. Example Camera Command 1 Command 2 Command 3 Command 4 Command 5 Guaranteed Valid? HERO10 Black Res: 1080 Anti-Flicker: 60Hz (NTSC) FPS: 240 FOV: Wide Hypersmooth: OFF ✔ HERO10 Black FPS: 240 Anti-Flicker: 60Hz (NTSC) Res: 1080 FOV: Wide Hypersmooth: OFF ❌ In the example above, the first set of commands will always work for basic video presets such as Standard. In the second example, suppose the camera's Video Resolution was previously set to 4K. If the user tries to set Video FPS to 240, it will fail because 4K/240fps is not supported. Capability Documents Documents Product Release capabilities.xlsx capabilities.json HERO11 Black Mini v02.10.00 v02.00.00 v01.10.00 HERO11 Black v02.01.00 v01.20.00 v01.12.00 v01.10.00 HERO10 Black v01.50.00 v01.46.00 v01.42.00 v01.40.00 v01.30.00 v01.20.00 v01.16.00 v01.10.00 HERO9 Black v01.72.00 v01.70.00 Spreadsheet Format The capabilities spreadsheet contains worksheets for every supported release. Each row in a worksheet represents a whitelisted state and is presented in dependency order as outlined above. JSON Format The capabilities JSON contains a set of whitelist states for every supported release. Each state is comprised of a list of objects that contain setting and option IDs necessary to construct set-setting commands and are given in dependency order as outlined above. Below is a simplified example of the capabilities JSON file; a formal schema is also available here: capabilities_schema.json { \"(PRODUCT_NAME)\": { \"(RELEASE_VERSION)\": { \"states\": [ [ {\"setting_name\": \"(str)\", \"setting_id\": (int), \"option_name\": \"(str)\", \"option_id\": (int)}, ... ], ... ], }, ... }, ... } Media The camera provides an endpoint to query basic details about media captured on the sdcard. Chapters All GoPro cameras break longer videos into chapters. GoPro cameras currently limit file sizes on sdcards to 4GB for both FAT32 and exFAT file systems. This limitation is most commonly seen when recording longer (10+ minute) videos. In practice, the camera will split video media into chapters named Gqccmmmm.MP4 (and ones for THM/LRV) such that: q: Quality Level (X: Extreme, H: High, M: Medium, L: Low) cc: Chapter Number (01-99) mmmm: Media ID (0001-9999) When media becomes chaptered, the camera increments subsequent Chapter Numbers while leaving the Media ID unchanged. For example, if the user records a long High-quality video that results in 4 chapters, the files on the sdcard may look like the following: -rwxrwxrwx@ 1 gopro 123456789 4006413091 Jan 1 00:00 GH010078.MP4 -rwxrwxrwx@ 1 gopro 123456789 17663 Jan 1 00:00 GH010078.THM -rwxrwxrwx@ 1 gopro 123456789 4006001541 Jan 1 00:00 GH020078.MP4 -rwxrwxrwx@ 1 gopro 123456789 17357 Jan 1 00:00 GH020078.THM -rwxrwxrwx@ 1 gopro 123456789 4006041985 Jan 1 00:00 GH030078.MP4 -rwxrwxrwx@ 1 gopro 123456789 17204 Jan 1 00:00 GH030078.THM -rwxrwxrwx@ 1 gopro 123456789 756706872 Jan 1 00:00 GH040078.MP4 -rwxrwxrwx@ 1 gopro 123456789 17420 Jan 1 00:00 GH040078.THM -rwxrwxrwx@ 1 gopro 123456789 184526939 Jan 1 00:00 GL010078.LRV -rwxrwxrwx@ 1 gopro 123456789 184519787 Jan 1 00:00 GL020078.LRV -rwxrwxrwx@ 1 gopro 123456789 184517614 Jan 1 00:00 GL030078.LRV -rwxrwxrwx@ 1 gopro 123456789 34877660 Jan 1 00:00 GL040078.LRV Media List Format The format of the media list is given below. { \"id\": \"&lt;MEDIA SESSION ID&gt;\", \"media\": [ { \"d\": \"&lt;DIRECTORY NAME&gt;\", \"fs\": [ {&lt;MEDIA ITEM INFO&gt;}, ... ] }, ... ] } Media List Keys The outer structure of the media list and the inner structure of individual media items use the keys in the table below. Key Description b ID of first member of a group (for grouped media items) d Directory name fs File system. Contains listing of media items in directory g Group ID (if grouped media item) glrv Low resolution video file size id Media list session identifier l ID of last member of a group (for grouped media items) m List of missing/deleted group member IDs (for grouped media items) media Contains media info for for each directory (e.g. 100GOPRO/, 101GOPRO/, ...) mod Last modified time (seconds since epoch) n Media filename s Size of (group) media in bytes t Group type (for grouped media items) (b -&gt; burst, c -&gt; continuous shot, n -&gt; night lapse, t -&gt; time lapse) Grouped Media Items In order to minimize the size of the JSON transmitted by the camera, grouped media items such as Burst Photos, Time Lapse Photos, Night Lapse Photos, etc are represented with a single item in the media list with additional keys that allow the user to extrapolate individual filenames for each member of the group. Filenames for group media items have the form \"GXXXYYYY.ZZZ\" where XXX is the group ID, YYY is the group member ID and ZZZ is the file extension. For example, take the media list below, which contains a Time Lapse Photo group media item: { \"id\": \"2530266050123724003\", \"media\": [ { \"d\": \"100GOPRO\", \"fs\": [ { \"b\": \"8\", \"cre\": \"1613669353\", \"g\": \"1\", \"l\": \"396\", \"m\": ['75', '139'], \"mod\": \"1613669353\", \"n\": \"G0010008.JPG\", \"s\": \"773977407\", \"t\": \"t\" } ] } ] } The first filename in the group is \"G0010008.JPG\" (key: \"n\"). The ID of the first group member in this case is \"008\" (key: \"b\"). The ID of the last group member in this case is \"396\" (key: \"l\"). The IDs of deleted members in this case are \"75\" and \"139\" (key: \"m\") Given this information, the user can extrapolate that the group currently contains G0010008.JPG, G0010009.JPG, G0010010.JPG, ..., G0010074.JPG, G0010076.JPG, ..., G0010138.JPG, G0010140.JPG, ..., G0010394.JPG, G0010395.JPG. G0010396.JPG Media HiLights The HiLight Tags feature allows the user to tag moments of interest either during video capture or on existing media. Add/Remove HiLights Below is a table of all HiLight commands. For details on how to send HiLight commands, see Commands Quick Reference. Command Description Media: HiLight (Add) Video: Add a tag at a specific time offset (ms) Photo: Add a tag Media: HiLight (Remove) Video: Remove a tag at a specific time offset (ms) Photo: Remove tag Media: HiLight Moment Add a tag to the current time offset (ms) while encoding video Note: Attempting to add a HiLight tag at a time offset that exceeds the duration of the video or removing a non-existent HiLight tag will result in an HTTP/500 error. Get HiLights Once HiLight tags have been added, they can be queried by calling the Media: Info command; the response content will be JSON that contains HiLight information: Media Type Key Value Photo hc HiLight Count Video hc HiLight Count Video hi HiLights (list of time offsets in ms) Example The JSON sample below shows media that contains three HiLights at time offsets 2502ms, 5839ms, and 11478ms. Note: Photo info will not have an \"hi\":[...] key-value pair. { ..., \"hc\":\"3\", \"hi\":[2502,5839,11478], ..., } Downloading Media The URL to download/stream media from the DCIM/ directory on the sdcard is the Base URL plus /videos/DCIM/XXX/YYY where XXX is the directory name within DCIM/ given by the media list and YYY is the target media filename. For example: Given the following media list: { \"id\": \"3586667939918700960\", \"media\": [ { \"d\": \"100GOPRO\", \"fs\": [ { \"n\": \"GH010397.MP4\", \"cre\": \"1613672729\", \"mod\": \"1613672729\", \"glrv\": \"1895626\", \"ls\": \"-1\", \"s\": \"19917136\" }, { \"cre\": \"1614340213\", \"mod\": \"1614340213\", \"n\": \"GOPR0001.JPG\", \"s\": \"6961371\" } ] } ] } The URL to download GH010397.MP4 over WiFi would be http://10.5.5.9:8080/videos/DCIM/100GOPRO/GH010397.MP4 The URL to download GOPR0001.JPG over WiFi would be http://10.5.5.9:8080/videos/DCIM/100GOPRO/GOPR0001.JPG Turbo Transfer Some cameras support Turbo Transfer mode, which allows media to be downloaded over WiFi more rapidly. This special mode should only be used during media offload. It is recommended that the user check for and--if necessary--disable Turbo Transfer on connect. For details on which cameras are supported and how to enable and disable Turbo Transfer, see Commands Quick Reference. Downloading Preview Stream When the preview stream is started, the camera starts up a UDP client and begins writing MPEG Transport Stream data to the connected client on port 8554. In order to stream and save this data, the user can implement a UDP server that binds to the same port and appends datagrams to a file when they are received. Camera State The camera provides multiple types of state, all of which can be queried: Camera state: Contains information about camera status (photos taken, date, is-camera-encoding, etc) and settings (current video resolution, current frame rate, etc) Preset State: How presets are arranged into preset groups, their titles, icons, settings closely associated with each preset, etc Camera State Format Camera state is given in the following form: { \"status\": { \"1\": &lt;status 1 value&gt;, \"2\": &lt;status 2 value&gt;, ... }, \"settings: { \"2\": &lt;setting 2 value&gt;, \"3\": &lt;setting 3 value&gt;, ... } } Where status X value and setting X value are almost always integer values. See Status Codes table in this document for exceptions. For status, keys are status codes and values are status values. For settings, keys are setting IDs, and values are option values Status IDs Below is a table of supported status IDs. ✔ Indicates support for all Open GoPro firmware versions. ❌ Indicates a lack of support for all Open GoPro firmware versions. &gt;= vXX.YY.ZZ indicates support for firmware versions equal to or newer than vXX.YY.ZZ Status ID Name Description Type Values HERO11 Black Mini HERO11 Black HERO10 Black HERO9 Black 1 Internal battery present Is the system's internal battery present? boolean 0: False 1: True ✔ ✔ ✔ ✔ 2 Internal battery level Rough approximation of internal battery level in bars integer 0: Zero 1: One 2: Two 3: Three ✔ ✔ ✔ ✔ 6 System hot Is the system currently overheating? boolean 0: False 1: True ✔ ✔ ✔ ✔ 8 System busy Is the camera busy? boolean 0: False 1: True ✔ ✔ ✔ ✔ 9 Quick capture active Is Quick Capture feature enabled? boolean 0: False 1: True ✔ ✔ ✔ ✔ 10 Encoding active Is the system encoding right now? boolean 0: False 1: True ✔ ✔ ✔ ✔ 11 Lcd lock active Is LCD lock active? boolean 0: False 1: True ✔ ✔ ✔ ✔ 13 Video progress counter When encoding video, this is the duration (seconds) of the video so far; 0 otherwise integer * ✔ ✔ ✔ ✔ 17 Enable Are Wireless Connections enabled? boolean 0: False 1: True ✔ ✔ ✔ ✔ 19 State The pairing state of the camera integer 0: Never Started 1: Started 2: Aborted 3: Cancelled 4: Completed ✔ ✔ ✔ ✔ 20 Type The last type of pairing that the camera was engaged in integer 0: Not Pairing 1: Pairing App 2: Pairing Remote Control 3: Pairing Bluetooth Device ✔ ✔ ✔ ✔ 21 Pair time Time (milliseconds) since boot of last successful pairing complete action integer * ✔ ✔ ✔ ✔ 22 State State of current scan for WiFi Access Points. Appears to only change for CAH-related scans integer 0: Never started 1: Started 2: Aborted 3: Canceled 4: Completed ✔ ✔ ✔ ✔ 23 Scan time msec The time, in milliseconds since boot that the WiFi Access Point scan completed integer * ✔ ✔ ✔ ✔ 24 Provision status WiFi AP provisioning state integer 0: Never started 1: Started 2: Aborted 3: Canceled 4: Completed ✔ ✔ ✔ ✔ 26 Remote control version Wireless remote control version integer * ✔ ✔ ✔ ✔ 27 Remote control connected Is a wireless remote control connected? boolean 0: False 1: True ✔ ✔ ✔ ✔ 28 Pairing Wireless Pairing State integer * ✔ ✔ ✔ ✔ 29 Wlan ssid Provisioned WIFI AP SSID. On BLE connection, value is big-endian byte-encoded int string * ✔ ✔ ✔ ✔ 30 Ap ssid Camera's WIFI SSID. On BLE connection, value is big-endian byte-encoded int string * ✔ ✔ ✔ ✔ 31 App count The number of wireless devices connected to the camera integer * ✔ ✔ ✔ ✔ 32 Enable Is Preview Stream enabled? boolean 0: False 1: True ✔ ✔ ✔ ✔ 33 Sd status Primary Storage Status integer -1: Unknown 0: OK 1: SD Card Full 2: SD Card Removed 3: SD Card Format Error 4: SD Card Busy 8: SD Card Swapped ✔ ✔ ✔ ✔ 34 Remaining photos How many photos can be taken before sdcard is full integer * ❌ ✔ ✔ ✔ 35 Remaining video time How many minutes of video can be captured with current settings before sdcard is full integer * ✔ ✔ ✔ ✔ 36 Num group photos How many group photos can be taken with current settings before sdcard is full integer * ❌ ✔ ✔ ✔ 37 Num group videos Total number of group videos on sdcard integer * ✔ ✔ ✔ ✔ 38 Num total photos Total number of photos on sdcard integer * ✔ ✔ ✔ ✔ 39 Num total videos Total number of videos on sdcard integer * ✔ ✔ ✔ ✔ 41 Ota status The current status of Over The Air (OTA) update integer 0: Idle 1: Downloading 2: Verifying 3: Download Failed 4: Verify Failed 5: Ready 6: GoPro App: Downloading 7: GoPro App: Verifying 8: GoPro App: Download Failed 9: GoPro App: Verify Failed 10: GoPro App: Ready ✔ ✔ ✔ ✔ 42 Download cancel request pending Is there a pending request to cancel a firmware update download? boolean 0: False 1: True ✔ ✔ ✔ ✔ 45 Camera locate active Is locate camera feature active? boolean 0: False 1: True ✔ ✔ ✔ ✔ 49 Multi shot count down The current timelapse interval countdown value (e.g. 5...4...3...2...1...) integer * ✔ ✔ ✔ ✔ 54 Remaining space Remaining space on the sdcard in Kilobytes integer * ✔ ✔ ✔ ✔ 55 Supported Is preview stream supported in current recording/mode/secondary-stream? boolean 0: False 1: True ✔ ✔ ✔ ✔ 56 Wifi bars WiFi signal strength in bars integer * ✔ ✔ ✔ ✔ 58 Num hilights The number of hilights in encoding video (set to 0 when encoding stops) integer * ✔ ✔ ✔ ✔ 59 Last hilight time msec Time since boot (msec) of most recent hilight in encoding video (set to 0 when encoding stops) integer * ✔ ✔ ✔ ✔ 60 Next poll msec The min time between camera status updates (msec). Do not poll for status more often than this integer * ✔ ✔ ✔ ✔ 64 Remaining timelapse time How many min of Timelapse video can be captured with current settings before sdcard is full integer * ✔ ✔ ✔ ✔ 65 Exposure select type Liveview Exposure Select Mode integer 0: Disabled 1: Auto 2: ISO Lock 3: Hemisphere ❌ ✔ ✔ ✔ 66 Exposure select x Liveview Exposure Select: y-coordinate (percent) percent 0-100 ❌ ✔ ✔ ✔ 67 Exposure select y Liveview Exposure Select: y-coordinate (percent) percent 0-100 ❌ ✔ ✔ ✔ 68 Gps status Does the camera currently have a GPS lock? boolean 0: False 1: True ✔ ✔ ✔ ✔ 69 Ap state Is the WiFi radio enabled? boolean 0: False 1: True ✔ ✔ ✔ ✔ 70 Internal battery percentage Internal battery level (percent) percent 0-100 ✔ ✔ ✔ ✔ 74 Acc mic status Microphone Accesstory status integer 0: Microphone mod not connected 1: Microphone mod connected 2: Microphone mod connected and microphone plugged into Microphone mod ✔ ✔ ✔ ✔ 75 Digital zoom Digital Zoom level (percent) percent 0-100 ✔ ✔ ✔ ✔ 76 Wireless band Wireless Band integer 0: 2.4 GHz 1: 5 GHz 2: Max ✔ ✔ ✔ ✔ 77 Digital zoom active Is Digital Zoom feature available? boolean 0: False 1: True ✔ ✔ ✔ ✔ 78 Mobile friendly video Are current video settings mobile friendly? (related to video compression and frame rate) boolean 0: False 1: True ✔ ✔ ✔ ✔ 79 First time use Is the camera currently in First Time Use (FTU) UI flow? boolean 0: False 1: True ❌ ❌ ✔ ✔ 81 Band 5ghz avail Is 5GHz wireless band available? boolean 0: False 1: True ✔ ✔ ✔ ✔ 82 System ready Is the system ready to accept commands? boolean 0: False 1: True ✔ ✔ ✔ ✔ 83 Batt okay for ota Is the internal battery charged sufficiently to start Over The Air (OTA) update? boolean 0: False 1: True ✔ ✔ ✔ ✔ 85 Video low temp alert Is the camera getting too cold to continue recording? boolean 0: False 1: True ✔ ✔ ✔ ✔ 86 Actual orientation The rotational orientation of the camera integer 0: 0 degrees (upright) 1: 180 degrees (upside down) 2: 90 degrees (laying on right side) 3: 270 degrees (laying on left side) ✔ ✔ ✔ ✔ 88 Zoom while encoding Is this camera capable of zooming while encoding (static value based on model, not settings) boolean 0: False 1: True ✔ ✔ ✔ ✔ 89 Current mode Current flatmode ID integer * ✔ ✔ ✔ ✔ 93 Active video presets Current Video Preset (ID) integer * ✔ ✔ ✔ ✔ 94 Active photo presets Current Photo Preset (ID) integer * ❌ ✔ ✔ ✔ 95 Active timelapse presets Current Timelapse Preset (ID) integer * ✔ ✔ ✔ ✔ 96 Active presets group Current Preset Group (ID) integer * ✔ ✔ ✔ ✔ 97 Active preset Current Preset (ID) integer * ✔ ✔ ✔ ✔ 98 Preset modified Preset Modified Status, which contains an event ID and a preset (group) ID integer * ✔ ✔ ✔ ✔ 99 Remaining live bursts How many Live Bursts can be captured before sdcard is full integer * ❌ ✔ ✔ ✔ 100 Num total live bursts Total number of Live Bursts on sdcard integer * ❌ ✔ ✔ ✔ 101 Capture delay active Is Capture Delay currently active (i.e. counting down)? boolean 0: False 1: True ✔ ✔ ✔ ✔ 102 Media mod mic status Media mod State integer 0: Media mod microphone removed 2: Media mod microphone only 3: Media mod microphone with external microphone ✔ ✔ ✔ ✔ 103 Timewarp speed ramp active Time Warp Speed integer 0: 15x 1: 30x 2: 60x 3: 150x 4: 300x 5: 900x 6: 1800x 7: 2x 8: 5x 9: 10x 10: Auto 11: 1x (realtime) 12: 1/2x (slow-motion) ✔ ✔ ✔ ✔ 104 Linux core active Is the system's Linux core active? boolean 0: False 1: True ❌ ❌ ✔ ✔ 105 Camera lens type Camera lens type (reflects changes to setting 162) integer 0: Default 1: Max Lens ✔ ✔ ✔ ✔ 106 Video hindsight capture active Is Video Hindsight Capture Active? boolean 0: False 1: True ❌ ✔ ✔ ✔ 107 Scheduled preset Scheduled Capture Preset ID integer * ❌ ✔ ✔ ✔ 108 Scheduled enabled Is Scheduled Capture set? boolean 0: False 1: True ❌ ✔ ✔ ✔ 110 Media mod status Media Mode Status (bitmasked) integer 0: 000 = Selfie mod: 0, HDMI: 0, Media Mod Connected: False 1: 001 = Selfie mod: 0, HDMI: 0, Media Mod Connected: True 2: 010 = Selfie mod: 0, HDMI: 1, Media Mod Connected: False 3: 011 = Selfie mod: 0, HDMI: 1, Media Mod Connected: True 4: 100 = Selfie mod: 1, HDMI: 0, Media Mod Connected: False 5: 101 = Selfie mod: 1, HDMI: 0, Media Mod Connected: True 6: 110 = Selfie mod: 1, HDMI: 1, Media Mod Connected: False 7: 111 = Selfie mod: 1, HDMI: 1, Media Mod Connected: True ❌ ✔ ✔ ✔ 111 Sd rating check error Does sdcard meet specified minimum write speed? boolean 0: False 1: True ✔ ✔ ✔ ❌ 112 Sd write speed error Number of sdcard write speed errors since device booted integer * ✔ ✔ ✔ ❌ 113 Turbo transfer Is Turbo Transfer active? boolean 0: False 1: True ✔ ✔ ✔ ✔ 114 Camera control status Camera control status ID integer 0: Camera Idle: No one is attempting to change camera settings 1: Camera Control: Camera is in a menu or changing settings. To intervene, app must request control 2: Camera External Control: An outside entity (app) has control and is in a menu or modifying settings ✔ ✔ ✔ ❌ 115 Usb connected Is the camera connected to a PC via USB? boolean 0: False 1: True ✔ ✔ ✔ ❌ 116 Allow control over usb Camera control over USB state integer 0: Disabled 1: Enabled ✔ ✔ \\&gt;= v01.30.00 ❌ 117 Total sd space kb Total SD card capacity in kilobytes integer * ✔ ✔ ❌ ❌ Preset Status Format Preset Status is returned as JSON, whose content is the serialization of the protobuf message: NotifyPresetStatus. Using Google protobuf APIs, the JSON can be converted back into a programmatic object in the user's language of choice. Features Presets The camera organizes modes of operation into presets. A preset is a logical wrapper around a specific camera mode, title, icon, and a set of settings that enhance different styles of capturing media. Depending on the camera's state, different collections of presets will be available for immediate loading and use. Below is a table of settings that affect the current preset collection and thereby which presets can be loaded: ID Setting 162 Max Lens 173 Video Performance Mode 175 Controls 177 Enable Night Photo 180 Video Mode To determine which presets are available for immediate use, get Preset Status. Preset Status All cameras support basic query and subscription mechanics that allow the user to: Get hierarchical data describing the Preset Groups, Presets, and Settings that are available in the camera's current state Preset Status should not be confused with camera status: Preset Status contains information about current preset groups and presets Camera status contains numerous statuses about current settings and camera system state Preset Groups Each Preset Group contains an ID, whether additional presets can be added, and an array of existing Presets. Presets Each Preset contains information about its ID, associated core mode, title, icon, whether it's a user-defined preset, whether the preset has been modified from its factory-default state (for factory-default presets only) and an array of Settings associated with the Preset. Important Note: The Preset ID is required to load a Preset via the Presets: Load command. Global Behaviors In order to prevent undefined behavior between the camera and a connected app, simultaneous use of the camera and a connected app is discouraged. Best practice for synchronizing user/app control is to use the Set Camera Control Status command and corresponding Camera Control Status (CCS) camera statuses in alignment with the finite state machine below: IDLEControl Status: IdleCAMERA_CONTROLControl Status: Camera ControlEXTERNAL_CONTROLControl Status: External ControlApp sets CCS: IdleUser interacts with cameraUser returns camera to idle screenApp sets CCS: IdleApp sets CCS: External ControlApp sets CCS: IdleUser interacts with cameraUser interacts with cameraApp sets CCS: External ControlUser interacts with camera Control Status ID IDLE 0 CONTROL 1 EXTERNAL_CONTROL 2 Set Camera Control Status This command is used to tell the camera that the app (i.e. External Control) wishes to claim control of the camera. This causes the camera to immediately exit any contextual menus and return to the idle screen. Any interaction with the camera's physical buttons will cause the camera to reclaim control and update control status accordingly. If the user returns the camera UI to the idle screen, the camera updates control status to Idle. Note: The entity currently claiming control of the camera is advertised in camera status 114 Information about whether the camera is in a contextual menu or not is advertised in camera status 63. OTA Update The Over The Air (OTA) update feature allows the user to update the camera's firmware via HTTP connection. Firmware update files can be obtained from GoPro's update page or programmatically using the firmware catalog. OTA Update Flow The OTA update process involves uploading chunks (or all) of a file along with its corresponding SHA1 hash, marking the file complete and then telling the camera to begin the update process. For specific command examples, see /gp/gpSoftUpdate in Commands Quick Reference. Note: Near the end of the firmware update process, in order to complete, the camera will need to reboot 1-2 times. This will cause any existing HTTP connections to be lost. ClientClientCameraCameraObtain UPDATE.zip from update page or firmware catalogCalculate SHA1_HASH for UPDATE.zipHTTP/GET: /gp/gpSoftUpdate?request=deleteDelete any old/cached dataHTTP/200 (OK)JSON {\"status\":0,\"message\":\"OK\",\"sha1\":\"\",\"bytes_complete\":0,\"complete\":false}HTTP/GET: /gp/gpSoftUpdate?request=showuiDisplay update OSD on camera UIHTTP/200 (OK)JSON: {\"status\":0,\"message\":\"OK\",\"sha1\":\"\",\"bytes_complete\":0,\"complete\":false}loop[read CHUNK of UPDATE.zip, starting at OFFSET]HTTP/POST: /gp/gpSoftUpdateContent-Type: multipart/form-datadata={\"sha1\": \"SHA1_HASH\", \"offset\": OFFSET, file: @CHUNK}HTTP/200 (OK)JSON: {\"status\": 0,\"message\": \"OK\",\"sha1\": \"SHA1_HASH\",\"bytes_complete\": (total uploaded bytes),\"complete\": false}HTTP/POST: /gp/gpSoftUpdateContent-Type: multipart/form-datadata={\"sha1\": \"SHA1_HASH\", \"complete\": true}HTTP/200 (OK)JSON: {\"status\":0,\"message\":\"OK\",\"sha1\":\"SHA1_HASH\",\"bytes_complete\":(size of UPDATE.zip),\"complete\":true}HTTP/GET: /gp/gpSoftUpdate?request=startStart updating firmwareHTTP/200 (OK)JSON: {\"status\":0,\"message\":\"OK\",\"sha1\":\"SHA1_HASH\",\"bytes_complete\":(size of UPDATE.zip),\"complete\":true}loop[while camera updates firmware]HTTP/GET: /gp/gpSoftUpdate?request=progressJSON: {\"status\":11,\"message\":\"Firmware update in progress\"}WiFi connection lostCamera displays OSD \"Update Complete\", reboots 1-2 times OTA Update Status Codes ID Status Description 0 Ok No errors occurred 1 Unknown Request Server did not recognize the request 2 Bad Params Parameter values not recognized 3 SHA1 Send Mismatch SHA1 for chunk did not match SHA1 of previous chunk(s) 4 SHA1 Calculates Mismatch Calculated SHA1 did not match user-specified SHA1 5 HTTP Boundary Error HTTP Post malformed 6 HTTP Post Error Unexpected HTTP/POST Content Type 7 Server Busy HTTP server is busy 8 Offset Mismatch Tried to upload chunk with offset that did not align with previous chunk 9 Bad Post Data Server failed to parse POST data 10 File Incomplete Tried to start update before server finished validating .zip file 11 Update in Progress Firmware update in progress 12 Insufficient Space Insufficient space on the sdcard to hold (decompressed) update file Webcam The webcam feature enables developers who are interested in writing custom drivers to make the camera broadcast its video preview with a limited set of resolution and field of view options. While active, the webcam feature runs a UDP client that sends raw Transport Stream data to the connected client on port 8554. To test basic functionality, connect the camera to your system, start the webcam, and use an application such as VLC to start a network stream on udp://@0.0.0.0:8554. For readers interested in using a GoPro camera as a webcam with preexisting tools, please see How to use GoPro as a Webcam. Webcam Finite State Machine PREREQUISITEWired USB Control disabledOFFWebcam disabledIDLEWebcam readyHPPHigh power previewLPPLow power previewConnect USBStopExitStartStopExitPreviewStopExitStartPreviewStartPreview Webcam Commands Note: Prior to issuing webcam commands, Wired USB Control must be disabled. For details about how to send this and webcam commands, see Commands Quick Reference. Command Connections Description Webcam: Start USB Enters webcam mode, uses default resolution and last-used fov, starts high-res stream to the IP address of caller Webcam: Start (with args) USB Enters webcam mode, uses specified resolution and/or fov, starts streaming to the IP address of caller Webcam: Preview USB Enters webcam mode, sets stream resolution and bitrate, starts low-res stream to the IP address of caller. Can set Webcam Digital Lenses and Digital Zoom levels while streaming Webcam: Stop USB Stops the webcam stream Webcam: Exit USB Stops the webcam stream and exits webcam mode Webcam: Status USB Returns the current state of the webcam endpoint, including status and error codes (see tables below) Webcam: Version USB Provides version information about webcam implementation in JSON format Status Codes Status Code OFF 0 IDLE 1 HIGH_POWER_PREVIEW 2 LOW_POWER_PREVIEW 3 Error Codes Status Code NONE 0 SET_PRESET 1 SET_WINDOW_SIZE 2 EXEC_STREAM 3 SHUTTER 4 COM_TIMEOUT 5 INVALID_PARAM 6 UNAVAILABLE 7 EXIT 8 Webcam Settings Aside from basic settings such as Resolution and FOV, the camera may support other settings such as Hypersmooth. In order to change these settings independently, the webcam must be in IDLE state. Note: There is a known issue on some cameras in which the webcam state will be wrongly reported as IDLE after a new USB connection. The best workaround for this is to call Webcam: Start followed by the Webcam: Stop after connecting USB in order to attain the true IDLE state. Resolutions Note: If resolution is not set, 1080p will be used by default ID Resolution HERO11 Black Mini HERO11 Black HERO10 Black HERO9 Black 4 480 ❌ ✔ ✔ ✔ 7 720 ❌ ✔ ✔ ✔ 12 1080 ❌ ✔ ✔ ✔ Digital Lenses / FOV Note: If fov is not set, camera will default to the last-set fov or Wide if fov has never been set. ID FOV HERO11 Black Mini HERO11 Black HERO10 Black HERO9 Black 0 WIDE ❌ ✔ ✔ ✔ 2 NARROW ❌ ✔ ✔ ✔ 3 SUPERVIEW ❌ ✔ ✔ ✔ 4 LINEAR ❌ ✔ ✔ ✔ Limitations HERO11 Black Mini The camera will reject requests to change settings while encoding; for example, if Hindsight feature is active, the user cannot change settings HTTP command arguments must be given in the order outlined in Commands Quick Reference HERO11 Black The camera will reject requests to change settings while encoding; for example, if Hindsight feature is active, the user cannot change settings HTTP command arguments must be given in the order outlined in Commands Quick Reference HERO10 Black The camera will reject requests to change settings while encoding; for example, if Hindsight feature is active, the user cannot change settings HTTP command arguments must be given in the order outlined in Commands Quick Reference HERO9 Black The HTTP server is not available while the camera is encoding, which means shutter controls are not supported over WiFi. This limitation can be overcome by using Bluetooth Low Energy for command and control and HTTP/REST for querying media content such as media list, media info, preview stream, etc. USB command and control is not supported on HERO9 Black. HTTP command arguments must be given in the order outlined in Commands Quick Reference General Unless changed by the user, GoPro cameras will automatically power off after some time (e.g. 5min, 15min, 30min). The Auto Power Down watchdog timer can be reset by sending periodic keep-alive messages to the camera. It is recommended to send a keep-alive at least once every 120 seconds. In general, querying the value for a setting that is not associated with the current preset/core mode results in an undefined value. For example, the user should not try to query the current Photo Digital Lenses (FOV) value while in Standard preset (Video mode).",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/http_2_0#"
        },
        {
            "title": "Open GoPro: ",
            "excerpt": "The Open GoPro API is the primary way for users to programmatically interact with a GoPro camera. It is supported on the following cameras / firmware versions: Camera Minimal Firmware Version Hero 9 Black v01.70.00 Hero 10 Black v01.10.00 Hero 11 Black v01.10.00 Hero 11 Black Mini v01.10.00 Open GoPro documents interfaces to HTTP (wired and wireless) and Bluetooth Low Energy that allow users to perform command, control, and query actions including: Feature BLE WiFi USB Camera Connect / Wake ✔️ Retrieve Camera State ✔️ ✔️ ✔️ Press Shutter ✔️ ✔️* ✔️* Change Settings / Modes ✔️ ✔️ ✔️ Live Preview ✔️ ✔️ Webcam / UDP Streaming (up to 1080P) ✔️ Media Management ✔️ ✔️ Metadata File Extraction ✔️ ✔️ External Power via same I/O ✔️ * = From Hero 10 onwards Docs Detailed Bluetooth Low Energy (BLE) and HTTP Interface Specifications. BLE Specs → HTTP Spec → Tutorials Walk-through tutorials in different languages / frameworks for getting started. ✏️ Tutorials → Demos Complete runnable examples in different languages to use as base for your project. ⚙️ Demos →",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/#"
        },
        {
            "title": "Protocol Documentation: ",
            "excerpt": "This page provides documentation for all of the protobuf message fields.",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#"
        },
        {
            "title": "Protocol Documentation: Protobuf Files",
            "excerpt": "- [live_streaming.proto](live_streaming-proto) - [network_management.proto](network_management-proto) - [preset_status.proto](preset_status-proto) - [request_get_preset_status.proto](request_get_preset_status-proto) - [response_generic.proto](response_generic-proto) - [set_camera_control_status.proto](set_camera_control_status-proto) - [turbo_transfer.proto](turbo_transfer-proto)",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#protobuf-files"
        },
        {
            "title": "Protocol Documentation: live_streaming.proto",
            "excerpt": "",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#live-streaming-proto"
        },
        {
            "title": "Protocol Documentation: NotifyLiveStreamStatus",
            "excerpt": "| Field | Type | Label | Description | | ----- | ---- | ----- | ----------- | | live_stream_status | [EnumLiveStreamStatus](open_gopro-EnumLiveStreamStatus) | optional | Live stream status | | live_stream_error | [EnumLiveStreamError](open_gopro-EnumLiveStreamError) | optional | Live stream error | | live_stream_encode | [bool](bool) | optional | Is live stream encoding? | | live_stream_bitrate | [int32](int32) | optional | Live stream bitrate (Kbps) | | live_stream_window_size_supported_array | [EnumWindowSize](open_gopro-EnumWindowSize) | repeated | Live stream resolution capabilities | | live_stream_encode_supported | [bool](bool) | optional | Does the camera support encoding while live streaming? | | live_stream_max_lens_unsupported | [bool](bool) | optional | Is the Max Lens feature NOT supported? | | live_stream_minimum_stream_bitrate | [int32](int32) | optional | Camera-defined minimum bitrate (static) (Kbps) | | live_stream_maximum_stream_bitrate | [int32](int32) | optional | Camera-defined maximum bitrate (static) (Kbps) | | live_stream_lens_supported | [bool](bool) | optional | Does camera support setting lens for live streaming? | | live_stream_lens_supported_array | [EnumLens](open_gopro-EnumLens) | repeated | Array of supported lenses for live streaming | | deprecated | [bool](bool) | optional | Deprecated |",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#notifylivestreamstatus"
        },
        {
            "title": "Protocol Documentation: RequestGetLiveStreamStatus",
            "excerpt": "| Field | Type | Label | Description | | ----- | ---- | ----- | ----------- | | register_live_stream_status | [EnumRegisterLiveStreamStatus](open_gopro-EnumRegisterLiveStreamStatus) | repeated | Array of live stream statuses to be notified about | | unregister_live_stream_status | [EnumRegisterLiveStreamStatus](open_gopro-EnumRegisterLiveStreamStatus) | repeated | Array of live stream statuses to stop being notified about |",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#requestgetlivestreamstatus"
        },
        {
            "title": "Protocol Documentation: RequestSetLiveStreamMode",
            "excerpt": "| Field | Type | Label | Description | | ----- | ---- | ----- | ----------- | | url | [string](string) | optional | RTMP(S) URL used for live stream | | encode | [bool](bool) | optional | Save media to sdcard while streaming? | | window_size | [EnumWindowSize](open_gopro-EnumWindowSize) | optional | Live stream resolution | | reserved1 | [string](string) | optional | Reserved | | reserved2 | [string](string) | optional | Reserved | | cert | [bytes](bytes) | optional | Certificate for servers that require it | | minimum_bitrate | [int32](int32) | optional | Minimum desired bitrate (may or may not be honored) | | maximum_bitrate | [int32](int32) | optional | Maximum desired bitrate (may or may not be honored) | | starting_bitrate | [int32](int32) | optional | Starting bitrate | | lens | [EnumLens](open_gopro-EnumLens) | optional | Lens to use for live stream (see | | reserved3 | [int32](int32) | optional | Reserved |",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#requestsetlivestreammode"
        },
        {
            "title": "Protocol Documentation: EnumLens",
            "excerpt": "| Name | Number | Description | | ---- | ------ | ----------- | | LENS_WIDE | 0 | | | LENS_LINEAR | 4 | | | LENS_SUPERVIEW | 3 | |",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#enumlens"
        },
        {
            "title": "Protocol Documentation: EnumLiveStreamError",
            "excerpt": "| Name | Number | Description | | ---- | ------ | ----------- | | LIVE_STREAM_ERROR_NONE | 0 | | | LIVE_STREAM_ERROR_NETWORK | 1 | | | LIVE_STREAM_ERROR_CREATESTREAM | 2 | | | LIVE_STREAM_ERROR_OUTOFMEMORY | 3 | | | LIVE_STREAM_ERROR_INPUTSTREAM | 4 | | | LIVE_STREAM_ERROR_INTERNET | 5 | | | LIVE_STREAM_ERROR_OSNETWORK | 6 | | | LIVE_STREAM_ERROR_SELECTEDNETWORKTIMEOUT | 7 | | | LIVE_STREAM_ERROR_SSL_HANDSHAKE | 8 | | | LIVE_STREAM_ERROR_CAMERA_BLOCKED | 9 | | | LIVE_STREAM_ERROR_UNKNOWN | 10 | | | LIVE_STREAM_ERROR_SD_CARD_FULL | 40 | | | LIVE_STREAM_ERROR_SD_CARD_REMOVED | 41 | |",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#enumlivestreamerror"
        },
        {
            "title": "Protocol Documentation: EnumLiveStreamStatus",
            "excerpt": "| Name | Number | Description | | ---- | ------ | ----------- | | LIVE_STREAM_STATE_IDLE | 0 | | | LIVE_STREAM_STATE_CONFIG | 1 | | | LIVE_STREAM_STATE_READY | 2 | | | LIVE_STREAM_STATE_STREAMING | 3 | | | LIVE_STREAM_STATE_COMPLETE_STAY_ON | 4 | | | LIVE_STREAM_STATE_FAILED_STAY_ON | 5 | | | LIVE_STREAM_STATE_RECONNECTING | 6 | |",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#enumlivestreamstatus"
        },
        {
            "title": "Protocol Documentation: EnumRegisterLiveStreamStatus",
            "excerpt": "| Name | Number | Description | | ---- | ------ | ----------- | | REGISTER_LIVE_STREAM_STATUS_STATUS | 1 | | | REGISTER_LIVE_STREAM_STATUS_ERROR | 2 | | | REGISTER_LIVE_STREAM_STATUS_MODE | 3 | | | REGISTER_LIVE_STREAM_STATUS_BITRATE | 4 | |",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#enumregisterlivestreamstatus"
        },
        {
            "title": "Protocol Documentation: EnumWindowSize",
            "excerpt": "| Name | Number | Description | | ---- | ------ | ----------- | | WINDOW_SIZE_480 | 4 | | | WINDOW_SIZE_720 | 7 | | | WINDOW_SIZE_1080 | 12 | |",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#enumwindowsize"
        },
        {
            "title": "Protocol Documentation: network_management.proto",
            "excerpt": "",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#network-management-proto"
        },
        {
            "title": "Protocol Documentation: NotifProvisioningState",
            "excerpt": "| Field | Type | Label | Description | | ----- | ---- | ----- | ----------- | | provisioning_state | [EnumProvisioning](open_gopro-EnumProvisioning) | required | Provisioning/connection state |",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#notifprovisioningstate"
        },
        {
            "title": "Protocol Documentation: NotifStartScanning",
            "excerpt": "| Field | Type | Label | Description | | ----- | ---- | ----- | ----------- | | scanning_state | [EnumScanning](open_gopro-EnumScanning) | required | Scanning state | | scan_id | [int32](int32) | optional | ID associated with scan results (included if scan was successful) | | total_entries | [int32](int32) | optional | Number of APs found during scan (included if scan was successful) | | total_configured_ssid | [int32](int32) | required | Total count of camera's provisioned SSIDs |",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#notifstartscanning"
        },
        {
            "title": "Protocol Documentation: RequestConnect",
            "excerpt": "| Field | Type | Label | Description | | ----- | ---- | ----- | ----------- | | ssid | [string](string) | required | AP SSID | | owner_purpose | [EnumNetworkOwner](open_gopro-EnumNetworkOwner) | optional | Deprecated |",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#requestconnect"
        },
        {
            "title": "Protocol Documentation: RequestConnectNew",
            "excerpt": "| Field | Type | Label | Description | | ----- | ---- | ----- | ----------- | | ssid | [string](string) | required | AP SSID | | password | [string](string) | required | AP password | | static_ip | [bytes](bytes) | optional | Static IP address | | gateway | [bytes](bytes) | optional | Gateway IP address | | subnet | [bytes](bytes) | optional | Subnet mask | | dns_primary | [bytes](bytes) | optional | Primary DNS | | dns_secondary | [bytes](bytes) | optional | Secondary DNS | | set_to_least_preferred_ap | [bool](bool) | optional | Deprecated | | owner_purpose | [EnumNetworkOwner](open_gopro-EnumNetworkOwner) | optional | Deprecated |",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#requestconnectnew"
        },
        {
            "title": "Protocol Documentation: RequestGetApEntries",
            "excerpt": "| Field | Type | Label | Description | | ----- | ---- | ----- | ----------- | | start_index | [int32](int32) | required | Used for paging. 0",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#requestgetapentries"
        },
        {
            "title": "Protocol Documentation: RequestReleaseNetwork",
            "excerpt": "",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#requestreleasenetwork"
        },
        {
            "title": "Protocol Documentation: RequestStartScan",
            "excerpt": "",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#requeststartscan"
        },
        {
            "title": "Protocol Documentation: ResponseConnect",
            "excerpt": "| Field | Type | Label | Description | | ----- | ---- | ----- | ----------- | | result | [EnumResultGeneric](open_gopro-EnumResultGeneric) | required | Generic pass/fail/error info | | provisioning_state | [EnumProvisioning](open_gopro-EnumProvisioning) | required | Provisioning/connection state | | timeout_seconds | [int32](int32) | required | Network connection timeout (seconds) |",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#responseconnect"
        },
        {
            "title": "Protocol Documentation: ResponseConnectNew",
            "excerpt": "| Field | Type | Label | Description | | ----- | ---- | ----- | ----------- | | result | [EnumResultGeneric](open_gopro-EnumResultGeneric) | required | Status of Connect New request | | provisioning_state | [EnumProvisioning](open_gopro-EnumProvisioning) | required | Current provisioning state of the network | | timeout_seconds | [int32](int32) | required | |",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#responseconnectnew"
        },
        {
            "title": "Protocol Documentation: ResponseGetApEntries",
            "excerpt": "| Field | Type | Label | Description | | ----- | ---- | ----- | ----------- | | result | [EnumResultGeneric](open_gopro-EnumResultGeneric) | required | Generic pass/fail/error info | | scan_id | [int32](int32) | required | ID associated with this batch of results | | entries | [ScanEntry](open_gopro-ScanEntry) | repeated | Array containing details about discovered APs |",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#responsegetapentries"
        },
        {
            "title": "Protocol Documentation: ResponseStartScanning",
            "excerpt": "| Field | Type | Label | Description | | ----- | ---- | ----- | ----------- | | result | [EnumResultGeneric](open_gopro-EnumResultGeneric) | required | Generic pass/fail/error info | | scanning_state | [EnumScanning](open_gopro-EnumScanning) | required | Scanning state |",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#responsestartscanning"
        },
        {
            "title": "Protocol Documentation: ScanEntry",
            "excerpt": "| Field | Type | Label | Description | | ----- | ---- | ----- | ----------- | | ssid | [string](string) | required | AP SSID | | signal_strength_bars | [int32](int32) | required | Signal strength (3 bars: >-70 dBm; 2 bars: >-85 dBm; 1 bar:",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#scanentry"
        },
        {
            "title": "Protocol Documentation: EnumNetworkOwner",
            "excerpt": "| Name | Number | Description | | ---- | ------ | ----------- | | DEPRECATED_1 | 0 | | | DEPRECATED_2 | 1 | | | DEPRECATED_3 | 2 | | | DEPRECATED_4 | 3 | | | DEPRECATED_5 | 4 | | | DEPRECATED_6 | 8 | | | DEPRECATED_7 | 16 | |",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#enumnetworkowner"
        },
        {
            "title": "Protocol Documentation: EnumProvisioning",
            "excerpt": "| Name | Number | Description | | ---- | ------ | ----------- | | PROVISIONING_UNKNOWN | 0 | | | PROVISIONING_NEVER_STARTED | 1 | | | PROVISIONING_STARTED | 2 | | | PROVISIONING_ABORTED_BY_SYSTEM | 3 | | | PROVISIONING_CANCELLED_BY_USER | 4 | | | PROVISIONING_SUCCESS_NEW_AP | 5 | | | PROVISIONING_SUCCESS_OLD_AP | 6 | | | PROVISIONING_ERROR_FAILED_TO_ASSOCIATE | 7 | | | PROVISIONING_ERROR_PASSWORD_AUTH | 8 | | | PROVISIONING_ERROR_EULA_BLOCKING | 9 | | | PROVISIONING_ERROR_NO_INTERNET | 10 | | | PROVISIONING_ERROR_UNSUPPORTED_TYPE | 11 | |",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#enumprovisioning"
        },
        {
            "title": "Protocol Documentation: EnumScanEntryFlags",
            "excerpt": "| Name | Number | Description | | ---- | ------ | ----------- | | SCAN_FLAG_OPEN | 0 | | | SCAN_FLAG_AUTHENTICATED | 1 | | | SCAN_FLAG_CONFIGURED | 2 | This network has been previous provisioned | | SCAN_FLAG_BEST_SSID | 4 | | | SCAN_FLAG_ASSOCIATED | 8 | | | SCAN_FLAG_UNSUPPORTED_TYPE | 16 | | | DEPRECATED | 32 | |",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#enumscanentryflags"
        },
        {
            "title": "Protocol Documentation: EnumScanning",
            "excerpt": "| Name | Number | Description | | ---- | ------ | ----------- | | SCANNING_UNKNOWN | 0 | | | SCANNING_NEVER_STARTED | 1 | | | SCANNING_STARTED | 2 | | | SCANNING_ABORTED_BY_SYSTEM | 3 | | | SCANNING_CANCELLED_BY_USER | 4 | | | SCANNING_SUCCESS | 5 | |",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#enumscanning"
        },
        {
            "title": "Protocol Documentation: preset_status.proto",
            "excerpt": "",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#preset-status-proto"
        },
        {
            "title": "Protocol Documentation: NotifyPresetStatus",
            "excerpt": "| Field | Type | Label | Description | | ----- | ---- | ----- | ----------- | | preset_group_array | [PresetGroup](open_gopro-PresetGroup) | repeated | Array of Preset Groups |",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#notifypresetstatus"
        },
        {
            "title": "Protocol Documentation: Preset",
            "excerpt": "| Field | Type | Label | Description | | ----- | ---- | ----- | ----------- | | id | [int32](int32) | optional | Preset ID | | mode | [EnumFlatMode](open_gopro-EnumFlatMode) | optional | Preset flatmode ID | | title_id | [EnumPresetTitle](open_gopro-EnumPresetTitle) | optional | Preset Title ID | | title_number | [int32](int32) | optional | Preset Title Number (e.g. 1/2/3 in Custom1, Custom2, Custom3) | | user_defined | [bool](bool) | optional | Is the Preset custom/user-defined? | | icon | [EnumPresetIcon](open_gopro-EnumPresetIcon) | optional | Preset Icon ID | | setting_array | [PresetSetting](open_gopro-PresetSetting) | repeated | Array of settings associated with this Preset | | is_modified | [bool](bool) | optional | Has Preset been modified from factory | | is_fixed | [bool](bool) | optional | Is this Preset mutable? |",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#preset"
        },
        {
            "title": "Protocol Documentation: PresetGroup",
            "excerpt": "| Field | Type | Label | Description | | ----- | ---- | ----- | ----------- | | id | [EnumPresetGroup](open_gopro-EnumPresetGroup) | optional | Preset Group ID | | preset_array | [Preset](open_gopro-Preset) | repeated | Array of Presets contained in this Preset Group | | can_add_preset | [bool](bool) | optional | Is there room in the group to add additional Presets? | | icon | [EnumPresetGroupIcon](open_gopro-EnumPresetGroupIcon) | optional | The icon to display for this preset group |",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#presetgroup"
        },
        {
            "title": "Protocol Documentation: PresetSetting",
            "excerpt": "| Field | Type | Label | Description | | ----- | ---- | ----- | ----------- | | id | [int32](int32) | optional | Setting ID | | value | [int32](int32) | optional | Setting value | | is_caption | [bool](bool) | optional | Does this setting appear on the Preset \"pill\" in the camera UI? |",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#presetsetting"
        },
        {
            "title": "Protocol Documentation: EnumFlatMode",
            "excerpt": "| Name | Number | Description | | ---- | ------ | ----------- | | FLAT_MODE_UNKNOWN | -1 | | | FLAT_MODE_PLAYBACK | 4 | | | FLAT_MODE_SETUP | 5 | | | FLAT_MODE_VIDEO | 12 | | | FLAT_MODE_TIME_LAPSE_VIDEO | 13 | | | FLAT_MODE_LOOPING | 15 | | | FLAT_MODE_PHOTO_SINGLE | 16 | | | FLAT_MODE_PHOTO | 17 | | | FLAT_MODE_PHOTO_NIGHT | 18 | | | FLAT_MODE_PHOTO_BURST | 19 | | | FLAT_MODE_TIME_LAPSE_PHOTO | 20 | | | FLAT_MODE_NIGHT_LAPSE_PHOTO | 21 | | | FLAT_MODE_BROADCAST_RECORD | 22 | | | FLAT_MODE_BROADCAST_BROADCAST | 23 | | | FLAT_MODE_TIME_WARP_VIDEO | 24 | | | FLAT_MODE_LIVE_BURST | 25 | | | FLAT_MODE_NIGHT_LAPSE_VIDEO | 26 | | | FLAT_MODE_SLOMO | 27 | | | FLAT_MODE_IDLE | 28 | | | FLAT_MODE_VIDEO_STAR_TRAIL | 29 | | | FLAT_MODE_VIDEO_LIGHT_PAINTING | 30 | | | FLAT_MODE_VIDEO_LIGHT_TRAIL | 31 | |",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#enumflatmode"
        },
        {
            "title": "Protocol Documentation: EnumPresetGroup",
            "excerpt": "| Name | Number | Description | | ---- | ------ | ----------- | | PRESET_GROUP_ID_VIDEO | 1000 | | | PRESET_GROUP_ID_PHOTO | 1001 | | | PRESET_GROUP_ID_TIMELAPSE | 1002 | | | PRESET_GROUP_ID_VIDEO_DUAL_LENS | 1003 | | | PRESET_GROUP_ID_PHOTO_DUAL_LENS | 1004 | | | PRESET_GROUP_ID_TIMELAPSE_DUAL_LENS | 1005 | | | PRESET_GROUP_ID_SPECIAL | 1006 | |",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#enumpresetgroup"
        },
        {
            "title": "Protocol Documentation: EnumPresetGroupIcon",
            "excerpt": "| Name | Number | Description | | ---- | ------ | ----------- | | PRESET_GROUP_VIDEO_ICON_ID | 0 | | | PRESET_GROUP_PHOTO_ICON_ID | 1 | | | PRESET_GROUP_TIMELAPSE_ICON_ID | 2 | | | PRESET_GROUP_LONG_BAT_VIDEO_ICON_ID | 3 | | | PRESET_GROUP_ENDURANCE_VIDEO_ICON_ID | 4 | | | PRESET_GROUP_MAX_VIDEO_ICON_ID | 5 | | | PRESET_GROUP_MAX_PHOTO_ICON_ID | 6 | | | PRESET_GROUP_MAX_TIMELAPSE_ICON_ID | 7 | |",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#enumpresetgroupicon"
        },
        {
            "title": "Protocol Documentation: EnumPresetIcon",
            "excerpt": "| Name | Number | Description | | ---- | ------ | ----------- | | PRESET_ICON_VIDEO | 0 | | | PRESET_ICON_ACTIVITY | 1 | | | PRESET_ICON_CINEMATIC | 2 | | | PRESET_ICON_PHOTO | 3 | | | PRESET_ICON_LIVE_BURST | 4 | | | PRESET_ICON_BURST | 5 | | | PRESET_ICON_PHOTO_NIGHT | 6 | | | PRESET_ICON_TIMEWARP | 7 | | | PRESET_ICON_TIMELAPSE | 8 | | | PRESET_ICON_NIGHTLAPSE | 9 | | | PRESET_ICON_SNAIL | 10 | | | PRESET_ICON_VIDEO_2 | 11 | | | PRESET_ICON_360_VIDEO | 12 | | | PRESET_ICON_PHOTO_2 | 13 | | | PRESET_ICON_PANORAMA | 14 | | | PRESET_ICON_BURST_2 | 15 | | | PRESET_ICON_TIMEWARP_2 | 16 | | | PRESET_ICON_TIMELAPSE_2 | 17 | | | PRESET_ICON_CUSTOM | 18 | | | PRESET_ICON_AIR | 19 | | | PRESET_ICON_BIKE | 20 | | | PRESET_ICON_EPIC | 21 | | | PRESET_ICON_INDOOR | 22 | | | PRESET_ICON_MOTOR | 23 | | | PRESET_ICON_MOUNTED | 24 | | | PRESET_ICON_OUTDOOR | 25 | | | PRESET_ICON_POV | 26 | | | PRESET_ICON_SELFIE | 27 | | | PRESET_ICON_SKATE | 28 | | | PRESET_ICON_SNOW | 29 | | | PRESET_ICON_TRAIL | 30 | | | PRESET_ICON_TRAVEL | 31 | | | PRESET_ICON_WATER | 32 | | | PRESET_ICON_LOOPING | 33 | | | PRESET_ICON_MAX_VIDEO | 55 | Reserved 34 - 50 for Custom presets | | PRESET_ICON_MAX_PHOTO | 56 | | | PRESET_ICON_MAX_TIMEWARP | 57 | | | PRESET_ICON_BASIC | 58 | | | PRESET_ICON_ULTRA_SLO_MO | 59 | | | PRESET_ICON_STANDARD_ENDURANCE | 60 | | | PRESET_ICON_ACTIVITY_ENDURANCE | 61 | | | PRESET_ICON_CINEMATIC_ENDURANCE | 62 | | | PRESET_ICON_SLOMO_ENDURANCE | 63 | | | PRESET_ICON_STATIONARY_1 | 64 | | | PRESET_ICON_STATIONARY_2 | 65 | | | PRESET_ICON_STATIONARY_3 | 66 | | | PRESET_ICON_STATIONARY_4 | 67 | | | PRESET_ICON_STAR_TRAIL | 76 | | | PRESET_ICON_LIGHT_PAINTING | 77 | | | PRESET_ICON_LIGHT_TRAIL | 78 | | | PRESET_ICON_FULL_FRAME | 79 | | | PRESET_ICON_TIMELAPSE_PHOTO | 1000 | | | PRESET_ICON_NIGHTLAPSE_PHOTO | 1001 | | | PRESET_ICON_MAX | 1002 | |",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#enumpreseticon"
        },
        {
            "title": "Protocol Documentation: EnumPresetTitle",
            "excerpt": "| Name | Number | Description | | ---- | ------ | ----------- | | PRESET_TITLE_ACTIVITY | 0 | | | PRESET_TITLE_STANDARD | 1 | | | PRESET_TITLE_CINEMATIC | 2 | | | PRESET_TITLE_PHOTO | 3 | | | PRESET_TITLE_LIVE_BURST | 4 | | | PRESET_TITLE_BURST | 5 | | | PRESET_TITLE_NIGHT | 6 | | | PRESET_TITLE_TIME_WARP | 7 | | | PRESET_TITLE_TIME_LAPSE | 8 | | | PRESET_TITLE_NIGHT_LAPSE | 9 | | | PRESET_TITLE_VIDEO | 10 | | | PRESET_TITLE_SLOMO | 11 | | | PRESET_TITLE_360_VIDEO | 12 | | | PRESET_TITLE_PHOTO_2 | 13 | | | PRESET_TITLE_PANORAMA | 14 | | | PRESET_TITLE_360_PHOTO | 15 | | | PRESET_TITLE_TIME_WARP_2 | 16 | | | PRESET_TITLE_360_TIME_WARP | 17 | | | PRESET_TITLE_CUSTOM | 18 | | | PRESET_TITLE_AIR | 19 | | | PRESET_TITLE_BIKE | 20 | | | PRESET_TITLE_EPIC | 21 | | | PRESET_TITLE_INDOOR | 22 | | | PRESET_TITLE_MOTOR | 23 | | | PRESET_TITLE_MOUNTED | 24 | | | PRESET_TITLE_OUTDOOR | 25 | | | PRESET_TITLE_POV | 26 | | | PRESET_TITLE_SELFIE | 27 | | | PRESET_TITLE_SKATE | 28 | | | PRESET_TITLE_SNOW | 29 | | | PRESET_TITLE_TRAIL | 30 | | | PRESET_TITLE_TRAVEL | 31 | | | PRESET_TITLE_WATER | 32 | | | PRESET_TITLE_LOOPING | 33 | | | PRESET_TITLE_360_TIMELAPSE | 51 | Reserved 34 - 50 for custom presets. | | PRESET_TITLE_360_NIGHT_LAPSE | 52 | | | PRESET_TITLE_360_NIGHT_PHOTO | 53 | | | PRESET_TITLE_PANO_TIME_LAPSE | 54 | | | PRESET_TITLE_MAX_VIDEO | 55 | | | PRESET_TITLE_MAX_PHOTO | 56 | | | PRESET_TITLE_MAX_TIMEWARP | 57 | | | PRESET_TITLE_BASIC | 58 | | | PRESET_TITLE_ULTRA_SLO_MO | 59 | | | PRESET_TITLE_STANDARD_ENDURANCE | 60 | | | PRESET_TITLE_ACTIVITY_ENDURANCE | 61 | | | PRESET_TITLE_CINEMATIC_ENDURANCE | 62 | | | PRESET_TITLE_SLOMO_ENDURANCE | 63 | | | PRESET_TITLE_STATIONARY_1 | 64 | | | PRESET_TITLE_STATIONARY_2 | 65 | | | PRESET_TITLE_STATIONARY_3 | 66 | | | PRESET_TITLE_STATIONARY_4 | 67 | | | PRESET_TITLE_SIMPLE_VIDEO | 68 | | | PRESET_TITLE_SIMPLE_TIME_WARP | 69 | | | PRESET_TITLE_SIMPLE_SUPER_PHOTO | 70 | | | PRESET_TITLE_SIMPLE_NIGHT_PHOTO | 71 | | | PRESET_TITLE_SIMPLE_VIDEO_ENDURANCE | 72 | | | PRESET_TITLE_HIGHEST_QUALITY | 73 | | | PRESET_TITLE_EXTENDED_BATTERY | 74 | | | PRESET_TITLE_LONGEST_BATTERY | 75 | | | PRESET_TITLE_STAR_TRAIL | 76 | | | PRESET_TITLE_LIGHT_PAINTING | 77 | | | PRESET_TITLE_LIGHT_TRAIL | 78 | | | PRESET_TITLE_FULL_FRAME | 79 | | | PRESET_TITLE_MAX_LENS_VIDEO | 80 | | | PRESET_TITLE_MAX_LENS_TIMEWARP | 81 | | | PRESET_TITLE_MAX | 82 | |",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#enumpresettitle"
        },
        {
            "title": "Protocol Documentation: request_get_preset_status.proto",
            "excerpt": "",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#request-get-preset-status-proto"
        },
        {
            "title": "Protocol Documentation: RequestGetPresetStatus",
            "excerpt": "| Field | Type | Label | Description | | ----- | ---- | ----- | ----------- | | register_preset_status | [EnumRegisterPresetStatus](open_gopro-EnumRegisterPresetStatus) | repeated | Array of Preset statuses to be notified about | | unregister_preset_status | [EnumRegisterPresetStatus](open_gopro-EnumRegisterPresetStatus) | repeated | Array of Preset statuses to stop being notified about |",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#requestgetpresetstatus"
        },
        {
            "title": "Protocol Documentation: EnumRegisterPresetStatus",
            "excerpt": "| Name | Number | Description | | ---- | ------ | ----------- | | REGISTER_PRESET_STATUS_PRESET | 1 | | | REGISTER_PRESET_STATUS_PRESET_GROUP_ARRAY | 2 | |",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#enumregisterpresetstatus"
        },
        {
            "title": "Protocol Documentation: response_generic.proto",
            "excerpt": "",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#response-generic-proto"
        },
        {
            "title": "Protocol Documentation: ResponseGeneric",
            "excerpt": "| Field | Type | Label | Description | | ----- | ---- | ----- | ----------- | | result | [EnumResultGeneric](open_gopro-EnumResultGeneric) | required | Generic pass/fail/error info |",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#responsegeneric"
        },
        {
            "title": "Protocol Documentation: EnumResultGeneric",
            "excerpt": "| Name | Number | Description | | ---- | ------ | ----------- | | RESULT_UNKNOWN | 0 | | | RESULT_SUCCESS | 1 | | | RESULT_ILL_FORMED | 2 | | | RESULT_NOT_SUPPORTED | 3 | | | RESULT_ARGUMENT_OUT_OF_BOUNDS | 4 | | | RESULT_ARGUMENT_INVALID | 5 | |",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#enumresultgeneric"
        },
        {
            "title": "Protocol Documentation: set_camera_control_status.proto",
            "excerpt": "",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#set-camera-control-status-proto"
        },
        {
            "title": "Protocol Documentation: RequestSetCameraControlStatus",
            "excerpt": "| Field | Type | Label | Description | | ----- | ---- | ----- | ----------- | | camera_control_status | [EnumCameraControlStatus](open_gopro-EnumCameraControlStatus) | required | Declare who is taking control of the camera |",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#requestsetcameracontrolstatus"
        },
        {
            "title": "Protocol Documentation: EnumCameraControlStatus",
            "excerpt": "| Name | Number | Description | | ---- | ------ | ----------- | | CAMERA_IDLE | 0 | | | CAMERA_CONTROL | 1 | Can only be set by camera, not by third-party | | CAMERA_EXTERNAL_CONTROL | 2 | |",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#enumcameracontrolstatus"
        },
        {
            "title": "Protocol Documentation: turbo_transfer.proto",
            "excerpt": "",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#turbo-transfer-proto"
        },
        {
            "title": "Protocol Documentation: RequestSetTurboActive",
            "excerpt": "| Field | Type | Label | Description | | ----- | ---- | ----- | ----------- | | active | [bool](bool) | required | Enable or disable Turbo Transfer feature |",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#requestsetturboactive"
        },
        {
            "title": "Protocol Documentation: Scalar Value Types",
            "excerpt": "| .proto Type | Notes | C++ | Java | Python | Go | C | PHP | Ruby | | ----------- | ----- | --- | ---- | ------ | -- | -- | --- | ---- | | double | | double | double | float | float64 | double | float | Float | | float | | float | float | float | float32 | float | float | Float | | int32 | Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead. | int32 | int | int | int32 | int | integer | Bignum or Fixnum (as required) | | int64 | Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead. | int64 | long | int/long | int64 | long | integer/string | Bignum | | uint32 | Uses variable-length encoding. | uint32 | int | int/long | uint32 | uint | integer | Bignum or Fixnum (as required) | | uint64 | Uses variable-length encoding. | uint64 | long | int/long | uint64 | ulong | integer/string | Bignum or Fixnum (as required) | | sint32 | Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. | int32 | int | int | int32 | int | integer | Bignum or Fixnum (as required) | | sint64 | Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. | int64 | long | int/long | int64 | long | integer/string | Bignum | | fixed32 | Always four bytes. More efficient than uint32 if values are often greater than 2^28. | uint32 | int | int | uint32 | uint | integer | Bignum or Fixnum (as required) | | fixed64 | Always eight bytes. More efficient than uint64 if values are often greater than 2^56. | uint64 | long | int/long | uint64 | ulong | integer/string | Bignum | | sfixed32 | Always four bytes. | int32 | int | int | int32 | int | integer | Bignum or Fixnum (as required) | | sfixed64 | Always eight bytes. | int64 | long | int/long | int64 | long | integer/string | Bignum | | bool | | bool | boolean | boolean | bool | bool | boolean | TrueClass/FalseClass | | string | A string must always contain UTF-8 encoded or 7-bit ASCII text. | string | String | str/unicode | string | string | string | String (UTF-8) | | bytes | May contain any arbitrary sequence of bytes. | string | ByteString | str | []byte | ByteString | string | String (ASCII-8BIT) |",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/protos#scalar-value-types"
        },
        {
            "title": "Tutorials: ",
            "excerpt": "This set of tutorials is a series of sample scripts / files and accompanying .html walk-throughs to implement basic functionality to interact with a GoPro device using the following languages: - Python - Kotlin - More to come! The tutorials only support Open GoPro Version 2.0 and must be run on a [supported camera]({% link specs/ble_versions/ble_2_0.md %}supported-cameras). They will provide walk-throughs and sample code to use the relevant language / framework to exercise the Open GoPro Interface using Bluetooth Low Energy (BLE) and HTTP over WiFi. The tutorials are meant as an introduction to the Open GoPro specification. They are not a substitute for the complete [BLE]({% link specs/ble_versions/ble_2_0.md %}) and [HTTP]({% link specs/http_versions/http_2_0.md %}) specifications which will be your main source of reference after completing the tutorials. {% for tutorial in site.tutorials %} - [{{ tutorial.title }}]({{ tutorial.permalink | prepend: site.baseurl }}) {% endfor %}",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/tutorials/#"
        },
        {
            "title": "Over the Air Firmware Update Demo: ",
            "excerpt": "Over the Air Firmware Update Demo Assumptions Prerequisites OTA Procedure Usage Testing This directory contains a bash script to perform an over-the-air (OTA) firmware (FW) update to the camera. Assumptions The host PC is already connected via WiFi to the target camera The target FW images are already provided from GoPro as a .zip file. These can be found on the Update Page or programmatically from the Firmware Catalog JSON information. Prerequisites Alternatively to satisfying these prerequisites, the script can be run with the Docker option (see usage) The script uses open ssl to calculate the hash so openssl must be installed and available on the system path. The script uses curl to send HTTP commands so curl must be installed and available on the system path. OTA Procedure The OTA procedure requires the following steps: Calculate the SHA1 hash of the target .zip file. Delete any partially stored data. Show the update UI Upload the target firmware to the camera Notify the camera that the upload is complete Instruct the camera to load the new firmware Usage Call the send_ota.sh script here with the -h option for a detailed usage: Usage: ./send_ota.sh [-d] OTA_UPDATE_FILE Given a target FW .zip file, calculate its SHA1 hash, then send it over-the-air to an already connected camera. Required positional arguments: OTA_UPDATE_FILE target .zip file to send over-the-air. If using docker, must be passed as relative path from the directory of this script Optional arguments: -d Use docker for openssl and curl commands. -h Print this Help. Testing There is a test script that will use a Python script (contained in a Docker container) to: get the FW catalog JSON get the UPDATE.zip from the link in the JSON exercise the send_ota.sh script to send this firmware to the camera (outside of the container) The test script is located ./test/test.sh and should be passed the camera that is connected, i.e.: ./test.sh \"HERO_11\" Note! The test script needs to be run from the test folder You can also run with the --help parameter to get a list of cameras.",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/demos/demos/bash/ota_update#"
        },
        {
            "title": "GoPro C/C++ Demos: ",
            "excerpt": "GoPro C/C++ Demos Build Requirements Steps Run Requirements Steps Media Commands Stream Commands This folder contains C and C++ examples to perform some Open GoPro functionality. There are two examples, each of which are detailed in a section below. Media Commands Stream Commands Build Requirements This demo depends on the following external libraries: libCurl: a client-side URL transfer library used to make command requests to the camera over WiFi and get the JSON response cJSON: an ultra-light JSON parser that can be used to parse the JSON responses from the WiFi commands To use the build system contained here, the following programs are required to be installed: Conan: a python-based C / C++ package manager If a local python 3 is found, this will be automatically installed CMake: a project configuration and build tool Steps Run the build.sh file. This will: verify existence of requirements (and install Conan if applicable) use Conan to download and install libCurl and cJson use CMake to configure build system and build executables The output binaries will then be available in build/bin Run Requirements Before running the executables built here, you must first be connected to the camera’s WiFi Access Point. This can be done via: Connect BLE to turn on AP and get WiFi SSID/PASSPHRASE Use retrieved WiFi SSID/PASSPHRASE to connect system to GoPro WiFi A programmatic example of this process can be found in the Open GoPro Python SDK’s Connect Wifi Demo. This can be run (assuming a local Python 3.8.x installation exists) via: pip install open-gopro gopro-wifi Steps Media Commands This demo shows one way to get the media list and download the first media file. It also supports requests to get the media list, media info and downloading specific media files. For a list of possible commands, do: $ ./build/bin/media_commands --help Media List: $ ./build/bin/media_commands &lt;-l, --list_files&gt; Media List(Pretty Print): $ ./build/bin/media_commands &lt;-f, --list_files_pretty&gt; Media Info: $ ./build/bin/media_commands &lt;-i, --info&gt; &lt;camera_file_path&gt; Media Info(Pretty Print): $ ./build/bin/media_commands &lt;-p, --info_pretty&gt; &lt;camera_file_path&gt; Media Download: $ ./build/bin/media_commands &lt;-g, --download&gt; &lt;camera_file_path&gt; &lt;output_path/output_file_name&gt; Media Hilight Moment: $ ./build/bin/media_commands --tag Media Hilight File: $ ./build/bin/media_commands --tag-video &lt;video_file_path&gt; &lt;offset_ms&gt; $ ./build/bin/media_commands --tag-photo &lt;photo_file_path&gt; Media Hilight Remove: $ ./build/bin/media_commands --tag-video-remove &lt;video_file_path&gt; &lt;offset_ms&gt; $ ./build/bin/media_commands --tag-photo-remove &lt;photo_file_path&gt; Media Demo: $ ./build/bin/media_commands &lt;-d, --demo&gt; &lt;output_path&gt; Stream Commands This demo demonstrates one way to start and stop the preview stream. Note: To run the Preview Stream demo. A media player (i.e: VLC) that supports UDP is needed to view the preview stream. The UDP address is udp://0.0.0.0:8554 Start Stream: $ ./build/bin/stream_commands &lt;-s, --start&gt; Stop Stream: $ ./build/bin/stream_commands &lt;-e, --end&gt; Preview Stream Demo: $ ./build/bin/stream_commands &lt;-d, --demo&gt;",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/demos/demos/c_c++/GoProC_C++Demo#"
        },
        {
            "title": "GoPro Low Latency Stream Demo: ",
            "excerpt": "This demostrates how to decode the GoPro webcam or 16x9 video preview stream using the ffmpeg library. To use this demo, plug in a hero 9 or hero 10 camera while in a standard video mode and run the app. The webcam stream at 1080p should be displayed in the window. The display output is not optimized. To switch to preview stream (720p non processed stream), uncomment the define in GoProStreamDemo.h //define USE_PREVIEW_STREAM",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/demos/demos/c_c++/GoProStreamDemo#"
        },
        {
            "title": "GoProCSharpSample: ",
            "excerpt": "This sample demonstrates how to discover, pair, and connect to a GoPro camera via Bluetooth LE (BLE). Once a connection is established, the code shows how to: Enable Wi-Fi on the GoPro camera Read the camera wifi name and password Get status and notification of camera’s battery level, encoding flag, and wifi ap on flag. Start and stop camera shutter Requirements Visual Studio is required to run the solution. Visit https://visualstudio.microsoft.com/downloads/ to download. The target .NET framework is v4.7.2 GoPro camera must be paired before any other operations will succeed. Put the camera in pairing mode before attempting pairing with the app. Usage Open and run the demo in Visual Studio to show the GUI Scan for GoPro devices Pair to the discovered device that is not GoPro Cam. In the .gif below, this is GoPro 0456 (Only needs to be done once, or if camera is factory reset) After pairing is successful, connect to the same GoPro device Now use any of the GUI buttons to read WiFi info, enable WiFi AP, set shutter, etc.",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/demos/demos/csharp/GoProCSharpSample#"
        },
        {
            "title": "CSharp Webcam Demo: ",
            "excerpt": "This demo implements a simple GUI to interact with a GoPro camera that supports Open GoPro 2.0. Requirements This demo will only run on Windows. Visual Studio is required to run the solution. Visit VisualStudio to download. The target .NET framework is v4.7.2 GoPro camera must be paired before any other operations will succeed. Put the camera in pairing mode before attempting pairing with the app. Prerequisites The correct GoPro Webcam drivers must be installed. To verify this, ensure that you can first use your desired GoPro as a webcam following the steps here. Usage Connect the GoPro to your computer using the USB cable Open the solution (GoProWebCamViewer.sln) in Visual Studio, build and run io to show the Webcam GUI Select Start Player to start the VLC backend. Note that the log and status bar have updated. This will be true for all functionality. Select Show Preview to start a low quality preview stream While in preview, feel free to update the FOV or change the zoom Once you are ready, select Start Webcam to start full resolution streaming",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/demos/demos/csharp/webcam#"
        },
        {
            "title": "Multi Webcam: ",
            "excerpt": "Multi Webcam Assumptions Installation Quick Start Start Webcam Example Single Webcam Multiple Webcams Module Usage This is a small Python module to demonstrate GoPro Webcam usage, including how to use multiple webcams simultaneously from the same PC. Assumptions It is assumed that the GoPro’s are using firmware versions that support the port parameter to the Start Webcam endpoint. See the Open GoPro Commands Quick Reference for more information. Installation This module requires Python &gt;= 3.9 and &lt; 3.11. It should be installed locally, either with pip via: pip install . or poetry via: poetry install --only main Quick Start Once installed, the following CLI programs are available: Each CLI has useful help available by calling it with the --help argument Start Webcam Configure and start a single webcam. Its stream can then be viewed using, for example VLC. usage: start-webcam [-h] [-p PORT] [-r RESOLUTION] [-f FOV] serial Enable and start the webcam. positional arguments: serial Last 3 digits of camera serial number. options: -h, --help show this help message and exit -p PORT, --port PORT Port to use. If not set, port will not be specified to camera. -r RESOLUTION, --resolution RESOLUTION Resolution to use. If set, fov must also be set. -f FOV, --fov FOV FOV to use. If set, resolution must also be set Example start-webcam 992 -p 9000 The stream can than be viewed at udp://@0.0.0.0:9001 Single Webcam Configure and start a single webcam. Then display its stream. This is different than the previous program in that it also handles displaying the stream (using OpenCV). usage: single-webcam [-h] [-p PORT] [-r RESOLUTION] [-f FOV] serial Enable and start the webcam and a player to view it. positional arguments: serial Last 3 digits of camera serial number. options: -h, --help show this help message and exit -p PORT, --port PORT Port to use. If not set, port will not be specified to camera. -r RESOLUTION, --resolution RESOLUTION Resolution to use. If set, fov must also be set. -f FOV, --fov FOV FOV to use. If set, resolution must also be set Multiple Webcams Using a .json configuraton file, configure, start, and view multiple webcams. usage: multi-webcam [-h] config Configure, enable and start webcams with players to view them. positional arguments: config Location of config json file. options: -h, --help show this help message and exit where an example config file could look like this: { \"992\": { \"port\": 9000, \"resolution\": 12, \"fov\": 0 }, \"149\": { \"resolution\": 12, \"fov\": 0 } } If port is not set, an available port will be discovered automatically starting at 8554. If resolution or fov are not set, they will be set to defaults by the GoPro. Cameras Module Usage For detailed module usage, see the docstrings in ./multi_webcam/webcam.py.",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/demos/demos/python/multi_webcam#"
        },
        {
            "title": "Open GoPro Python SDK: ",
            "excerpt": "This is a Python package that provides an interface for the user to exercise the Open GoPro Bluetooth Low Energy (BLE) and Wi-Fi / USB HTTP API’s as well as install command line interfaces to take photos, videos, and view video streams. Free software: MIT license Documentation: View on Open GoPro View on Github Documentation Note! This README is only an overview of the package. Complete documentation can be found on Open GoPro Features Top-level GoPro class interface to use BLE, WiFi, and / or USB Cross-platform (tested on MacOS Big Sur, Windows 10, and Ubuntu 20.04) BLE implemented using bleak Wi-Fi controller provided in the Open GoPro package (loosely based on the Wireless Library Supports all commands, settings, and statuses from the Open GoPro API Automatically handles connection maintenance: manage camera ready / encoding periodically sends keep alive signals Includes detailed logging for each module Includes demo scripts installed as command-line applications to show BLE, WiFi, and USB functionality such as: Take a photo Take a video Configure and view a GoPro webcam stream GUI to send all commands and view the live / preview stream Log the battery Installation Note! This package requires Python &gt;= 3.8 and &lt; 3.11 The minimal install to use the Open GoPro library and the CLI demos is: $ pip install open-gopro To also install the extra dependencies to run the GUI demos, do: $ pip install open-gopro[gui] Usage To automatically connect to GoPro device via BLE and WiFI, set the preset, set video parameters, take a video, and download all files: import time from open_gopro import WirelessGoPro, Params with WirelessGoPro() as gopro: gopro.ble_command.load_preset(Params.Preset.CINEMATIC) gopro.ble_setting.resolution.set(Params.Resolution.RES_4K) gopro.ble_setting.fps.set(Params.FPS.FPS_30) gopro.ble_command.set_shutter(Params.Shutter.ON) time.sleep(2) Record for 2 seconds gopro.ble_command.set_shutter(Params.Shutter.OFF) Download all of the files from the camera media_list = [x[\"n\"] for x in gopro.wifi_command.get_media_list().flatten for file in media_list: gopro.wifi_command.download_file(camera_file=file) And much more! Demos Note! These demos can be found on Github Demos can be found in the installed package in the “demos” folder. They are installed as a CLI entrypoint and can be run as shown below. Command Line Interface (CLI) Demos All of these demos are CLI only and can thus be run with the minimal (non-GUI) install. Capture a photo and download it to your computer: $ gopro-photo Capture a video and download it to your computer: $ gopro-video Connect to the GoPro and log battery consumption in to a .csv: $ gopro-log-battery Connect to the GoPro’s Wi-Fi AP and maintain the connection: $ gopro-wifi For more information on each, try running with help as such: $ gopro-photo --help usage: gopro-photo [-h] [-i IDENTIFIER] [-l LOG] [-o OUTPUT] [-w WIFI_INTERFACE] Connect to a GoPro camera, take a photo, then download it. optional arguments: -h, --help show this help message and exit -i IDENTIFIER, --identifier IDENTIFIER Last 4 digits of GoPro serial number, which is the last 4 digits of the default camera SSID. If not used, first discovered GoPro will be connected to -l LOG, --log LOG Location to store detailed log -o OUTPUT, --output OUTPUT Where to write the photo to. If not set, write to 'photo.jpg' -w WIFI_INTERFACE, --wifi_interface WIFI_INTERFACE System Wifi Interface. If not set, first discovered interface will be used. GUI Demos These demos require the additional GUI installation. Start the preview stream and view it: $ gopro-preview-stream Start the live stream and view it: $ gopro-live-stream",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/demos/demos/python/sdk_wireless_camera_control#"
        },
        {
            "title": "Swift Enable WiFi Demo: ",
            "excerpt": "This demo demonstrates how to discover and connect to a GoPro camera via Bluetooth LE (BLE). Once a connection is established, the demo demonstrates how to enable Wi-Fi on the GoPro camera and join the camera’s Wi-Fi. The steps required to join camera’s Wi-Fi are: Enable Wi-Fi Request camera’s Wi-Fi settings (SSID and password) Use iOS NetworkExtension API to join camera’s WiFi Requirements GoPro camera must be paired with the mobile device. If the camera is not paired, put the camera in pairing mode File Structure BLE CentralManager.swift - A simple wrapper around CBCentralManager to handle CoreBluetooth Central related tasks Peripheral.swift - A simple wrapper around CBPeripheral to handle CoreBluetooth Peripheral related tasks Peripheral+Camera.swift - An extension of Peripheral class for sending commands to a GoPro camera Views CameraSelectionView.swift - A SwiftUI list view for showing the nearby GoPro cameras CameraView.swift - A simple view with a button for initiate the request to enable Wi-Fi on the connected GoPro camera",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/demos/demos/swift/EnableWiFiDemo#"
        },
        {
            "title": "Tutorial 1: Connect BLE: ",
            "excerpt": "This tutorial will provide a walk-through to connect to the GoPro camera via Bluetooth Low Energy (BLE). Requirements Hardware A GoPro camera that is supported by Open GoPro python kotlin One of the following systems: Windows 10, version 16299 (Fall Creators Update) or greater Linux distribution with BlueZ &gt;= 5.43 OS X/macOS support via Core Bluetooth API, from at least OS X version 10.11 An Android Device supporting SDK &gt;= 33 Software python kotlin Python &gt;= 3.8.x must be installed. See this Python installation guide. Android Studio &gt;= 2022.1.1 (Electric Eel) Overview / Assumptions python kotlin This tutorial will use bleak to control the OS’s Bluetooth Low Energy (BLE). The Bleak BLE controller does not currently support autonomous pairing for the BlueZ backend. So if you are using BlueZ (i.e. Ubuntu, RaspberryPi, etc.), you need to first pair the camera from the command line as shown in the BlueZ tutorial. There is work to add this feature and progress can be tracked on the Github Issue. The bleak module is based on asyncio which means that its awaitable functions need to be called from an async coroutine. In order to do this, all of the code below should be running in an async function. We accomplish this in the tutorial scripts by making main async as such: import asyncio async def main() -&gt; None: Put our code here if __name__ == \"__main__\": asyncio.run(main()) These are stripped down Python tutorials that are only meant to show the basics. For a complete Python SDK that uses bleak as the backend as well as a cross-platform WiFi backend to easily write Python apps that control the GoPro, see the Open GoPro Python SDK This tutorial will provide a set of Kotlin tutorials to demonstrate Open GoPro Functionality. The tutorials are provided as a single Android Studio project targeted to run on an Android device. The tutorials are only concerned with application-level demonstrations of the Open GoPro API and therefore do not prioritize the following: UI: The tutorial project only contains a minimal UI to select, implement, and view logs for each tutorial Android architecture / best practices: the project architecture is designed to encapsulate Kotlin functionality to easily display per-tutorial functionality Android-specific requirements: permission handling, adapter enabling, etc are implemented in the project but not documented in the tutorials BLE / Wifi (HTTP) functionality: A simple BLE API is included in the project and will be touched upon in the tutorials. However, the focus of the tutorials is not on how the BLE API is implemented as a real project would likely use a third-party library for this such as Kable See the Punchthrough tutorials for Android BLE-Specific tutorials These tutorials assume familiarity and a base level of competence with: Android Studio Bluetooth Low Energy JSON HTTP Setup python kotlin This set of tutorials is accompanied by a Python package consisting of scripts separated by tutorial module. These can be found on Github. Once the Github repo has been cloned or downloaded to your local machine, the package can be installed as follows: Enter the python tutorials directory at $INSTALL/demos/python/tutorial/ where $INSTALL is the top level of the Open GoPro repo where it exists on your local machine Use pip to install the package (in editable mode in case you want to test out some changes): pip install -e . While it is out of the scope of this tutorial to describe, it is recommended to install the package in to a virtual environment in order to isolate system dependencies. You can test that installation was successful by viewing the installed package’s information: $ pip show open-gopro-python-tutorials Name: open-gopro-python-tutorials Version: 0.0.3 Summary: Open GoPro Python Tutorials Home-page: https://github.com/gopro/OpenGoPro Author: Tim Camise Author-email: gopro.com License: MIT Location: c:\\users\\tim\\gopro\\opengopro\\demos\\python\\tutorial Requires: bleak, requests Required-by: This set of tutorials is accompanied by an Android Studio project consisting of, among other project infrastructure, Kotlin files separated by tutorial module. The project can be found on Github. Once the Github repo has been cloned or downloaded to your local machine, open the project in Android studio. At this point you should be able to build and load the project to your Android device. The project will not work on an emulated device since BLE can not be emulated. Just Show me the Demo!! python kotlin Each of the scripts for this tutorial can be found in the Tutorial 1 directory.. Python &gt;= 3.8.x must be used as specified in the requirements You can test connecting to your camera through BLE using the following script: python ble_connect.py See the help for parameter definitions: $ python ble_connect.py --help usage: ble_connect.py [-h] [-i IDENTIFIER] Connect to a GoPro camera, pair, then enable notifications. optional arguments: -h, --help show this help message and exit -i IDENTIFIER, --identifier IDENTIFIER Last 4 digits of GoPro serial number, which is the last 4 digits of the default camera SSID. If not used, first discovered GoPro will be connected to The Kotlin file for this tutorial can be found on Github. To perform the tutorial, run the Android Studio project, select “Tutorial 1” from the dropdown and click on “Perform.” Perform Tutorial 1 This will start the tutorial and log to the screen as it executes. When the tutorial is complete, click “Exit Tutorial” to return to the Tutorial selection screen. Basic BLE Tutorial This tutorial will walk through the process of connecting to a GoPro via BLE. This same connect functionality will be used as a foundation for all future BLE tutorials. Here is a summary of the sequence that will be described in detail in the following sections: Open GoPro user deviceGoProScanningConnectedalt[If not Previously Paired]PairedReady to CommunicateAdvertisingAdvertisingConnectPair RequestPair ResponseEnable Notifications on Characteristic 1Enable Notifications on Characteristic 2Enable Notifications on Characteristic ..Enable Notifications on Characteristic NOpen GoPro user deviceGoPro Advertise First, we need to ensure the camera is discoverable (i.e. it is advertising). Follow the per-camera steps here. The screen should appear as such: Camera is discoverable. Scan Next, we must scan to discover the advertising GoPro Camera. python kotlin We will do this using bleak. Let’s initialize an empty dict that will store discovered devices, indexed by name: Map of devices indexed by name devices: Dict[str, BleakDevice] = {} We’re then going to scan for all devices. We are passing a scan callback to bleak in order to also find non-connectable scan responses. We are keeping any devices that have a device name. Scan callback to also catch nonconnectable scan responses def _scan_callback(device: BleakDevice, _: Any) -&gt; None: Add to the dict if not unknown if device.name != \"Unknown\" and device.name is not None: devices[device.name] = device Now discover and add connectable advertisements for device in await BleakScanner.discover(timeout=5, detection_callback=_scan_callback): if device.name != \"Unknown\" and device.name is not None: devices[device.name] = device Now we can search through the discovered devices to see if we found a GoPro. Any GoPro device name will be structured as GoPro XXXX where XXXX is the last four digits of your camera’s serial number. If you have renamed your GoPro to something other than the default, you will need to update the below steps accordingly. First, we define a regex which is either “GoPro “ followed by any four alphanumeric characters if no identifier was passed, or “GoPro “ concatenated with the identifier if it exists. In the demo ble_connect.py, the identifier is taken from the command-line arguments. token = re.compile(r\"GoPro [A-Z0-9]{4}\" if identifier is None else f\"GoPro {identifier}\") Now we build a list of matched devices by checking if each device’s name includes the token regex. matched_devices: List[BleakDevice] = [] Now look for our matching device(s) matched_devices = [device for name, device in devices.items() if token.match(name)] Due to potential RF interference and the asynchronous nature of BLE advertising / scanning, it is possible that the advertising GoPro will not be discovered by the scanning PC in one scan. Therefore, you may need to redo the scan (as ble_connect.py does) until a GoPro is found. That is, matched_device must contain at least one device. Similarly, connection establishment can fail for reasons out of our control. Therefore, the connection process is also wrapped in retry logic. Here is an example of the log from ble_connect.py of scanning for devices. Note that this includes several rescans until the devices was found. $ python ble_connect.py INFO:root:Scanning for bluetooth devices... INFO:root: Discovered: INFO:root: Discovered: TR8600 seri INFO:root:Found 0 matching devices. INFO:root: Discovered: INFO:root: Discovered: TR8600 seri INFO:root: Discovered: GoPro Cam INFO:root: Discovered: GoPro 0456 INFO:root:Found 1 matching devices. Among other devices, you should see GoPro XXXX where XXXX is the last four digits of your camera’s serial number. First let’s define a filter to find the GoPro. We do this by filtering on the GoPro Service UUID that is included in all GoPro advertisements: private val scanFilters = listOf&lt;ScanFilter&gt;( ScanFilter.Builder().setServiceUuid(ParcelUuid.fromString(GOPRO_UUID)).build() ) We then send this to the BLE API and collect events from the SharedFlow that it returns. We take the first event emitted from this SharedFlow and notify (via a Channel) that a GoPro advertiser has been found, store the GoPro’s BLE address, and stop the scan. ble.startScan(scanFilters).onSuccess { scanResults -&gt; val deviceChannel: Channel&lt;BluetoothDevice&gt; = Channel() // Collect scan results CoroutineScope(Dispatchers.IO).launch { scanResults.collect { scanResult -&gt; // We will take the first discovered gopro deviceChannel.send(scanResult.device) } } // Wait to receive the scan result goproAddress = deviceChannel.receive().address ble.stopScan(scanResults) } At this point, the GoPro’s BLE address is stored (as a String) in goproAddress. Here is an example log output from this process: Scanning for GoPro's Received scan result: GoPro 0992 Found GoPro: GoPro 0992 Connect Now that we have discovered at least one GoPro device to connect to, the next step is to establish a BLE connection to the camera. python kotlin We're just taking the first device if there are multiple. device = matched_devices[0] client = BleakClient(device) await client.connect(timeout=15) An example output of this is shown here where we can see that the connection has successfully been established as well as the GoPro’s BLE MAC address.: INFO:root:Establishing BLE connection to EF:5A:F6:13:E6:5A: GoPro 0456... INFO:bleak.backends.dotnet.client:Services resolved for BleakClientDotNet (EF:5A:F6:13:E6:5A) INFO:root:BLE Connected! ble.connect(goproAddress) At this point, the BLE connection is established but there is more setup to be done before we are ready to communicate. Pair The GoPro has encryption-protected characteristics which require us to pair before writing to them. Therefore now that we are connected, we need to attempt to pair. python kotlin try: await client.pair() except NotImplementedError: This is expected on Mac pass Not all OS’s allow pairing (at this time) but some require it. Rather than checking for the OS, we are just catching the exception when it fails. Rather than explicitly request pairing, we rely on the fact that Android will automatically start the pairing process if you try to read a characteristic that requires encryption. To do this, we read the Wifi AP Password characteristic. First we discover all characteristics (this will also be needed later when enabling notifications): ble.discoverCharacteristics(goproAddress) Then we read the relevant characteristic to trigger pairing: ble.readCharacteristic(goproAddress, GoProUUID.WIFI_AP_PASSWORD.uuid) At this point a pairing popup should occur on the Android Device. Select “Allow Pairing” to continue. Here is an example log output from this process: Discovering characteristics Discovered 9 services for F7:5B:5D:81:64:1B Service 00001801-0000-1000-8000-00805f9b34fb Characteristics: |-- Service 00001800-0000-1000-8000-00805f9b34fb Characteristics: |--00002a00-0000-1000-8000-00805f9b34fb: READABLE |--00002a01-0000-1000-8000-00805f9b34fb: READABLE |--00002a04-0000-1000-8000-00805f9b34fb: READABLE Service 0000180f-0000-1000-8000-00805f9b34fb Characteristics: |--00002a19-0000-1000-8000-00805f9b34fb: READABLE, NOTIFIABLE |------00002902-0000-1000-8000-00805f9b34fb: EMPTY Service 0000180a-0000-1000-8000-00805f9b34fb Characteristics: |--00002a29-0000-1000-8000-00805f9b34fb: READABLE |--00002a24-0000-1000-8000-00805f9b34fb: READABLE |--00002a25-0000-1000-8000-00805f9b34fb: READABLE |--00002a27-0000-1000-8000-00805f9b34fb: READABLE |--00002a26-0000-1000-8000-00805f9b34fb: READABLE |--00002a28-0000-1000-8000-00805f9b34fb: READABLE |--00002a23-0000-1000-8000-00805f9b34fb: READABLE |--00002a50-0000-1000-8000-00805f9b34fb: READABLE Service b5f90001-aa8d-11e3-9046-0002a5d5c51b Characteristics: |--b5f90002-aa8d-11e3-9046-0002a5d5c51b: READABLE, WRITABLE |--b5f90003-aa8d-11e3-9046-0002a5d5c51b: READABLE, WRITABLE |--b5f90004-aa8d-11e3-9046-0002a5d5c51b: WRITABLE |--b5f90005-aa8d-11e3-9046-0002a5d5c51b: READABLE, INDICATABLE |------00002902-0000-1000-8000-00805f9b34fb: EMPTY |--b5f90006-aa8d-11e3-9046-0002a5d5c51b: READABLE Service 0000fea6-0000-1000-8000-00805f9b34fb Characteristics: |--b5f90072-aa8d-11e3-9046-0002a5d5c51b: WRITABLE |--b5f90073-aa8d-11e3-9046-0002a5d5c51b: NOTIFIABLE |------00002902-0000-1000-8000-00805f9b34fb: EMPTY |--b5f90074-aa8d-11e3-9046-0002a5d5c51b: WRITABLE |--b5f90075-aa8d-11e3-9046-0002a5d5c51b: NOTIFIABLE |------00002902-0000-1000-8000-00805f9b34fb: EMPTY |--b5f90076-aa8d-11e3-9046-0002a5d5c51b: WRITABLE |--b5f90077-aa8d-11e3-9046-0002a5d5c51b: NOTIFIABLE |------00002902-0000-1000-8000-00805f9b34fb: EMPTY |--b5f90078-aa8d-11e3-9046-0002a5d5c51b: WRITABLE |--b5f90079-aa8d-11e3-9046-0002a5d5c51b: NOTIFIABLE |------00002902-0000-1000-8000-00805f9b34fb: EMPTY Service b5f90090-aa8d-11e3-9046-0002a5d5c51b Characteristics: |--b5f90091-aa8d-11e3-9046-0002a5d5c51b: WRITABLE |--b5f90092-aa8d-11e3-9046-0002a5d5c51b: NOTIFIABLE |------00002902-0000-1000-8000-00805f9b34fb: EMPTY Service b5f90080-aa8d-11e3-9046-0002a5d5c51b Characteristics: |--b5f90081-aa8d-11e3-9046-0002a5d5c51b: NOTIFIABLE |------00002902-0000-1000-8000-00805f9b34fb: EMPTY |--b5f90082-aa8d-11e3-9046-0002a5d5c51b: WRITABLE |--b5f90083-aa8d-11e3-9046-0002a5d5c51b: NOTIFIABLE |------00002902-0000-1000-8000-00805f9b34fb: EMPTY |--b5f90084-aa8d-11e3-9046-0002a5d5c51b: NOTIFIABLE |------00002902-0000-1000-8000-00805f9b34fb: EMPTY Service 00001804-0000-1000-8000-00805f9b34fb Characteristics: |--00002a07-0000-1000-8000-00805f9b34fb: READABLE Pairing Read characteristic b5f90003-aa8d-11e3-9046-0002a5d5c51b : value: 66:3F:54:2D:38:35:72:2D:4E:35:63 Once paired, the camera should beep and display “Connection Successful”. This pairing process only needs to be done once. On subsequent connections, the devices will automatically re-establish encryption using stored keys. That is, they are “bonded.” Enable Notifications As specified in the Open GoPro Bluetooth API, we must enable notifications for a given characteristic to receive responses from it. To enable notifications, we loop over each characteristic in each service and enable the characteristic for notification if it has notify properties: python kotlin It is necessary to define a notification handler to pass to the bleak start_notify method. Since we only care about connecting to the device in this tutorial (and not actually receiving data), we are just passing an empty function. A future tutorial will demonstrate how to use this meaningfully. for service in client.services: for char in service.characteristics: if \"notify\" in char.properties: await client.start_notify(char, notification_handler) In the following example output, we can see that notifications are enabled for each characteristic that is notifiable. INFO:root:Enabling notifications... INFO:root:Enabling notification on char 00002a19-0000-1000-8000-00805f9b34fb INFO:root:Enabling notification on char b5f90073-aa8d-11e3-9046-0002a5d5c51b INFO:root:Enabling notification on char b5f90075-aa8d-11e3-9046-0002a5d5c51b INFO:root:Enabling notification on char b5f90077-aa8d-11e3-9046-0002a5d5c51b INFO:root:Enabling notification on char b5f90079-aa8d-11e3-9046-0002a5d5c51b INFO:root:Enabling notification on char b5f90092-aa8d-11e3-9046-0002a5d5c51b INFO:root:Enabling notification on char b5f90081-aa8d-11e3-9046-0002a5d5c51b INFO:root:Enabling notification on char b5f90083-aa8d-11e3-9046-0002a5d5c51b INFO:root:Enabling notification on char b5f90084-aa8d-11e3-9046-0002a5d5c51b INFO:root:Done enabling notifications ble.servicesOf(goproAddress).onSuccess { services -&gt; services.forEach { service -&gt; service.characteristics.forEach { char -&gt; if (char.isNotifiable()) { ble.enableNotification(goproAddress, char.uuid) } } } } Here is an example log output from this process: Enabling notifications Enabling notifications for 00002a19-0000-1000-8000-00805f9b34fb Wrote to descriptor 00002902-0000-1000-8000-00805f9b34fb Enabling notifications for b5f90073-aa8d-11e3-9046-0002a5d5c51b Wrote to descriptor 00002902-0000-1000-8000-00805f9b34fb Enabling notifications for b5f90075-aa8d-11e3-9046-0002a5d5c51b Wrote to descriptor 00002902-0000-1000-8000-00805f9b34fb Enabling notifications for b5f90077-aa8d-11e3-9046-0002a5d5c51b Wrote to descriptor 00002902-0000-1000-8000-00805f9b34fb Enabling notifications for b5f90079-aa8d-11e3-9046-0002a5d5c51b Wrote to descriptor 00002902-0000-1000-8000-00805f9b34fb Enabling notifications for b5f90092-aa8d-11e3-9046-0002a5d5c51b Wrote to descriptor 00002902-0000-1000-8000-00805f9b34fb Enabling notifications for b5f90081-aa8d-11e3-9046-0002a5d5c51b Wrote to descriptor 00002902-0000-1000-8000-00805f9b34fb Enabling notifications for b5f90083-aa8d-11e3-9046-0002a5d5c51b Wrote to descriptor 00002902-0000-1000-8000-00805f9b34fb Enabling notifications for b5f90084-aa8d-11e3-9046-0002a5d5c51b Wrote to descriptor 00002902-0000-1000-8000-00805f9b34fb Bluetooth is ready for communication! The characteristics that correspond to each UUID listed in the log can be found in the Open GoPro API. These will be used in a future tutorial to send data. Once the notifications are enabled, the GoPro BLE initialization is complete and it is ready to communicate via BLE. Quiz time! 📚 ✏️ How often is it necessary to pair? A: Pairing must occur every time to ensure safe BLE communication. B: We never need to pair as the GoPro does not require it to communicate. C: Pairing only needs to occur once as the keys will be automatically re-used for future connections. Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is C. Pairing is only needed once (assuming neither side deletes the keys). If the GoPro deletes the keys (via Connections-&gt;Reset Connections), the devices will need to re-pair. Troubleshooting Device not connecting If the connection is not starting, it is likely because the camera is not advertising. This can be due to either: The camera is not in pairing mode. Ensure that this is achieved as done in the advertise section. The devices never disconnected from the previous session so are thus already connected. If this is the case, perform the “Complete System Reset” shown below. Complete System Reset BLE is a fickle beast. If at any point it is impossible to discover or connect to the camera, perform the following. Reset the camera by choosing Connections –&gt; Reset Connections Use your OS’s bluetooth settings GUI to remove / unpair the Gopro Restart the procedure detailed above Logs python kotlin The demo program has enabled bleak logs and is also using the default python logging module to write its own logs. To enable more bleak logs, follow bleak’s troubleshooting section. The demo program is using Timber. It is piping all log messages to the UI but they are also available in the logcat window and can be filtered using: package:mine tag:GP_. Good Job! Congratulations 🤙 You can now successfully connect to the GoPro via BLE and prepare it to receive / send data. To see how to send commands, you should advance to the next tutorial.",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/tutorials/connect-ble#"
        },
        {
            "title": "Tutorial 2: Send BLE Commands: ",
            "excerpt": "This document will provide a walk-through tutorial to use the Open GoPro BLE Interface to send commands and receive responses. “Commands” in this sense are specifically procedures that are initiated by either: Writing to the Command Request UUID and receiving responses via the Command Response UUID. They are listed here. Writing to the Setting UUID and receiving responses via the Setting Response UUID. They are listed here. It is suggested that you have first completed the connect tutorial before going through this tutorial. This tutorial only considers sending these commands as one-off commands. That is, it does not consider state management / synchronization when sending multiple commands. This will be discussed in a future lab. Requirements It is assumed that the hardware and software requirements from the connect tutorial are present and configured correctly. Just Show me the Demo(s)!! python kotlin Each of the scripts for this tutorial can be found in the Tutorial 2 directory. Python &gt;= 3.8.x must be used as specified in the requirements Set Shutter You can test sending the Set Shutter command to your camera through BLE using the following script: $ python ble_command_set_shutter.py See the help for parameter definitions: $ python ble_command_set_shutter.py --help usage: ble_command_set_shutter.py [-h] [-i IDENTIFIER] Connect to a GoPro camera, set the shutter on, wait 2 seconds, then set the shutter off. optional arguments: -h, --help show this help message and exit -i IDENTIFIER, --identifier IDENTIFIER Last 4 digits of GoPro serial number, which is the last 4 digits of the default camera SSID. If not used, first discovered GoPro will be connected to Load Preset Group You can test sending the Load Preset Group command to your camera through BLE using the following script: $ python ble_command_load_group.py See the help for parameter definitions: $ python ble_command_load_group.py --help usage: ble_command_load_group.py [-h] [-i IDENTIFIER] Connect to a GoPro camera, then change the Preset Group to Video. optional arguments: -h, --help show this help message and exit -i IDENTIFIER, --identifier IDENTIFIER Last 4 digits of GoPro serial number, which is the last 4 digits of the default camera SSID. If not used, first discovered GoPro will be connected to Set the Video Resolution You can test sending the Set Video Resolution command to your camera through BLE using the following script: $ python ble_command_set_resolution.py See the help for parameter definitions: $ python ble_command_set_resolution.py --help usage: ble_command_set_resolution.py [-h] [-i IDENTIFIER] Connect to a GoPro camera, then change the resolution to 1080. optional arguments: -h, --help show this help message and exit -i IDENTIFIER, --identifier IDENTIFIER Last 4 digits of GoPro serial number, which is the last 4 digits of the default camera SSID. If not used, first discovered GoPro will be connected to Set the Frames Per Second (FPS) You can test sending the Set FPS command to your camera through BLE using the following script: $ python ble_command_set_fps.py See the help for parameter definitions: $ python ble_command_set_fps.py --help usage: ble_command_set_fps.py [-h] [-i IDENTIFIER] Connect to a GoPro camera, then attempt to change the fps to 240. optional arguments: -h, --help show this help message and exit -i IDENTIFIER, --identifier IDENTIFIER Last 4 digits of GoPro serial number, which is the last 4 digits of the default camera SSID. If not used, first discovered GoPro will be connected to The Kotlin file for this tutorial can be found on Github. To perform the tutorial, run the Android Studio project, select “Tutorial 2” from the dropdown and click on “Perform.” This requires that a GoPro is already connected via BLE, i.e. that Tutorial 1 was already run. You can check the BLE status at the top of the app. Perform Tutorial 2 This will start the tutorial and log to the screen as it executes. When the tutorial is complete, click “Exit Tutorial” to return to the Tutorial selection screen. Setup We must first connect as was discussed in the connect tutorial. In this case, however, we are defining a meaningful (albeit naive) notification handler that will: print byte data and handle that the notification was received on check if the response is what we expected set an event to notify the writer that the response was received This is a very simple handler; response parsing will be expanded upon in the next tutorial. python kotlin def notification_handler(handle: int, data: bytes) -&gt; None: logger.info(f'Received response at {handle=}: {hexlify(data, \":\")!r}') If this is the correct handle and the status is success, the command was a success if client.services.characteristics[handle].uuid == response_uuid and data[2] == 0x00: logger.info(\"Command sent successfully\") Anything else is unexpected. This shouldn't happen else: logger.error(\"Unexpected response\") Notify the writer event.set() The event used above is a simple synchronization event that is only alerting the writer that a notification was received. For now, we’re just checking that the handle matches what is expected and that the status (third byte) is success (0x00). private val receivedData: Channel&lt;UByteArray&gt; = Channel() private fun naiveNotificationHandler(characteristic: UUID, data: UByteArray) { if ((characteristic == GoProUUID.CQ_COMMAND_RSP.uuid)) { CoroutineScope(Dispatchers.IO).launch { receivedData.send(data) } } } private val bleListeners by lazy { BleEventListener().apply { onNotification = ::naiveNotificationHandler } } The handler is simply verifying that the response was received on the correct UIUD and then notifying the received data. We are registering this notification handler with the BLE API before sending any data requests as such: ble.registerListener(goproAddress, bleListeners) There is much more to the synchronization and data parsing than this but this will be discussed in future tutorials. Command Overview Both Command Requests and Setting Requests follow the same procedure: Write to relevant request UUID Receive confirmation from GoPro (via notification from relevant response UUID) that request was received. GoPro reacts to command The notification response only indicates that the request was received and whether it was accepted or rejected. The relevant behavior of the GoPro must be observed to verify when the command’s effects have been applied. Here is the procedure from power-on to finish: Open GoPro user deviceGoProdevices are connected as in Tutorial 1Command Request (Write to Request UUID)Command Response (via notification to Response UUID)Apply effects of command when ableOpen GoPro user deviceGoPro Sending Commands Now that we are are connected, paired, and have enabled notifications (registered to our defined callback), we can send some commands. First, we need to define the attributes to write to / receive responses from, which are: For commands “Command Request” characteristic (UUID b5f90072-aa8d-11e3-9046-0002a5d5c51b) “Command Response” characteristic (UUID b5f90073-aa8d-11e3-9046-0002a5d5c51b) For settings “Settings” characteristic (UUID b5f90074-aa8d-11e3-9046-0002a5d5c51b) “Settings Response” (UUID b5f90075-aa8d-11e3-9046-0002a5d5c51b) python kotlin COMMAND_REQ_UUID = GOPRO_BASE_UUID.format(\"0072\") COMMAND_RSP_UUID = GOPRO_BASE_UUID.format(\"0073\") SETTINGS_REQ_UUID = GOPRO_BASE_UUID.format(\"0074\") SETTINGS_RSP_UUID = GOPRO_BASE_UUID.format(\"0075\") We’re using the GOPRO_BASE_UUID string imported from the module’s __init__.py to build these. These are defined in the GoProUUID class: const val GOPRO_UUID = \"0000FEA6-0000-1000-8000-00805f9b34fb\" const val GOPRO_BASE_UUID = \"b5f9%s-aa8d-11e3-9046-0002a5d5c51b\" enum class GoProUUID(val uuid: UUID) { WIFI_AP_PASSWORD(UUID.fromString(GOPRO_BASE_UUID.format(\"0003\"))), WIFI_AP_SSID(UUID.fromString(GOPRO_BASE_UUID.format(\"0002\"))), CQ_COMMAND(UUID.fromString(GOPRO_BASE_UUID.format(\"0072\"))), CQ_COMMAND_RSP(UUID.fromString(GOPRO_BASE_UUID.format(\"0073\"))), CQ_SETTING(UUID.fromString(GOPRO_BASE_UUID.format(\"0074\"))), CQ_SETTING_RSP(UUID.fromString(GOPRO_BASE_UUID.format(\"0075\"))), CQ_QUERY(UUID.fromString(GOPRO_BASE_UUID.format(\"0076\"))), CQ_QUERY_RSP(UUID.fromString(GOPRO_BASE_UUID.format(\"0077\"))); } Set Shutter The first command we will be sending is Set Shutter, which at byte level is: Command Bytes Set Shutter Off 0x03 0x01 0x01 0x00 Set Shutter On 0x03 0x01 0x01 0x01 Now, let’s write the bytes to the “Command Request” UUID to turn the shutter on and start encoding! python kotlin event.clear() await client.write_gatt_char(COMMAND_REQ_UUID, bytearray([3, 1, 1, 1])) await event.wait() Wait to receive the notification response We make sure to clear the synchronization event before writing, then pend on the event until it is set in the notification callback. val setShutterOnCmd = ubyteArrayOf(0x03U, 0x01U, 0x01U, 0x01U) ble.writeCharacteristic(goproAddress, GoProUUID.CQ_COMMAND.uuid, setShutterOnCmd) // Wait to receive the notification response, then check its status checkStatus(receivedData.receive()) You should hear the camera beep and it will either take a picture or start recording depending on what mode it is in. Also note that we have received the “Command Status” notification response from the Command Response characteristic since we enabled its notifications in Enable Notifications. This can be seen in the demo log: python kotlin INFO:root:Setting the shutter on INFO:root:Received response at handle=52: b'02:01:00' INFO:root:Shutter command sent successfully Writing characteristic b5f90072-aa8d-11e3-9046-0002a5d5c51b ==&gt; 03:01:01:01 Wrote characteristic b5f90072-aa8d-11e3-9046-0002a5d5c51b Characteristic b5f90073-aa8d-11e3-9046-0002a5d5c51b changed | value: 02:01:00 Received response on b5f90073-aa8d-11e3-9046-0002a5d5c51b: 02:01:00 Command sent successfully As expected, the response was received on the correct handle and the status was “success”. If you are recording a video, continue reading to set the shutter off. We can now set the shutter off: We’re waiting 2 seconds in case you are in video mode so that we can capture a 2 second video. python kotlin time.sleep(2) event.clear() await client.write_gatt_char(COMMAND_REQ_UUID, bytearray([3, 1, 1, 0])) await event.wait() Wait to receive the notification response This will log in the console as follows: INFO:root:Setting the shutter off INFO:root:Received response at handle=52: b'02:01:00' INFO:root:Shutter command sent successfully delay(2000) val setShutterOffCmd = ubyteArrayOf(0x03U, 0x01U, 0x01U, 0x00U) // Wait to receive the notification response, then check its status checkStatus(receivedData.receive()) This will log as such: Setting the shutter off Writing characteristic b5f90072-aa8d-11e3-9046-0002a5d5c51b ==&gt; 03:01:01:00 Wrote characteristic b5f90072-aa8d-11e3-9046-0002a5d5c51b Characteristic b5f90073-aa8d-11e3-9046-0002a5d5c51b changed | value: 02:01:00 Received response on b5f90073-aa8d-11e3-9046-0002a5d5c51b: 02:01:00 Command sent successfully Load Preset Group The next command we will be sending is Load Preset Group, which is used to toggle between the 3 groups of presets (video, photo, and timelapse). At byte level, the commands are: Command Bytes Load Video Preset Group 0x04 0x3E 0x02 0x03 0xE8 Load Photo Preset Group 0x04 0x3E 0x02 0x03 0xE9 Load Timelapse Preset Group 0x04 0x3E 0x02 0x03 0xEA It is possible that the preset GroupID values will vary in future cameras. The only absolutely correct way to know the preset ID is to read them from the “Get Preset Status” protobuf command. A future lab will discuss protobuf commands. Now, let’s write the bytes to the “Command Request” UUID to change the preset group to Video! python kotlin event.clear() await client.write_gatt_char(COMMAND_REQ_UUID, bytearray([0x04, 0x3E, 0x02, 0x03, 0xE8])) await event.wait() Wait to receive the notification response We make sure to clear the synchronization event before writing, then pend on the event until it is set in the notification callback. val loadPreset = ubyteArrayOf(0x04U, 0x3EU, 0x02U, 0x03U, 0xE8U) ble.writeCharacteristic(goproAddress, GoProUUID.CQ_COMMAND.uuid, loadPreset) // Wait to receive the notification response, then check its status checkStatus(receivedData.receive()) You should hear the camera beep and move to the Video Preset Group. You can tell this by the logo at the top middle of the screen: Load Preset Group Also note that we have received the “Command Status” notification response from the Command Response characteristic since we enabled its notifications in Enable Notifications. This can be seen in the demo log: python kotlin INFO:root:Loading the video preset group... INFO:root:Received response at handle=52: b'02:3e:00' INFO:root:Command sent successfully Loading Video Preset Group Writing characteristic b5f90072-aa8d-11e3-9046-0002a5d5c51b ==&gt; 04:3E:02:03:E8 Wrote characteristic b5f90072-aa8d-11e3-9046-0002a5d5c51b Characteristic b5f90073-aa8d-11e3-9046-0002a5d5c51b changed | value: 02:3E:00 Received response on b5f90073-aa8d-11e3-9046-0002a5d5c51b: 02:3E:00 Command status received Command sent successfully As expected, the response was received on the correct handle and the status was “success”. Set the Video Resolution The next command we will be sending is Set Video Resolution. This is used to change the value of the Video Resolution setting. It is important to note that this only affects video resolution (not photo). Therefore, the Video Preset Group must be active in order for it to succeed. This can be done either manually through the camera UI or by sending Load Preset Group. This resolution only affects the current video preset. Each video preset can have its own independent values for video resolution. Here are some of the byte level commands for various video resolutions. Command Bytes Set Video Resolution to 1080 0x03 0x02 0x01 0x09 Set Video Resolution to 2.7K 0x03 0x02 0x01 0x04 Set Video Resolution to 5K 0x03 0x02 0x01 0x18 Now, let’s write the bytes to the “Setting Request” UUID to change the video resolution to 1080! python kotlin event.clear() await client.write_gatt_char(SETTINGS_REQ_UUID, bytearray([0x03, 0x02, 0x01, 0x09])) await event.wait() Wait to receive the notification response We make sure to clear the synchronization event before writing, then pend on the event until it is set in the notification callback. val setResolution = ubyteArrayOf(0x03U, 0x02U, 0x01U, 0x09U) ble.writeCharacteristic(goproAddress, GoProUUID.CQ_COMMAND.uuid, setResolution) // Wait to receive the notification response, then check its status checkStatus(receivedData.receive()) You should see the video resolution change to 1080 in the pill in the bottom-middle of the screen: Set Video Resolution Also note that we have received the “Command Status” notification response from the Command Response characteristic since we enabled its notifications in Enable Notifications.. This can be seen in the demo log: python kotlin INFO:root:Loading the video preset group... INFO:root:Received response at handle=52: b'02:3e:00' INFO:root:Command sent successfully Setting resolution to 1080 Writing characteristic b5f90072-aa8d-11e3-9046-0002a5d5c51b ==&gt; 03:02:01:09 Wrote characteristic b5f90072-aa8d-11e3-9046-0002a5d5c51b Characteristic b5f90073-aa8d-11e3-9046-0002a5d5c51b changed | value: 02:02:00 Received response on b5f90073-aa8d-11e3-9046-0002a5d5c51b: 02:02:00 Command status received Command sent successfully As expected, the response was received on the correct handle and the status was “success”. If the Preset Group was not Video, the status will not be success. Set the Frames Per Second (FPS) The next command we will be sending is Set FPS. This is used to change the value of the FPS setting. It is important to note that this setting is dependent on the video resolution. That is, certain FPS values are not valid with certain resolutions. In general, higher resolutions only allow lower FPS values. Also, the current anti-flicker value may further limit possible FPS values. Check the camera capabilities to see which FPS values are valid for given use cases. Therefore, for this step of the tutorial, it is assumed that the resolution has been set to 1080 as in Set the Video Resolution. Here are some of the byte level commands for various FPS values. Command Bytes Set FPS to 24 0x03 0x03 0x01 0x0A Set FPS to 60 0x03 0x03 0x01 0x05 Set FPS to 240 0x03 0x03 0x01 0x00 Note that the possible FPS values can vary based on the Open GoPro version that the camera supports. Therefore, it is necessary to check the version. Now, let’s write the bytes to the “Setting Request” UUID to change the FPS to 240! python kotlin event.clear() await client.write_gatt_char(SETTINGS_REQ_UUID, bytearray([0x03, 0x03, 0x01, 0x00])) await event.wait() Wait to receive the notification response We make sure to clear the synchronization event before writing, then pend on the event until it is set in the notification callback. val setFps = ubyteArrayOf(0x03U, 0x03U, 0x01U, 0x00U) ble.writeCharacteristic(goproAddress, GoProUUID.CQ_COMMAND.uuid, setFps) // Wait to receive the notification response, then check its status checkStatus(receivedData.receive()) You should see the FPS change to 240 in the pill in the bottom-middle of the screen: Set FPS Also note that we have received the “Command Status” notification response from the Command Response characteristic since we enabled its notifications in Enable Notifications.. This can be seen in the demo log: python kotlin INFO:root:Setting the fps to 240 INFO:root:Received response at handle=57: b'02:03:00' INFO:root:Command sent successfully Setting the FPS to 240 Writing characteristic b5f90072-aa8d-11e3-9046-0002a5d5c51b ==&gt; 03:03:01:00 Wrote characteristic b5f90072-aa8d-11e3-9046-0002a5d5c51b Characteristic b5f90073-aa8d-11e3-9046-0002a5d5c51b changed | value: 02:03:00 Received response on b5f90073-aa8d-11e3-9046-0002a5d5c51b: 02:03:00 Command status received Command sent successfully As expected, the response was received on the correct handle and the status was “success”. If the video resolution was higher, for example 5K, this would fail. Quiz time! 📚 ✏️ Which of the following is not a real preset group? A: Timelapse B: Photo C: Burst D: Video Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is C. There are 3 preset groups (Timelapse, Photo, and Video). These can be set via the Load Preset Group command. True or False: Every combination of resolution and FPS value is valid. A: True B: False Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is B. Each resolution can support all or only some FPS values. You can find out which resolutions support which fps values by consulting the capabilities section of the spec. True or False: Every camera supports the same combination of resolution and FPS values. A: True B: False Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is B. The only way to know what values are supported is to first check the Open GoPro version. See the relevant version of the BLE or WiFi spec to see what is supported. Troubleshooting See the first tutorial’s troubleshooting section. Good Job! Congratulations 🤙 You can now send any of the other BLE commands detailed in the Open GoPro documentation in a similar manner. To see how to parse more complicate responses, proceed to the next tutorial.",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/tutorials/send-ble-commands#"
        },
        {
            "title": "Tutorial 3: Parse BLE TLV Responses: ",
            "excerpt": "This document will provide a walk-through tutorial to implement the Open GoPro Interface to parse BLE Type-Length-Value (TLV) Responses. Besides TLV, some BLE commands instead return protobuf responses. These are not considered here and will be discussed in a future tutorial. It is suggested that you have first completed the connect and sending commands tutorials before going through this tutorial. This tutorial will give an overview of types of responses, then give examples of parsing each type before finally providing a Response class that will be used in future tutorials. Requirements It is assumed that the hardware and software requirements from the connect tutorial are present and configured correctly. Just Show me the Demo(s)!! python kotlin Each of the scripts for this tutorial can be found in the Tutorial 2 directory. Python &gt;= 3.8.x must be used as specified in the requirements Parsing a One Packet TLV Response You can test parsing a one packet TLV response with your camera through BLE using the following script: $ python ble_command_get_version.py See the help for parameter definitions: $ python ble_command_get_version.py --help usage: ble_command_get_version.py [-h] [-i IDENTIFIER] Connect to a GoPro camera via BLE, then get the Open GoPro version. optional arguments: -h, --help show this help message and exit -i IDENTIFIER, --identifier IDENTIFIER Last 4 digits of GoPro serial number, which is the last 4 digits of the default camera SSID. If not used, first discovered GoPro will be connected to Parsing Multiple Packet TLV Responses You can test parsing multiple packet TVL responses with your camera through BLE using the following script: $ python ble_command_get_state.py See the help for parameter definitions: $ python ble_command_get_state.py --help usage: ble_command_get_state.py [-h] [-i IDENTIFIER] Connect to a GoPro camera via BLE, then get its statuses and settings. optional arguments: -h, --help show this help message and exit -i IDENTIFIER, --identifier IDENTIFIER Last 4 digits of GoPro serial number, which is the last 4 digits of the default camera SSID. If not used, first discovered GoPro will be connected to The Kotlin file for this tutorial can be found on Github. To perform the tutorial, run the Android Studio project, select “Tutorial 3” from the dropdown and click on “Perform.” This requires that a GoPro is already connected via BLE, i.e. that Tutorial 1 was already run. You can check the BLE status at the top of the app. Perform Tutorial 3 This will start the tutorial and log to the screen as it executes. When the tutorial is complete, click “Exit Tutorial” to return to the Tutorial selection screen. Setup We must first connect as was discussed in the connect tutorial. When enabling notifications, one of the notification handlers described in the following sections will be used. Response Overview In the preceding tutorials, we have been using a very simple response handling procedure where the notification handler simply checks that the UUID is the expected UUID and that the status byte of the response is 0 (Success). This has been fine since we were only sending specific commands where this works and we know that the sequence always appears as such (connection sequence left out for brevity): Open GoPro user deviceGoProdevices are connected as in Tutorial 1Write to characteristicNotification Response (MSB == 0 (start))Open GoPro user deviceGoPro In actuality, responses can be more complicated. As described in the Open GoPro Interface, responses can be be comprised of multiple packets where each packet is &lt;= 20 bytes such as: Open GoPro user deviceGoProdevices are connected as in Tutorial 1Write to characteristicNotification Response (MSB == 0 (start))Notification Response (MSB == 1 (continuation))Notification Response (MSB == 1 (continuation))Notification Response (MSB == 1 (continuation))Open GoPro user deviceGoPro This requires the implementation of accumulating and parsing algorithms which will be described in [Parsing Multiple Packet TLV Responses]. Parsing a One Packet TLV Response This section will describe how to parse one packet (&lt;= 20 byte) responses. A one-packet response is formatted as such: Header (length) Command / Setting ID Status Response 1 byte 1 byte 1 bytes Length - 2 bytes Command / Setting Responses with Response Length 0 These are the only responses that we have seen thus far through the first 2 tutorials. They return a status but have a 0 length additional response. For example, consider Set Shutter. It returned a response of: 02:01:00 This equates to: Header (length) Command / Setting / Status ID Status Response 1 byte 1 byte 1 bytes Length - 2 bytes 0x02 0x01 == Set Shutter 0x00 == Success (2 -2 = 0 bytes) We can see how this response includes the status but no additional response data. This type of response will be used for most Commands and Setting Responses as seen in the previous tutorial. Complex Command Response There are some commands that do return additional response data. These are called “complex responses.” From the commands reference, we can see that these are: Get Open GoPro Version (ID == 0x51) Get Hardware Info (ID == 0x3C) In this tutorial, we will walk through creating a simple parser to parse the Open GoPro Get Version Command. It is important to always query the version after connecting in order to know which API is supported. See the relevant version of the BLE and / or WiFi spec for more details about each version. First, we send the command to the Command Request UUID: python kotlin COMMAND_REQ_UUID = GOPRO_BASE_UUID.format(\"0072\") event.clear() await client.write_gatt_char(COMMAND_REQ_UUID, bytearray([0x01, 0x51])) await event.wait() Wait to receive the notification response We then receive a response at the expected handle. This is logged as: INFO:root:Getting the Open GoPro version... INFO:root:Received response at handle=52: b'06:51:00:01:02:01:00' val getVersion = ubyteArrayOf(0x01U, 0x51U) ble.writeCharacteristic(goproAddress, GoProUUID.CQ_COMMAND.uuid, getVersion) val version = receivedResponse.receive() as Response.Complex // Wait to receive response This is loged as such: Getting the Open GoPro version Writing characteristic b5f90072-aa8d-11e3-9046-0002a5d5c51b ==&gt; 01:51 Wrote characteristic b5f90072-aa8d-11e3-9046-0002a5d5c51b Characteristic b5f90073-aa8d-11e3-9046-0002a5d5c51b changed | value: 06:51:00:01:02:01:00 Received response on b5f90073-aa8d-11e3-9046-0002a5d5c51b: 06:51:00:01:02:01:00 This response equates to: Header (length) Command / Setting / Status ID Status Response 1 byte 1 byte 1 bytes Length - 2 bytes 0x06 0x51 == Get Version 0x00 == Success 0x01 0x02 0x01 0x00 We can see that this “complex response” contains 4 additional bytes that need to be parsed. Using the information from the interface description, we know to parse this as: Byte Meaning 0x01 Length of Major Version Number 0x02 Major Version Number 0x01 Length of Minor Version Number 0x00 Minor Version Number We implement this in the notification handler as follows. First, we parse the length, command ID, and status from the first 3 bytes of the response. Then we parse the remaining four bytes of the response as individual values formatted as such: Length Value 1 byte Length bytes python kotlin The snippets of code included in this section are taken from the notification handler Parse first 3 bytes len = data[0] command_id = data[1] status = data[2] Parse remaining four bytes index = 3 params = [] while index &lt;= len: param_len = data[index] index += 1 params.append(data[index : index + param_len]) index += param_len The snippets of code included in this section are taken from the Response.Complex parse method. For the contrived code in this tutorial, we have separate Response sealed classes to handle each use case. // Parse header bytes id = packet[0].toInt() status = packet[1].toInt() var buf = packet.drop(2) // Parse remaining packet while (buf.isNotEmpty()) { // Get each parameter's ID and length val paramLen = buf[0].toInt() buf = buf.drop(1) // Get the parameter's value val paramVal = buf.take(paramLen) // Store in data list data += paramVal.toUByteArray() // Advance the buffer for continued parsing buf = buf.drop(paramLen) } From the complex response definition, we know these parameters are one byte each and equate to the major and the minor version so let’s print them (and all of the other response information) as such: python kotlin major, minor = params logger.info(f\"Received a response to {command_id=} with {status=}: version={major[0]}.{minor[0]}\") which shows on the log as: INFO:root:Received a response to command_id=81 with status=0: version=2.0 val version = receivedResponse.receive() as Response.Complex // Wait to receive response val major = version.data[0].first().toInt() val minor = version.data[1].first().toInt() Timber.i(\"Got the Open GoPro version successfully: $major.$minor\") which shows on the log as such: Got the Open GoPro version successfully: 2.0 Quiz time! 📚 ✏️ What is the maximum size of an individual notification response packet? A: 20 bytes B: 256 bytes C: There is no maximum size Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is A. Responses can be composed of multiple packets where each packet is at maximum 20 bytes. What is the maximum amount of packets that one response can be composed of? A: 20 bytes B: 256 bytes C: There is no maximum size Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is C. There is no limit on the amount of packets that can comprise a response. What is the maximum amount of packets that one response can be composed of? A: Always 1 packet B: Always multiple packets. C: Always 1 packet except for complex responses. Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is C. Command responses are almost always 1 packet (just returning the status). The exception are complex responses which can be multiple packets (in the case of Get Hardware Info) How many packets are setting responses comprised of? A: Always 1 packet B: Always multiple packets. C: Always 1 packet except for complex responses. Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is A. Settings Responses only ever contain the command status. Furthermore, there is no concept of complex responses for setting commands. Parsing Multiple Packet TLV Responses This section will describe parsing TLV responses that contain more than one packet. It will first describe how to accumulate such responses and then provide a parsing example. The example script that will be walked through for this section is ble_command_get_state.py. We will be creating a small Response class that will be re-used for future tutorials. Accumulating the Response The first step is to accumulate the multiple packets into one response. Whereas for all tutorials until now, we have just used the header bytes of the response as the length, we now must completely parse the header as it is defined: Byte 1 Byte 2 (optional) Byte 3 (optional) 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 0: Start 00: General Message Length: 5 bits 0: Start 01: Extended (13-bit) Message Length: 13 bits 0: Start 10: Extended (16-bit) Message Length: 16 bits 0: Start 11: Reserved 1: Continuation The basic algorithm here (which is implemented in the Message.accumulate method) is as follows: Continuation bit set? python kotlin if buf[0] &amp; CONT_MASK: buf.pop(0) else: ... if (data.first().and(Mask.Continuation.value) == Mask.Continuation.value) { buf = buf.drop(1).toUByteArray() // Pop the header byte } else { // This is a new packet ... No, continuation bit was not set. So create new response, then get its length. python kotlin This is a new packet so start with an empty byte array self.bytes = bytearray() hdr = Header((buf[0] &amp; HDR_MASK) &gt;&gt; 5) if hdr is Header.GENERAL: self.bytes_remaining = buf[0] &amp; GEN_LEN_MASK buf = buf[1:] elif hdr is Header.EXT_13: self.bytes_remaining = ((buf[0] &amp; EXT_13_BYTE0_MASK) &lt;&lt; 8) + buf[1] buf = buf[2:] elif hdr is Header.EXT_16: self.bytes_remaining = (buf[1] &lt;&lt; 8) + buf[2] buf = buf[3:] // This is a new packet so start with empty array packet = ubyteArrayOf() when (Header.fromValue((buf.first() and Mask.Header.value).toInt() shr 5)) { Header.GENERAL -&gt; { bytesRemaining = buf[0].and(Mask.GenLength.value).toInt() buf = buf.drop(1).toUByteArray() } Header.EXT_13 -&gt; { bytesRemaining = ((buf[0].and(Mask.Ext13Byte0.value) .toLong() shl 8) or buf[1].toLong()).toInt() buf = buf.drop(2).toUByteArray() } Header.EXT_16 -&gt; { bytesRemaining = ((buf[1].toLong() shl 8) or buf[2].toLong()).toInt() buf = buf.drop(3).toUByteArray() } Header.RESERVED -&gt; { throw Exception(\"Unexpected RESERVED header\") } } Append current packet to response and decrement bytes remaining. python kotlin Append payload to buffer and update remaining / complete self.bytes.extend(buf) self.bytes_remaining -= len(buf) // Accumulate the payload now that headers are handled and dropped packet += buf bytesRemaining -= buf.size In the notification handler, we are then parsing if there are no bytes remaining. python kotlin if response.is_received: response.parse() rsp.accumulate(data) if (rsp.isReceived) { rsp.parse() ... NoYesDecrement bytes remainingYesNoRead Available PacketContinuation bit set?Create new empty responseGet bytes remaining, i.e. lengthAppend packet to accumulating responseBytes remaining == 0?Parse Received Packet We can see this in action when we send the Get All Setting Values Query. Queries aren’t introduced until the next tutorial so for now, just pay attention to the response. We send the command as such: python kotlin QUERY_REQ_UUID = GOPRO_BASE_UUID.format(\"0076\") event.clear() await client.write_gatt_char(QUERY_REQ_UUID, bytearray([0x01, 0x12])) await event.wait() Wait to receive the notification response val getCameraSettings = ubyteArrayOf(0x01U, 0x12U) ble.writeCharacteristic(goproAddress, GoProUUID.CQ_QUERY.uuid, getCameraSettings) val settings = receivedResponse.receive() Then, in the notification handler, we continuously receive and accumulate packets until we have received the entire response, at which point we notify the writer that the response is ready: python kotlin def notification_handler(handle: int, data: bytes) -&gt; None: response.accumulate(data) if response.is_received: response.parse() Notify writer that procedure is complete event.set() private fun tlvResponseNotificationHandler(characteristic: UUID, data: UByteArray) { ... rsp.accumulate(data) if (rsp.isReceived) { rsp.parse() // Notify the command sender the the procedure is complete response = null // Clear for next command CoroutineScope(Dispatchers.IO).launch { receivedResponse.send(rsp) } } We also first parse the response but that will be described in the next section. We can see the individual packets being accumulated in the log: python kotlin INFO:root:Getting the camera's settings... INFO:root:Received response at handle=62: b'21:25:12:00:02:01:09:03:01:01:05:0 INFO:root:self.bytes_remaining=275 INFO:root:Received response at handle=62: b'80:01:00:18:01:00:1e:04:00:00:00:0 INFO:root:self.bytes_remaining=256 INFO:root:Received response at handle=62: b'81:0a:25:01:00:29:01:09:2a:01:05:2 INFO:root:self.bytes_remaining=237 INFO:root:Received response at handle=62: b'82:2f:01:04:30:01:03:36:01:00:3b:0 INFO:root:self.bytes_remaining=218 INFO:root:Received response at handle=62: b'83:04:00:00:00:00:3e:04:00:00:00:0 INFO:root:self.bytes_remaining=199 INFO:root:Received response at handle=62: b'84:00:42:04:00:00:00:00:43:04:00:0 INFO:root:self.bytes_remaining=180 INFO:root:Received response at handle=62: b'85:4f:01:00:53:01:00:54:01:00:55:0 INFO:root:self.bytes_remaining=161 INFO:root:Received response at handle=62: b'86:01:28:5b:01:02:60:01:00:66:01:0 INFO:root:self.bytes_remaining=142 INFO:root:Received response at handle=62: b'87:00:6a:01:00:6f:01:0a:70:01:ff:7 INFO:root:self.bytes_remaining=123 INFO:root:Received response at handle=62: b'88:75:01:00:76:01:04:79:01:00:7a:0 INFO:root:self.bytes_remaining=104 INFO:root:Received response at handle=62: b'89:01:00:7e:01:00:80:01:0c:81:01:0 INFO:root:self.bytes_remaining=85 INFO:root:Received response at handle=62: b'8a:0c:85:01:09:86:01:00:87:01:01:8 INFO:root:self.bytes_remaining=66 INFO:root:Received response at handle=62: b'8b:92:01:00:93:01:00:94:01:02:95:0 INFO:root:self.bytes_remaining=47 INFO:root:Received response at handle=62: b'8c:01:00:9c:01:00:9d:01:00:9e:01:0 INFO:root:self.bytes_remaining=28 INFO:root:Received response at handle=62: b'8d:00:a2:01:00:a3:01:01:a4:01:00:a INFO:root:self.bytes_remaining=9 INFO:root:Received response at handle=62: b'8e:a8:04:00:00:00:00:a9:01:01' INFO:root:self.bytes_remaining=0 INFO:root:Successfully received the response Writing characteristic b5f90076-aa8d-11e3-9046-0002a5d5c51b ==&gt; 01:12 Wrote characteristic b5f90076-aa8d-11e3-9046-0002a5d5c51b Characteristic b5f90077-aa8d-11e3-9046-0002a5d5c51b changed | value: 21:2B:12:00:02:01:04:03:01:05:05:01:00:06:01:01:0D:01:01:13 Received response on b5f90077-aa8d-11e3-9046-0002a5d5c51b: 21:2B:12:00:02:01:04:03:01:05:05:01:00:06:01:01:0D:01:01:13 Received packet of length 18. 281 bytes remaining Characteristic b5f90077-aa8d-11e3-9046-0002a5d5c51b changed | value: 80:01:00:18:01:00:1E:04:00:00:00:6E:1F:01:00:20:04:00:00:00 Received response on b5f90077-aa8d-11e3-9046-0002a5d5c51b: 80:01:00:18:01:00:1E:04:00:00:00:6E:1F:01:00:20:04:00:00:00 Received packet of length 19. 262 bytes remaining Characteristic b5f90077-aa8d-11e3-9046-0002a5d5c51b changed | value: 81:0A:25:01:00:29:01:09:2A:01:08:2B:01:00:2C:01:09:2D:01:08 Received response on b5f90077-aa8d-11e3-9046-0002a5d5c51b: 81:0A:25:01:00:29:01:09:2A:01:08:2B:01:00:2C:01:09:2D:01:08 Received packet of length 19. 243 bytes remaining Characteristic b5f90077-aa8d-11e3-9046-0002a5d5c51b changed | value: 82:2F:01:07:36:01:01:3B:01:04:3C:04:00:00:00:00:3D:04:00:00 Received response on b5f90077-aa8d-11e3-9046-0002a5d5c51b: 82:2F:01:07:36:01:01:3B:01:04:3C:04:00:00:00:00:3D:04:00:00 Received packet of length 19. 224 bytes remaining Characteristic b5f90077-aa8d-11e3-9046-0002a5d5c51b changed | value: 83:00:00:3E:04:00:12:4F:80:40:01:04:41:04:00:00:00:00:42:04 Received response on b5f90077-aa8d-11e3-9046-0002a5d5c51b: 83:00:00:3E:04:00:12:4F:80:40:01:04:41:04:00:00:00:00:42:04 Received packet of length 19. 205 bytes remaining Characteristic b5f90077-aa8d-11e3-9046-0002a5d5c51b changed | value: 84:00:00:00:00:43:04:00:12:4F:80:4B:01:00:4C:01:00:53:01:01 Received response on b5f90077-aa8d-11e3-9046-0002a5d5c51b: 84:00:00:00:00:43:04:00:12:4F:80:4B:01:00:4C:01:00:53:01:01 Received packet of length 19. 186 bytes remaining Characteristic b5f90077-aa8d-11e3-9046-0002a5d5c51b changed | value: 85:54:01:00:55:01:00:56:01:00:57:01:00:58:01:32:5B:01:03:66 Received response on b5f90077-aa8d-11e3-9046-0002a5d5c51b: 85:54:01:00:55:01:00:56:01:00:57:01:00:58:01:32:5B:01:03:66 Received packet of length 19. 167 bytes remaining Characteristic b5f90077-aa8d-11e3-9046-0002a5d5c51b changed | value: 86:01:08:67:01:03:69:01:00:6F:01:0A:70:01:64:72:01:01:73:01 Received response on b5f90077-aa8d-11e3-9046-0002a5d5c51b: 86:01:08:67:01:03:69:01:00:6F:01:0A:70:01:64:72:01:01:73:01 Received packet of length 19. 148 bytes remaining Characteristic b5f90077-aa8d-11e3-9046-0002a5d5c51b changed | value: 87:00:74:01:02:75:01:01:76:01:04:79:01:03:7A:01:65:7B:01:65 Received response on b5f90077-aa8d-11e3-9046-0002a5d5c51b: 87:00:74:01:02:75:01:01:76:01:04:79:01:03:7A:01:65:7B:01:65 Received packet of length 19. 129 bytes remaining Characteristic b5f90077-aa8d-11e3-9046-0002a5d5c51b changed | value: 88:7C:01:64:7D:01:00:7E:01:00:80:01:0D:81:01:02:82:01:69:83 Received response on b5f90077-aa8d-11e3-9046-0002a5d5c51b: 88:7C:01:64:7D:01:00:7E:01:00:80:01:0D:81:01:02:82:01:69:83 Received packet of length 19. 110 bytes remaining Characteristic b5f90077-aa8d-11e3-9046-0002a5d5c51b changed | value: 89:01:03:84:01:0C:86:01:02:87:01:01:8B:01:03:90:01:0C:91:01 Received response on b5f90077-aa8d-11e3-9046-0002a5d5c51b: 89:01:03:84:01:0C:86:01:02:87:01:01:8B:01:03:90:01:0C:91:01 Received packet of length 19. 91 bytes remaining Characteristic b5f90077-aa8d-11e3-9046-0002a5d5c51b changed | value: 8A:00:92:01:00:93:01:00:94:01:01:95:01:02:96:01:00:97:01:00 Received response on b5f90077-aa8d-11e3-9046-0002a5d5c51b: 8A:00:92:01:00:93:01:00:94:01:01:95:01:02:96:01:00:97:01:00 Received packet of length 19. 72 bytes remaining Characteristic b5f90077-aa8d-11e3-9046-0002a5d5c51b changed | value: 8B:99:01:64:9A:01:02:9B:01:64:9C:01:64:9D:01:64:9E:01:01:9F Received response on b5f90077-aa8d-11e3-9046-0002a5d5c51b: 8B:99:01:64:9A:01:02:9B:01:64:9C:01:64:9D:01:64:9E:01:01:9F Received packet of length 19. 53 bytes remaining Characteristic b5f90077-aa8d-11e3-9046-0002a5d5c51b changed | value: 8C:01:01:A0:01:00:A1:01:64:A2:01:00:A3:01:01:A4:01:64:A7:01 Received response on b5f90077-aa8d-11e3-9046-0002a5d5c51b: 8C:01:01:A0:01:00:A1:01:64:A2:01:00:A3:01:01:A4:01:64:A7:01 Received packet of length 19. 34 bytes remaining Characteristic b5f90077-aa8d-11e3-9046-0002a5d5c51b changed | value: 8D:04:A8:04:00:00:00:00:A9:01:01:AE:01:00:AF:01:01:B0:01:03 Received response on b5f90077-aa8d-11e3-9046-0002a5d5c51b: 8D:04:A8:04:00:00:00:00:A9:01:01:AE:01:00:AF:01:01:B0:01:03 Received packet of length 19. 15 bytes remaining Characteristic b5f90077-aa8d-11e3-9046-0002a5d5c51b changed | value: 8E:B1:01:00:B2:01:01:B3:01:03:B4:01:00:B5:01:00 Received response on b5f90077-aa8d-11e3-9046-0002a5d5c51b: 8E:B1:01:00:B2:01:01:B3:01:03:B4:01:00:B5:01:00 Received packet of length 15. 0 bytes remaining Received the expected successful response Got the camera's settings successfully At this point the response has been accumulated. See the next section for how to parse it. Quiz time! 📚 ✏️ How can we know that a response has been completely received? A: The stop bit will be set in the header B: The response has accumulated length bytes C: By checking for the end of frame (EOF) sentinel character Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is B. The length of the entire response is parsed from the first packet. We then accumulate packets, keeping track of the received length, until all of the bytes have been received. A and C are just made up 😜. Parsing a Query Response This section is going to describe responses to to BLE status / setting queries. We don’t actually introduce such queries until the next tutorial so for now, only the parsing of the response is important. While multi-packet responses are almost always Query Responses, they can also be from Command Complex responses. In a real-world implementation, it is therefore necessary to check the received UUID to see how to parse. Query Responses contain one or more TLV groups in their Response data. To recap, the generic response format is: Header (length) Query ID Status Response 1-2 bytes 1 byte 1 bytes Length - 2 bytes This means that query responses will contain an array of additional TLV groups in the “Response” field as such: ID1 Length1 Value1 ID2 Length2 Value 2 … IDN LengthN ValueN 1 byte 1 byte Length1 bytes 1 byte 1 byte Length2 bytes … 1 byte 1 byte LengthN bytes Depending on the amount of query results in the response, this response can be one or multiple packets. Therefore, we need to account for the possibility that it may always be more than 1 packet. We can see an example of such parsing in the response parse method as shown below: We have already parsed the length when we were accumulating the packet. So the next step is to parse the Query ID and Status: python kotlin self.id = self.bytes[0] self.status = self.bytes[1] id = packet[0].toInt() status = packet[1].toInt() We then continuously parse Type (ID) - Length - Value groups until we have consumed the response. We are storing each value in a hash map indexed by ID for later access. python kotlin buf = self.bytes[2:] while len(buf) &gt; 0: Get ID and Length param_id = buf[0] param_len = buf[1] buf = buf[2:] Get the value value = buf[:param_len] Store in dict for later access self.data[param_id] = value Advance the buffer buf = buf[param_len:] while (buf.isNotEmpty()) { // Get each parameter's ID and length val paramId = buf[0] val paramLen = buf[1].toInt() buf = buf.drop(2) // Get the parameter's value val paramVal = buf.take(paramLen) // Store in data dict for access later data[paramId] = paramVal.toUByteArray() // Advance the buffer for continued parsing buf = buf.drop(paramLen) } yesnoParse Query IDParse StatusMore data?Get Value IDGet Value LengthGet Valuedone In the tutorial demo, we then log this entire dict after parsing is complete as such (abbreviated for brevity): python kotlin INFO:root:Received settings : { \"2\": \"09\", \"3\": \"01\", \"5\": \"00\", \"6\": \"01\", \"13\": \"01\", \"19\": \"00\", \"30\": \"00:00:00:00\", \"31\": \"00\", \"32\": \"00:00:00:0a\", \"41\": \"09\", \"42\": \"05\", \"43\": \"00\", ... \"160\": \"00\", \"161\": \"00\", \"162\": \"00\", \"163\": \"01\", \"164\": \"00\", \"165\": \"00\", \"166\": \"00\", \"167\": \"04\", \"168\": \"00:00:00:00\", \"169\": \"01\" } { \"2\": \"09\", \"3\": \"01\", \"5\": \"00\", \"6\": \"01\", \"13\": \"01\", \"19\": \"00\", \"24\": \"00\", \"30\": \"00:00:00:6E\", \"31\": \"00\", \"32\": \"00:00:00:0A\", \"37\": \"00\", \"41\": \"09\", \"42\": \"08\", \"43\": \"00\", \"44\": \"09\", \"45\": \"08\", \"47\": \"07\", ... \"115\": \"00\", \"116\": \"02\", \"117\": \"01\", \"151\": \"00\", \"153\": \"64\", \"154\": \"02\", \"155\": \"64\", \"156\": \"64\", \"157\": \"64\", \"158\": \"01\", \"159\": \"01\", \"160\": \"00\", \"161\": \"64\", \"162\": \"00\", \"163\": \"01\", \"164\": \"64\", \"167\": \"04\", \"168\": \"00:00:00:00\", \"169\": \"01\", \"174\": \"00\", \"175\": \"01\", \"176\": \"03\", \"177\": \"00\", \"178\": \"01\", \"179\": \"03\", \"180\": \"00\", \"181\": \"00\" } We can see what each of these values mean by looking at the Open GoPro Interface. For example: ID 2 == 9 equates to Resolution == 1080 ID 3 == 1 equates to FPS == 120 How many packets are query responses? A: Always 1 packet B: Always multiple packets C: Always 1 packet except for complex responses D: Can be 1 or multiple packets Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is D. Query responses can be one packet (if for example querying a specific setting) or multiple packets (when querying many or all settings as in the example here). See the next tutorial for more information on queries. Which field is not common to all responses? A: length B: status C: ID D: None of the Above Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is D. Query responses can be one packet (if for example querying a specific setting) or multiple packets (when querying many or all settings as in the example here). See the next tutorial for more information on queries. Troubleshooting See the first tutorial’s troubleshooting section. Good Job! Congratulations 🤙 You can now parse any TLV response that is received from the GoPro, at least if it is received uninterrupted. There is additional logic required for a complete solution such as checking the UUID the response is received on and storing a dict of response per UUID. At the current time, this endeavor is left for the reader. For a complete example of this, see the Open GoPro Python SDK. To learn more about queries, go to the next tutorial.",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/tutorials/parse-ble-responses#"
        },
        {
            "title": "Tutorial 4: BLE Queries: ",
            "excerpt": "This document will provide a walk-through tutorial to implement the Open GoPro Interface to query the camera’s setting and status information via BLE. “Queries” in this sense are specifically procedures that: are initiated by writing to the Query UUID receive responses via the Query Response UUID. This will be described in more detail below. It is suggested that you have first completed the connect, sending commands, and parsing responses tutorials before going through this tutorial. This tutorial only considers sending these queries as one-off commands. That is, it does not consider state management / synchronization when sending multiple commands. This will be discussed in a future lab. Requirements It is assumed that the hardware and software requirements from the connect tutorial are present and configured correctly. Just Show me the Demo(s)!! python kotlin Each of the scripts for this tutorial can be found in the Tutorial 2 directory. Python &gt;= 3.8.x must be used as specified in the requirements Individual Query Poll You can test an individual query poll with your camera through BLE using the following script: $ python ble_command_poll_resolution_value.py See the help for parameter definitions: $ python ble_command_poll_resolution_value.py --help usage: ble_command_poll_resolution_value.py [-h] [-i IDENTIFIER] Connect to a GoPro camera, get the current resolution, modify the resolution, and confirm the change was successful. optional arguments: -h, --help show this help message and exit -i IDENTIFIER, --identifier IDENTIFIER Last 4 digits of GoPro serial number, which is the last 4 digits of the default camera SSID. If not used, first discovered GoPro will be connected to Multiple Simultaneous Query Polls You can test querying multiple queries simultaneously with your camera through BLE using the following script: $ python ble_command_poll_multiple_setting_values.py See the help for parameter definitions: $ python ble_command_poll_multiple_setting_values.py --help usage: ble_command_poll_multiple_setting_values.py [-h] [-i IDENTIFIER] Connect to a GoPro camera then get the current resolution, fps, and fov. optional arguments: -h, --help show this help message and exit -i IDENTIFIER, --identifier IDENTIFIER Last 4 digits of GoPro serial number, which is the last 4 digits of the default camera SSID. If not used, first discovered GoPro will be connected to Registering for Query Push Notifications You can test registering for querties and receiving push notifications with your camera through BLE using the following script: $ python ble_command_register_resolution_value_updates.py See the help for parameter definitions: $ python ble_command_register_resolution_value_updates.py --help usage: ble_command_register_resolution_value_updates.py [-h] [-i IDENTIFIER] Connect to a GoPro camera, register for updates to the resolution, receive the current resolution, modify the resolution, and confirm receipt of the change notification. optional arguments: -h, --help show this help message and exit -i IDENTIFIER, --identifier IDENTIFIER Last 4 digits of GoPro serial number, which is the last 4 digits of the default camera SSID. If not used, first discovered GoPro will be connected to The Kotlin file for this tutorial can be found on Github. To perform the tutorial, run the Android Studio project, select “Tutorial 4” from the dropdown and click on “Perform.” This requires that a GoPro is already connected via BLE, i.e. that Tutorial 1 was already run. You can check the BLE status at the top of the app. Perform Tutorial 4 This will start the tutorial and log to the screen as it executes. When the tutorial is complete, click “Exit Tutorial” to return to the Tutorial selection screen. Setup We must first connect as was discussed in the connect tutorial. We will also be using the Response class that was defined in the parsing responses tutorial to accumulate and parse notification responses to the Query Response characteristic. Throughout this tutorial, the query information that we will be reading is the Resolution Setting (ID 0x02). python kotlin Therefore, we have slightly changed the notification handler to update a global resolution variable as it queries the resolution: def notification_handler(handle: int, data: bytes) -&gt; None: response.accumulate(data) if response.is_received: response.parse() if client.services.characteristics[handle].uuid == QUERY_RSP_UUID: resolution = Resolution(response.data[RESOLUTION_ID][0]) Notify writer that the procedure is complete event.set() Therefore, we have slightly updated the notification handler to only handle query responses: fun resolutionPollingNotificationHandler(characteristic: UUID, data: UByteArray) { GoProUUID.fromUuid(characteristic)?.let { // If response is currently empty, create a new one response = response ?: Response.Query() // We're only handling queries in this tutorial } ?: return // We don't care about non-GoPro characteristics (i.e. the BT Core Battery service) Timber.d(\"Received response on $characteristic: ${data.toHexString()}\") response?.let { rsp -&gt; rsp.accumulate(data) if (rsp.isReceived) { rsp.parse() // If this is a query response, it must contain a resolution value if (characteristic == GoProUUID.CQ_QUERY_RSP.uuid) { Timber.i(\"Received resolution query response\") } ... We are also defining a resolution enum that will be updated as we receive new resolutions: private enum class Resolution(val value: UByte) { RES_4K(1U), RES_2_7K(4U), RES_2_7K_4_3(6U), RES_1080(9U), RES_4K_4_3(18U), RES_5K(24U); companion object { private val valueMap: Map&lt;UByte, Resolution&gt; by lazy { values().associateBy { it.value } } fun fromValue(value: UByte) = valueMap.getValue(value) } } private lateinit var resolution: Resolution There are two methods to query status / setting information, each of which will be described in a following section: Polling Query Information Registering for query push notifications Polling Query Information It is possible to poll one or more setting / status values using the following commands: Query ID Request Query 0x12 Get Setting value(s) len:12:xx:xx 0x13 Get Status value(s) len:13:xx:xx where xx are setting / status ID(s) and len is the length of the rest of the query (the number of query bytes plus one for the request ID byte). There will be specific examples below. Since they are two separate commands, combination of settings / statuses can not be polled simultaneously. Here is a generic sequence diagram (the same is true for statuses): Open GoPro user deviceGoProConnected (steps from connect tutorial)Get Setting value(s) command written to Query UUIDSetting values responded to Query Response UUIDMore setting values responded to Query Response UUID...More setting values responded to Query Response UUIDOpen GoPro user deviceGoPro The number of notification responses will vary depending on the amount of settings that have been queried. Note that setting values will be combined into one notification until it reaches the maximum notification size (20 bytes). At this point, a new response will be sent. Therefore, it is necessary to accumulate and then parse these responses as was described in parsing query responses Individual Query Poll Here we will walk through an example of polling one setting (Resolution). First we send the query command: python kotlin The sample code can be found in in ble_query_poll_resolution_value.py. Let’s first define the UUID’s to write to and receive from: QUERY_REQ_UUID = GOPRO_BASE_UUID.format(\"0076\") QUERY_RSP_UUID = GOPRO_BASE_UUID.format(\"0077\") Then actually send the command: event.clear() await client.write_gatt_char(QUERY_REQ_UUID, bytearray([0x02, 0x12, RESOLUTION_ID])) await event.wait() Wait to receive the notification response val pollResolution = ubyteArrayOf(0x02U, 0x12U, RESOLUTION_ID) ble.writeCharacteristic(goproAddress, GoProUUID.CQ_QUERY.uuid, pollResolution) When the response is received in / from the notification handler, we update the global resolution variable: python kotlin def notification_handler(handle: int, data: bytes) -&gt; None: response.accumulate(data) Notify the writer if we have received the entire response if response.is_received: response.parse() If this is query response, it must contain a resolution value if client.services.characteristics[handle].uuid == QUERY_RSP_UUID: resolution = Resolution(response.data[RESOLUTION_ID][0]) which logs as such: INFO:root:Getting the current resolution INFO:root:Received response at handle=62: b'05:12:00:02:01:09' INFO:root:self.bytes_remaining=0 INFO:root:Resolution is currently Resolution.RES_1080 // Wait to receive the response and then convert it to resolution resolution = Resolution.fromValue( receivedResponse.receive().data.getValue(RESOLUTION_ID).first() ) which logs as such: Polling the current resolution Writing characteristic b5f90076-aa8d-11e3-9046-0002a5d5c51b ==&gt; 02:12:02 Wrote characteristic b5f90076-aa8d-11e3-9046-0002a5d5c51b Characteristic b5f90077-aa8d-11e3-9046-0002a5d5c51b changed | value: 05:12:00:02:01:04 Received response on b5f90077-aa8d-11e3-9046-0002a5d5c51b: 05:12:00:02:01:04 Received packet of length 5. 0 bytes remaining Received resolution query response Camera resolution is RES_2_7K For verification purposes, we are then changing the resolution and polling again to verify that the setting has changed: python kotlin INFO:root:Changing the resolution to Resolution.RES_2_7K... INFO:root:Received response at handle=57: b'02:02:00' INFO:root:self.bytes_remaining=0 INFO:root:Command sent successfully INFO:root:Polling the resolution to see if it has changed... INFO:root:Received response at handle=62: b'05:12:00:02:01:07' INFO:root:self.bytes_remaining=0 INFO:root:Resolution is currently Resolution.RES_2_7K while (resolution != newResolution) { ble.writeCharacteristic(goproAddress, GoProUUID.CQ_QUERY.uuid, pollResolution) resolution = Resolution.fromValue( receivedResponse.receive().data.getValue(RESOLUTION_ID).first() ) Timber.i(\"Camera resolution is currently $resolution\") } which logs as such: Changing the resolution to RES_1080 Writing characteristic b5f90074-aa8d-11e3-9046-0002a5d5c51b ==&gt; 03:02:01:09 Wrote characteristic b5f90074-aa8d-11e3-9046-0002a5d5c51b Characteristic b5f90075-aa8d-11e3-9046-0002a5d5c51b changed | value: 02:02:00 Received response on b5f90075-aa8d-11e3-9046-0002a5d5c51b: 02:02:00 Command sent successfully Resolution successfully changed Polling the resolution until it changes Writing characteristic b5f90076-aa8d-11e3-9046-0002a5d5c51b ==&gt; 02:12:02 Characteristic b5f90077-aa8d-11e3-9046-0002a5d5c51b changed | value: 05:12:00:02:01:09 Received response on b5f90077-aa8d-11e3-9046-0002a5d5c51b: 05:12:00:02:01:09 Received resolution query response Wrote characteristic b5f90076-aa8d-11e3-9046-0002a5d5c51b Camera resolution is currently RES_1080 Multiple Simultaneous Query Polls Rather than just polling one setting, it is also possible to poll multiple settings. An example of this is shown below. It is very similar to the previous example except for the following: The query command now includes 3 settings: Resolution, FPS, and FOV. python kotlin RESOLUTION_ID = 2 FPS_ID = 3 FOV_ID = 121 await client.write_gatt_char(QUERY_REQ_UUID, bytearray([0x04, 0x12, RESOLUTION_ID, FPS_ID, FOV_ID])) TODO The length (first byte of the command) has been increased to 4 to accommodate the extra settings We are also parsing the response to get all 3 values: python kotlin def notification_handler(handle: int, data: bytes) -&gt; None: response.accumulate(data) if response.is_received: response.parse() if client.services.characteristics[handle].uuid == QUERY_RSP_UUID: resolution = Resolution(response.data[RESOLUTION_ID][0]) fps = FPS(response.data[FPS_ID][0]) video_fov = VideoFOV(response.data[FOV_ID][0]) TODO When we are storing the updated setting, we are just taking the first byte (i..e index 0). A real-world implementation would need to know the length (and type) of the setting / status response by the ID. For example, sometimes settings / statuses are bytes, words, strings, etc. They are then printed to the log which will look like the following: python kotlin INFO:root:Received response at handle=62: b'0b:12:00:02:01:07:03:01:01:79:01:00' INFO:root:self.bytes_remaining=0 INFO:root:Resolution is currently Resolution.RES_2_7K INFO:root:Video FOV is currently VideoFOV.FOV_WIDE INFO:root:FPS is currently FPS.FPS_120 TODO Query All It is also possible to query all settings / statuses by not passing any ID’s into the the query command, i.e.: Query ID Request Query 0x12 Get All Settings 01:12 0x13 Get All Statuses 01:13 An example of this can be seen in the parsing query responses tutorial Quiz time! 📚 ✏️ How can we poll the encoding status and the resolution setting using one command? A: Concatenate a &8216;Get Setting Value&8217; command and a &8216;Get Status&8217; command with the relevant ID&8217;s B: Concatenate the &8216;Get All Setting&8217; and &8216;Get All Status&8217; commands. C: It is not possible Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is C. It is not possible to concatenate commands. This would result in an unknown sequence of bytes from the camera&8217;s perspective. So it is not possible to get a setting value and a status value in one command. The Get Setting command (with resolution ID) and Get Status command(with encoding ID) must be sent sequentially in order to get this information. Registering for Query Push Notifications Rather than polling the query information, it is also possible to use an interrupt scheme to register for push notifications when the relevant query information changes. The relevant commands are: Query ID Request Query 0x52 Register updates for setting(s) len:52:xx:xx 0x53 Register updates for status(es) len:53:xx:xx 0x72 Unregister updates for setting(s) len:72:xx:xx 0x73 Unregister updates for status(es) len:73:xx:xx where xx are setting / status ID(s) and len is the length of the rest of the query (the number of query bytes plus one for the request ID byte). The Query ID’s for push notification responses are as follows: Query ID Response 0x92 Setting Value Push Notification 0x93 Status Value Push Notification Here is a generic sequence diagram of how this looks (the same is true for statuses): Open GoPro user deviceGoProConnected (steps from connect tutorial)loop[Setting changes]loop[Settingchanges]Register updates for settingNotification Response and Current Setting ValueSetting changesPush notification of new setting valueUnregister updates for settingNotification ResponseSetting changesOpen GoPro user deviceGoPro That is, after registering for push notifications for a given query, notification responses will continuously be sent whenever the query changes until the client unregisters for push notifications for the given query. The initial response to the Register command also contains the current setting / status value. We will walk through an example of this below: First, let’s register for updates when the resolution setting changes: python kotlin First, let’s define the UUID’s we will be using: SETTINGS_REQ_UUID = GOPRO_BASE_UUID.format(\"0074\") SETTINGS_RSP_UUID = GOPRO_BASE_UUID.format(\"0075\") QUERY_REQ_UUID = GOPRO_BASE_UUID.format(\"0076\") QUERY_RSP_UUID = GOPRO_BASE_UUID.format(\"0077\") Then, let’s send the register BLE message… event.clear() await client.write_gatt_char(QUERY_REQ_UUID, bytearray([0x02, 0x52, RESOLUTION_ID])) await event.wait() Wait to receive the notification response val registerResolutionUpdates = ubyteArrayOf(0x02U, 0x52U, RESOLUTION_ID) ble.writeCharacteristic(goproAddress, GoProUUID.CQ_QUERY.uuid, registerResolutionUpdates) and parse its response (which includes the current resolution value). This is very similar to the polling example with the exception that the Query ID is now 0x52 (Register Updates for Settings). This can be seen in the raw byte data as well as by inspecting the response’s id property. python kotlin def notification_handler(handle: int, data: bytes) -&gt; None: logger.info(f'Received response at {handle=}: {hexlify(data, \":\")!r}') response.accumulate(data) Notify the writer if we have received the entire response if response.is_received: response.parse() If this is query response, it must contain a resolution value if client.services.characteristics[handle].uuid == QUERY_RSP_UUID: global resolution resolution = Resolution(response.data[RESOLUTION_ID][0]) This will show in the log as such: INFO:root:Registering for resolution updates INFO:root:Received response at handle=62: b'05:52:00:02:01:07' INFO:root:self.bytes_remaining=0 INFO:root:Successfully registered for resolution value updates. INFO:root:Resolution is currently Resolution.RES_2_7K fun resolutionRegisteringNotificationHandler(characteristic: UUID, data: UByteArray) { ... if (rsp.isReceived) { rsp.parse() if (characteristic == GoProUUID.CQ_QUERY_RSP.uuid) { Timber.i(\"Received resolution query response\") resolution = Resolution.fromValue(rsp.data.getValue(RESOLUTION_ID).first()) Timber.i(\"Resolution is now $resolution\") ... This will show in the log as such: Registering for resolution value updates Writing characteristic b5f90076-aa8d-11e3-9046-0002a5d5c51b ==&gt; 02:52:02 Wrote characteristic b5f90076-aa8d-11e3-9046-0002a5d5c51b We are now successfully registered for resolution value updates and will receive push notifications whenever the resolution changes. We verify this in the demo by then changing the resolution. python kotlin This will show in the log as such: INFO:root:Successfully changed the resolution INFO:root:Received response at handle=62: b'05:92:00:02:01:09' INFO:root:self.bytes_remaining=0 INFO:root:Resolution is now Resolution.RES_1080 val newResolution = if (resolution == Resolution.RES_2_7K) Resolution.RES_1080 else Resolution.RES_2_7K val setResolution = ubyteArrayOf(0x03U, RESOLUTION_ID, 0x01U, newResolution.value) ble.writeCharacteristic(goproAddress, GoProUUID.CQ_SETTING.uuid, setResolution) val setResolutionResponse = receivedResponse.receive() // Verify we receive the update from the camera when the resolution changes while (resolution != newResolution) { receivedResponse.receive() } We can see change happen in the log: Changing the resolution to RES_2_7K Writing characteristic b5f90074-aa8d-11e3-9046-0002a5d5c51b ==&gt; 03:02:01:04 Wrote characteristic b5f90074-aa8d-11e3-9046-0002a5d5c51b Resolution successfully changed Waiting for camera to inform us about the resolution change Characteristic b5f90077-aa8d-11e3-9046-0002a5d5c51b changed | value: 05:92:00:02:01:04 Received response on b5f90077-aa8d-11e3-9046-0002a5d5c51b: 05:92:00:02:01:04 Received resolution query response Resolution is now RES_2_7K In this case, the Query ID is 0x92 (Setting Value Push Notification) as expected. Multiple push notifications can be registered / received in a similar manner that multiple queries were polled above Quiz time! 📚 ✏️ True or False: We can still poll a given query value while we are currently registered to receive push notifications for it. A: True B: False Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is A. While there is probably not a good reason to do so, there is nothing preventing polling in this manner. True or False: A push notification for a registered setting will only ever contain query information about one setting ID. A: True B: False Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is B. It is possible for push notifications to contain multiple setting ID&8217;s if both setting ID&8217;s have push notifications registered and both settings change at the same time. Troubleshooting See the first tutorial’s troubleshooting section. Good Job! Congratulations 🤙 You can now query any of the settings / statuses from the camera using one of the above patterns. If you have been following these tutorials in order, here is an extra 🥇🍾 Congratulations 🍰👍 because you have completed all of the BLE tutorials. Next, to get started with WiFI (specifically to enable and connect to it), proceed to the next tutorial.",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/tutorials/ble-queries#"
        },
        {
            "title": "Tutorial 5: Connect WiFi: ",
            "excerpt": "This document will provide a walk-through tutorial to implement the Open GoPro Interface to enable the GoPro’s WiFi Access Point (AP) so that it can be connected to. It will also provide an example of connecting to the WiFi AP. It is recommended that you have first completed the connecting, sending commands, and parsing responses tutorials before proceeding. Requirements It is assumed that the hardware and software requirements from the connect tutorial are present and configured correctly. The scripts that will be used for this tutorial can be found in the Tutorial 5 Folder. Just Show me the Demo(s)!! python kotlin Each of the scripts for this tutorial can be found in the Tutorial 2 directory. Python &gt;= 3.8.x must be used as specified in the requirements Enable WiFi AP You can test querying the current Resolution on your camera through BLE using the following script: $ python wifi_enable.py See the help for parameter definitions: $ python wifi_enable.py --help usage: wifi_enable.py [-h] [-i IDENTIFIER] [-t TIMEOUT] Connect to a GoPro camera via BLE, get WiFi info, and enable WiFi. optional arguments: -h, --help show this help message and exit -i IDENTIFIER, --identifier IDENTIFIER Last 4 digits of GoPro serial number, which is the last 4 digits of the default camera SSID. If not used, first discovered GoPro will be connected to -t TIMEOUT, --timeout TIMEOUT time in seconds to maintain connection before disconnecting. If not set, will maintain connection indefinitely The Kotlin file for this tutorial can be found on Github. To perform the tutorial, run the Android Studio project, select “Tutorial 5” from the dropdown and click on “Perform.” This requires that a GoPro is already connected via BLE, i.e. that Tutorial 1 was already run. You can check the BLE status at the top of the app. Perform Tutorial 5 This will start the tutorial and log to the screen as it executes. When the tutorial is complete, click “Exit Tutorial” to return to the Tutorial selection screen. Setup We must first connect to BLE as was discussed in the connect tutorial. We are also using the same notification handler as was used in the sending commands tutorial Connecting to WiFi AP Now that we are connected via BLE, paired, and have enabled notifications, we can send the command to enable the WiFi AP. Here is an outline of the steps to do so: Open GoPro user deviceGoProBLEGoProWiFiScanningConnectedalt[If not Previously Paired]PairedReady to Communicateloop[Steps from Connect Tutorial]WiFi AP enabledAdvertisingAdvertisingConnectPair RequestPair ResponseEnable Notifications on Characteristic 1Enable Notifications on Characteristic 2Enable Notifications on Characteristic ..Enable Notifications on Characteristic NRead Wifi AP SSIDRead Wifi AP PasswordWrite to Enable WiFi APResponse sent as notificationConnect to WiFi APOpen GoPro user deviceGoProBLEGoProWiFi Essentially we will be finding the WiFi AP information (SSID and password) via BLE, enabling the WiFi AP via BLE, then connecting to the WiFi AP. Find WiFi Information Note that the process to get this information is different than all procedures described up to this point. Whereas the previous command, setting, and query procedures all followed the Write Request-Notification Response pattern, the WiFi Information is retrieved via direct Read Requests to BLE characteristics. Get WiFi SSID The WiFi SSID can be found by reading from the WiFi AP SSID characteristic of the WiFi Access Point service. First, let’s send the read request to get the SSID (and decode it into a string). python kotlin Let’s define the attribute to read from: WIFI_AP_SSID_UUID = GOPRO_BASE_UUID.format(\"0002\") Then send the BLE read request: ssid = await client.read_gatt_char(WIFI_AP_SSID_UUID) ssid = ssid.decode() There is no need for a synchronization event as the information is available when the read_gatt_char method returns. In the demo, this information is logged as such: INFO:root:Reading the WiFi AP SSID INFO:root:SSID is GP24500456 ble.readCharacteristic(goproAddress, GoProUUID.WIFI_AP_SSID.uuid).onSuccess { ssid = it.decodeToString() } Timber.i(\"SSID is $ssid\") In the demo, this information is logged as such: Getting the SSID Read characteristic b5f90002-aa8d-11e3-9046-0002a5d5c51b : value: 64:65:62:75:67:68:65:72:6F:31:31 SSID is debughero11 Get WiFi Password The WiFi password can be found by reading from the WiFi AP password characteristic of the WiFi Access Point service. First, let’s send the read request to get the password (and decode it into a string). python kotlin Let’s define the attribute to read from: WIFI_AP_PASSWORD_UUID = GOPRO_BASE_UUID.format(\"0003\") Then send the BLE read request: There is no need for a synchronization event as the information is available when the read_gatt_char method returns. In the demo, this information is logged as such: INFO:root:Reading the WiFi AP password INFO:root:Password is g@6-Tj9-C7K ble.readCharacteristic(goproAddress, GoProUUID.WIFI_AP_PASSWORD.uuid).onSuccess { password = it.decodeToString() } Timber.i(\"Password is $password\") In the demo, this information is logged as such: Getting the password Read characteristic b5f90003-aa8d-11e3-9046-0002a5d5c51b : value: 7A:33:79:2D:44:43:58:2D:50:68:6A Password is z3y-DCX-Phj Enable WiFi AP Before we can connect to the WiFi AP, we have to make sure it is enabled. This is accomplished by using the “AP Control” command: Command Bytes Ap Control Enable 0x03 0x17 0x01 0x01 Ap Control Disable 0x03 0x17 0x01 0x00 This is done in the same manner that we did in the sending commands tutorial. Now, let’s write the bytes to the “Command Request UUID” to enable the WiFi AP! python kotlin event.clear() await client.write_gatt_char(COMMAND_REQ_UUID, bytearray([0x03, 0x17, 0x01, 0x01])) await event.wait() Wait to receive the notification response We make sure to clear the synchronization event before writing, then pend on the event until it is set in the notification callback. val enableWifiCommand = ubyteArrayOf(0x03U, 0x17U, 0x01U, 0x01U) ble.writeCharacteristic(goproAddress, GoProUUID.CQ_COMMAND.uuid, enableWifiCommand) receivedData.receive() Note that we have received the “Command Status” notification response from the Command Response characteristic since we enabled it’s notifications in Enable Notifications. This can be seen in the demo log: python kotlin INFO:root:Enabling the WiFi AP INFO:root:Received response at handle=52: b'02:17:00' INFO:root:Command sent successfully INFO:root:WiFi AP is enabled Enabling the camera's Wifi AP Writing characteristic b5f90072-aa8d-11e3-9046-0002a5d5c51b ==&gt; 03:17:01:01 Wrote characteristic b5f90072-aa8d-11e3-9046-0002a5d5c51b Characteristic b5f90073-aa8d-11e3-9046-0002a5d5c51b changed | value: 02:17:00 Received response on b5f90073-aa8d-11e3-9046-0002a5d5c51b: 02:17:00 Command sent successfully As expected, the response was received on the correct handle and the status was “success”. Establish Connection to WiFi AP python kotlin If you have been following through the ble_enable_wifi.py script, you will notice that it ends here such that we know the WiFi SSID and password and the WiFi AP is enabled and ready to connect to. This is because there are many different methods of connecting to the WiFi AP depending on your OS and the framework you are using to develop. You could, for example, simply use your OS’s WiFi GUI to connect. While out of the scope of these tutorials, there is a programmatic example of this in the cross-platform WiFi Demo from the Open GoPro Python SDK. Using the passwsord and SSID we discovered above, we will now connect to the camera’s network: wifi.connect(ssid, password) This should show a system popup on your Android device that eventually goes away once the Wifi is connected. This connection process appears to vary drastically in time. Quiz time! 📚 ✏️ How is the WiFi password response received? A: As a read response from the WiFi AP Password characteristic B: As write responses to the WiFi Request characteristic C: As notifications of the Command Response characteristic Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is A. This (and WiFi AP SSID) is an exception to the rule. Usually responses are received as notifications to a response characteristic. However, in this case, it is received as a direct read response (since we are reading from the characteristic and not writing to it). Which of the following statements about the GoPro WiFi AP is true? A: It only needs to be enabled once and it will then always remain on B: The WiFi password will never change C: The WiFi SSID will never change D: None of the Above Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is D. While the WiFi AP will remain on for some time, it can and will eventually turn off so it is always recommended to first connect via BLE and ensure that it is enabled. The password and SSID will almost never change. However, they will change if the connections are reset via Connections-&gt;Reset Connections. Troubleshooting See the first tutorial’s troubleshooting section. Good Job! Congratulations 🤙 You are now connected to the GoPro’s Wifi AP and can send any of the HTTP commands defined in the Open GoPro Interface. Proceed to the next tutorial.",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/tutorials/connect-wifi#"
        },
        {
            "title": "Tutorial 6: Send WiFi Commands: ",
            "excerpt": "This document will provide a walk-through tutorial to send Open GoPro HTTP commands to the GoPro. It is suggested that you have first completed the Connecting to Wifi tutorial. This tutorial only considers sending these commands as one-off commands. That is, it does not consider state management / synchronization when sending multiple commands. This will be discussed in a future tutorial. There are two types of responses that can be received from the HTTP commands: JSON and binary. This section will deal with commands that return JSON responses. For commands with binary responses (as well as commands with JSON responses that work with the media list), see the next tutorial. Requirements It is assumed that the hardware and software requirements from the connect tutorial are present and configured correctly. The scripts that will be used for this tutorial can be found in the Tutorial 6 Folder. Just Show me the Demo(s)!! python kotlin Each of the scripts for this tutorial can be found in the Tutorial 2 directory. Python &gt;= 3.8.x must be used as specified in the requirements You must be connected to the camera via WiFi as stated in Tutorial 5. Get State You can test querying the state of your camera with HTTP over WiFi using the following script: $ python wifi_command_get_state.py See the help for parameter definitions: $ python wifi_command_get_state.py --help usage: wifi_command_get_state.py [-h] Get the state of the GoPro (status and settings). optional arguments: -h, --help show this help message and exit Preview Stream You can test enabling the UDP preview stream with HTTP over WiFi using the following script: $ python wifi_command_preview_stream.py See the help for parameter definitions: $ python wifi_command_preview_stream.py --help usage: wifi_command_preview_stream.py [-h] Enable the preview stream. optional arguments: -h, --help show this help message and exit Once enabled the stream can be viewed at udp://@:8554 (For more details see the View Stream tab in the Preview Stream section below. Load Preset Group You can test sending the load preset group command with HTTP over WiFi using the following script: $ python wifi_command_load_group.py See the help for parameter definitions: $ python wifi_command_load_group.py --help usage: wifi_command_load_group.py [-h] Load the video preset group. optional arguments: -h, --help show this help message and exit Set Shutter You can test sending the Set Shutter command with HTTP over WiFi using the following script: $ python wifi_command_set_shutter.py See the help for parameter definitions: $ python wifi_command_set_shutter.py --help usage: wifi_command_set_shutter.py [-h] Take a 3 second video. optional arguments: -h, --help show this help message and exit Set Setting You can test setting the resolution setting with HTTP over WiFi using the following script: $ python wifi_command_set_resolution.py See the help for parameter definitions: $ python wifi_command_set_resolution.py --help usage: wifi_command_set_resolution.py [-h] Set the video resolution to 1080. optional arguments: -h, --help show this help message and exit The Kotlin file for this tutorial can be found on Github. To perform the tutorial, run the Android Studio project, select “Tutorial 6” from the dropdown and click on “Perform.” This requires: a GoPro is already connected via BLE, i.e. that Tutorial 1 was already run. a GoPro is already connected via Wifi, i.e. that Tutorial 5 was already run. You can check the BLE and Wifi statuses at the top of the app. Perform Tutorial 6 This will start the tutorial and log to the screen as it executes. When the tutorial is complete, click “Exit Tutorial” to return to the Tutorial selection screen. Setup We must first connect to The GoPro’s WiFi Access Point (AP) as was discussed in the Connecting to Wifi tutorial. Sending HTTP Commands with JSON Responses Now that we are are connected via WiFi, we can communicate via HTTP commands. python kotlin We will use the requests package to send the various HTTP commands. We are building the endpoints using the GOPRO_BASE_URL defined in the tutorial package’s __init__.py We are using ktor for the HTTP client. We are using an abstracted get function from our Wifi class to send get requests as such: private val client by lazy { HttpClient(CIO) { install(HttpTimeout) } } suspend fun get(endpoint: String, timeoutMs: Long = 5000L): JsonObject { Timber.d(\"GET request to: $endpoint\") val response = client.request(endpoint) { timeout { requestTimeoutMillis = timeoutMs } } val bodyAsString: String = response.body() return prettyJson.parseToJsonElement(bodyAsString).jsonObject } Both Command Requests and Setting Requests follow the same procedure: Send HTTP GET command to appropriate endpoint Receive confirmation from GoPro (via HTTP response) that request was received. GoPro reacts to command The HTTP response only indicates that the request was received correctly. The relevant behavior of the GoPro must be observed to verify when the command’s effects have been applied. Open GoPro user deviceGoProPC connected to WiFi APCommand Request (GET)Command Response (HTTP 200 OK)Apply affects of command when ableOpen GoPro user deviceGoPro Get State The first command we will be sending is Get State. This command will return all of the current settings and values. It is basically a combination of the Get All Settings and Get All Statuses commands that were sent via BLE. Since there is no way to query individual settings / statuses via WiFi (or register for asynchronous notifications when they change), this is the only option to query setting / status information via WiFi. The command writes to the following endpoint: /gopro/camera/state Let’s build the endpoint then send the GET request and check the response for errors. Any errors will raise an exception. python kotlin url = GOPRO_BASE_URL + \"/gopro/camera/state\" response = requests.get(url) response.raise_for_status() var response = wifi.get(GOPRO_BASE_URL + \"gopro/camera/state\") Lastly, we print the response’s JSON data: python kotlin logger.info(f\"Response: {json.dumps(response.json(), indent=4)}\") The response will log as such (abbreviated for brevity): INFO:root:Getting GoPro's status and settings: sending http://10.5.5.9:8080/gopro/camera/state INFO:root:Command sent successfully INFO:root:Response: { \"status\": { \"1\": 1, \"2\": 2, \"3\": 0, \"4\": 255, \"6\": 0, \"8\": 0, \"9\": 0, \"10\": 0, \"11\": 0, \"13\": 0, \"14\": 0, \"17\": 1, ... \"settings\": { \"2\": 9, \"3\": 1, \"5\": 0, \"6\": 1, \"13\": 1, \"19\": 0, \"24\": 0, \"30\": 0, \"31\": 0, \"32\": 10, \"41\": 9, \"42\": 5, Timber.i(prettyJson.encodeToString(response)) The response will log as such (abbreviated for brevity): Getting camera state GET request to: http://10.5.5.9:8080/gopro/camera/state { \"status\": { \"1\": 1, \"2\": 4, \"3\": 0, \"4\": 255, \"6\": 0, \"8\": 0, \"9\": 0, \"10\": 0, \"11\": 0, \"13\": 0, ... \"113\": 0, \"114\": 0, \"115\": 0, \"116\": 0, \"117\": 31154688 }, \"settings\": { \"2\": 9, \"3\": 1, \"5\": 0, \"6\": 1, \"13\": 1, ... \"177\": 0, \"178\": 1, \"179\": 3, \"180\": 0, \"181\": 0 } } We can see what each of these values mean by looking at the Open GoPro Interface. For example (for settings): ID 2 == 9 equates to Resolution == 1080 ID 3 == 1 equates to FPS == 120 Load Preset Group The next command we will be sending is Load Preset Group, which is used to toggle between the 3 groups of presets (video, photo, and timelapse). The preset groups ID’s are: Command Bytes Load Video Preset Group 1000 Load Photo Preset Group 1001 Load Timelapse Preset Group 1002 It is possible that the preset GroupID values will vary in future cameras. The only absolutely correct way to know the preset ID is to read them from the “Get Preset Status” protobuf command. A future lab will discuss protobuf commands. python kotlin url = GOPRO_BASE_URL + \"/gopro/camera/presets/set_group?id=1000\" response = requests.get(url) response.raise_for_status() response = wifi.get(GOPRO_BASE_URL + \"gopro/camera/presets/load?id=1000\") Lastly, we print the response’s JSON data: python kotlin logger.info(f\"Response: {json.dumps(response.json(), indent=4)}\") This will log as such: INFO:root:Loading the video preset group: sending http://10.5.5.9:8080/gopro/camera/presets/set_group?id=1000 INFO:root:Command sent successfully INFO:root:Response: {} Timber.i(prettyJson.encodeToString(response)) The response will log as such: Loading Video Preset Group GET request to: http://10.5.5.9:8080/gopro/camera/presets/load?id=1000 { } Lastly, we print the response’s JSON data: The response JSON is empty. This is expected in the case of a success. You should hear the camera beep and switch to the Cinematic Preset (assuming it wasn’t already set). You can verify this by seeing the preset name in the pill at bottom middle of the screen. Load Preset Set Shutter The next command we will be sending is Set Shutter. which is used to start and stop encoding. python kotlin url = GOPRO_BASE_URL + f\"/gopro/camera/shutter/start\" response = requests.get(url) response.raise_for_status() response = wifi.get(GOPRO_BASE_URL + \"gopro/camera/shutter/start\") Lastly, we print the response’s JSON data: This command does not return a JSON response so we don’t print the response This will log as such: python kotlin INFO:root:Turning the shutter on: sending http://10.5.5.9:8080/gopro/camera/shutter/start INFO:root:Command sent successfully Timber.i(prettyJson.encodeToString(response)) The response will log as such: Setting Shutter On GET request to: http://10.5.5.9:8080/gopro/camera/shutter/start { } We can then wait a few seconds and repeat the above procedure to set the shutter off using gopro/camera/shutter/stop. The shutter can not be set on if the camera is encoding or set off if the camera is not encoding. An attempt to do so will result in an error response. Set Setting The next command will be sending is Set Setting. This end point is used to update all of the settings on the camera. It is analogous to BLE commands like Set Video Resolution. It is important to note that many settings are dependent on the video resolution (and other settings). For example, certain FPS values are not valid with certain resolutions. In general, higher resolutions only allow lower FPS values. Check the camera capabilities to see which settings are valid for given use cases. Let’s build the endpoint first to set the Video Resolution to 1080 (the setting_id and option value comes from the command table linked above). python kotlin url = GOPRO_BASE_URL + f\"/gopro/camera/setting?setting=2&amp;option=9\" response = requests.get(url) response.raise_for_status() response = wifi.get(GOPRO_BASE_URL + \"gopro/camera/setting?setting=2&amp;option=9\") Lastly, we print the response’s JSON data: python kotlin logger.info(f\"Response: {json.dumps(response.json(), indent=4)}\") This will log as such: INFO:root:Setting the video resolution to 1080: sending http://10.5.5.9:8080/gopro/camera/setting?setting_id=2&amp;opt_value=9 INFO:root:Command sent successfully INFO:root:Response: {} Timber.i(prettyJson.encodeToString(response)) The response will log as such: Setting Resolution to 1080 GET request to: http://10.5.5.9:8080/gopro/camera/setting?setting=2&amp;option=9 { } The response JSON is empty. This is expected in the case of a success. You should hear the camera beep and see the video resolution change to 1080 in the pill in the bottom-middle of the screen: Video Resolution As a reader exercise, try using the [Get State] command to verify that the resolution has changed. Preview Stream The next command we will be sending is Preview Stream. This command will enable (or disable) the preview stream . It is then possible to view the preview stream from a media player. The commands write to the following endpoints: Command Endpoint start preview stream /gopro/camera/stream/start stop preview stream /gopro/camera/stream/stop Let’s build the endpoint then send the GET request and check the response for errors. Any errors will raise an exception. python kotlin url = GOPRO_BASE_URL + \"/gopro/camera/stream/start\" response = requests.get(url) response.raise_for_status() TODO Lastly, we print the response’s JSON data: python kotlin logger.info(f\"Response: {json.dumps(response.json(), indent=4)}\") This will log as such: INFO:root:Starting the preview stream: sending http://10.5.5.9:8080/gopro/camera/stream/start INFO:root:Command sent successfully INFO:root:Response: {} TODO The response JSON is empty. This is expected in the case of a success. Once enabled, the stream can be viewed at udp://@:8554. Here is an example of viewing this using VLC: The screen may slightly vary depending on your OS Select Media–&gt;Open Network Stream Enter the path as such: Configure Preview Stream Select play The preview stream should now be visible. Quiz time! 📚 ✏️ What is the significance of empty JSON in an HTTP response? A: Always an error! The command was not received correctly. B: If the status is ok (200), this is expected. C: This is expected for errors (code other than 200) but not expected for ok (200). Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is B. It is common for the JSON response to be empty if the command was received successfully but there is no additional information to return at the current time. Which of the of the following is not a real preset group? A: Timelapse B: Photo C: Burst D: Video Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is C. There are 3 preset groups (Timelapse, Photo, and Video). These can be set via the Load Preset Group command. How do you query the current video resolution setting (id = 2) via WiFi? A: Send GET to /gopro/camera/state?setting_id=2 B: Send GET to /gopro/camera/state?get_setting=2 C: Send POST to /gopro/camera/state with request &8216;setting_id=2&8217; D: None of the Above Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is D. You can&8217;t query individual settings or statuses with the HTTP API. In order to get the value of a specific setting you&8217;ll need to send a GET to /gopro/camera/state and parse the value of the desired setting from the JSON response. Troubleshooting HTTP Logging Wireshark can be used to view the HTTP commands and responses between the PC and the GoPro. Start a Wireshark capture on the WiFi adapter that is used to connect to the GoPro Filter for the GoPro IP address (10.5.5.9) Wireshark Good Job! Congratulations 🤙 You can now send any of the HTTP commands defined in the Open GoPro Interface that return JSON responses. You may have noted that we did not discuss one of these (Get Media List) in this tutorial. Proceed to the next tutorial to see how to get and perform operations using the media list.",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/tutorials/send-wifi-commands#"
        },
        {
            "title": "Tutorial 7: Camera Media List: ",
            "excerpt": "This document will provide a walk-through tutorial to send Open GoPro HTTP commands to the GoPro, specifically to get the media list and perform operations on it (downloading pictures, videos, etc.) It is suggested that you have first completed the Connecting to Wifi and Sending WiFi Commands tutorials. This tutorial only considers sending these commands as one-off commands. That is, it does not consider state management / synchronization when sending multiple commands. This will be discussed in a future tutorial. Requirements It is assumed that the hardware and software requirements from the connect tutorial are present and configured correctly. The scripts that will be used for this tutorial can be found in the Tutorial 7 Folder. Just Show me the Demo(s)!! python kotlin Each of the scripts for this tutorial can be found in the Tutorial 2 directory. Python &gt;= 3.8.x must be used as specified in the requirements You must be connected to the camera via WiFi in order to run these scripts. You can do this by manually to the SSID and password listed on your camera or by leaving the Establish Connection to WiFi AP script from Tutorial 5 running in the background. Download Media File You can downloading a file from your camera with HTTP over WiFi using the following script: $ python wifi_media_download_file.py See the help for parameter definitions: $ python wifi_media_download_file.py --help usage: wifi_media_download_file.py [-h] Find a photo on the camera and download it to the computer. optional arguments: -h, --help show this help message and exit Get Media Thumbnail You can downloading the thumbnail for a media file from your camera with HTTP over WiFi using the following script: $ python wifi_media_get_thumbnail.py See the help for parameter definitions: $ python wifi_media_get_thumbnail.py --help usage: wifi_media_get_thumbnail.py [-h] Get the thumbnail for a media file. optional arguments: -h, --help show this help message and exit The Kotlin file for this tutorial can be found on Github. To perform the tutorial, run the Android Studio project, select “Tutorial 7” from the dropdown and click on “Perform.” This requires: a GoPro is already connected via BLE, i.e. that Tutorial 1 was already run. a GoPro is already connected via Wifi, i.e. that Tutorial 5 was already run. You can check the BLE and Wifi statuses at the top of the app. Perform Tutorial 7 This will start the tutorial and log to the screen as it executes. When the tutorial is complete, click “Exit Tutorial” to return to the Tutorial selection screen. Setup We must first connect to The GoPro’s WiFi Access Point (AP) as was discussed in the Connecting to Wifi tutorial. Get Media List Now that we are are connected via WiFi, we will get the media list using the same procedure to send HTTP commands as in the previous tutorial. We get the media list via the Get Media List command. This command will return a JSON structure of all of the media files (pictures, videos) on the camera with corresponding information about each media file. Let’s build the endpoint, send the GET request, and check the response for errors. Any errors will raise an exception. python kotlin url = GOPRO_BASE_URL + \"/gopro/media/list\" response = requests.get(url) response.raise_for_status() val response = wifi.get(GOPRO_BASE_URL + \"gopro/media/list\") Lastly, we print the response’s JSON data: python kotlin logger.info(f\"Response: {json.dumps(response.json(), indent=4)}\") The response will log as such (abbreviated for brevity): INFO:root:Getting the media list: sending http://10.5.5.9:8080/gopro/media/list INFO:root:Command sent successfully INFO:root:Response: { \"id\": \"2510746051348624995\", \"media\": [ { \"d\": \"100GOPRO\", \"fs\": [ { \"n\": \"GOPR0987.JPG\", \"cre\": \"1618583762\", \"mod\": \"1618583762\", \"s\": \"5013927\" }, { \"n\": \"GOPR0988.JPG\", \"cre\": \"1618583764\", \"mod\": \"1618583764\", \"s\": \"5009491\" }, { \"n\": \"GOPR0989.JPG\", \"cre\": \"1618583766\", \"mod\": \"1618583766\", \"s\": \"5031861\" }, { \"n\": \"GX010990.MP4\", \"cre\": \"1451608343\", \"mod\": \"1451608343\", \"glrv\": \"806586\", \"ls\": \"-1\", \"s\": \"10725219\" }, Timber.i(\"Files in media list: ${prettyJson.encodeToString(fileList)}\") The response will log as such (abbreviated for brevity): GET request to: http://10.5.5.9:8080/gopro/media/list Complete media list: { \"id\": \"4386457835676877283\", \"media\": [ { \"d\": \"100GOPRO\", \"fs\": [ { \"n\": \"GOPR0232.JPG\", \"cre\": \"1748997965\", \"mod\": \"1748997965\", \"s\": \"7618898\" }, { \"n\": \"GOPR0233.JPG\", \"cre\": \"1748998273\", \"mod\": \"1748998273\", \"s\": \"7653472\" }, ... { \"n\": \"GX010259.MP4\", \"cre\": \"1677828860\", \"mod\": \"1677828860\", \"glrv\": \"943295\", \"ls\": \"-1\", \"s\": \"9788009\" } ] } ] } The media list format is defined in the Open GoPro Specification. We won’t be rehashing that here but will provide examples below of using the media list. One common functionality is to get the list of media file names, which can be done as such: python kotlin print([x[\"n\"] for x in media_list[\"media\"][0][\"fs\"]]) That is, access the list at the fs tag at the first element of the media tag, then make a list of all of the names (n tag of each element) in the fs list. val fileList = response[\"media\"]?.jsonArray?.first()?.jsonObject?.get(\"fs\")?.jsonArray?.map { mediaEntry -&gt; mediaEntry.jsonObject[\"n\"] }?.map { it.toString().replace(\"\\\"\", \"\") } That is: Access the JSON array at the fs tag at the first element of the media tag Make a list of all of the names (n tag of each element) in the fs list. Map this list to string and remove backslashes 3. Media List Operations Whereas all of the WiFi commands described until now have returned JSON responses, most of the media list operations return binary data. From an HTTP perspective, the behavior is the same. However, the GET response will contain a large binary chunk of information so we will loop through it with the requests library as such, writing up to 8 kB at a time: diskOpen GoPro user deviceGoProPC connected to WiFi APloop[write until complete]Get Media List (GET)Media List (HTTP 200 OK)Command Request (GET)Binary Response (HTTP 200 OK)write &lt;= 8KdiskOpen GoPro user deviceGoPro Download Media File The next command we will be sending is Download Media. Specifically, we will be downloading a photo. The camera must have at least one photo in its media list in order for this to work. First, we get the media list as in Get Media List . Then we search through the list of file names in the media list looking for a photo (i.e. a file whose name ends in .jpg). Once we find a photo, we proceed: python kotlin media_list = get_media_list() photo: Optional[str] = None for media_file in [x[\"n\"] for x in media_list[\"media\"][0][\"fs\"]]: if media_file.lower().endswith(\".jpg\"): logger.info(f\"found a photo: {media_file}\") photo = media_file break val photo = fileList?.firstOrNull { it.endsWith(ignoreCase = true, suffix = \"jpg\") } ?: throw Exception(\"Not able to find a .jpg in the media list\") Timber.i(\"Found a photo: $photo\") Now let’s build the endpoint, send the GET request, and check the response for errors. Any errors will raise an exception. The endpoint will start with “videos” for both photos and videos python kotlin url = GOPRO_BASE_URL + f\"videos/DCIM/100GOPRO/{photo}\" with requests.get(url, stream=True) as request: request.raise_for_status() Lastly, we iterate through the binary content in 8 kB chunks, writing to a local file: file = photo.split(\".\")[0] + \".jpg\" with open(file, \"wb\") as f: logger.info(f\"receiving binary stream to {file}...\") for chunk in request.iter_content(chunk_size=8192): f.write(chunk) return wifi.getFile( GOPRO_BASE_URL + \"videos/DCIM/100GOPRO/$photo\", appContainer.applicationContext ) TODO FIX THIS This will log as such: python kotlin INFO:root:found a photo: GOPR0987.JPG INFO:root:Downloading GOPR0987.JPG INFO:root:Sending: http://10.5.5.9:8080/videos/DCIM/100GOPRO/GOPR0987.JPG INFO:root:receiving binary stream to GOPR0987.jpg... Once complete, the GOPR0987_thumbnail.jpg file will be available from where the demo script was called. Found a photo: GOPR0232.JPG Downloading photo: GOPR0232.JPG... Once complete, the photo will display in the tutorial window. Get Media Thumbnail The next command we will be sending is Get Media thumbnail . Specifically, we will be getting the thumbnail for a photo. The camera must have at least one photo in its media list in order for this to work. There is a separate commandto get a media “screennail” First, we get the media list as in Get Media List . Then we search through the list of file names in the media list looking for a photo (i.e. a file whose name ends in .jpg). Once we find a photo, we proceed: python kotlin media_list = get_media_list() photo: Optional[str] = None for media_file in [x[\"n\"] for x in media_list[\"media\"][0][\"fs\"]]: if media_file.lower().endswith(\".jpg\"): logger.info(f\"found a photo: {media_file}\") photo = media_file break TODO Now let’s build the endpoint, send the GET request, and check the response for errors. Any errors will raise an exception. python kotlin url = GOPRO_BASE_URL + f\"/gopro/media/thumbnail?path=100GOPRO/{photo}\" with requests.get(url, stream=True) as request: request.raise_for_status() Lastly, we iterate through the binary content in 8 kB chunks, writing to a local file: file = photo.split(\".\")[0] + \".jpg\" with open(file, \"wb\") as f: logger.info(f\"receiving binary stream to {file}...\") for chunk in request.iter_content(chunk_size=8192): f.write(chunk) TODO This will log as such: python kotlin INFO:root:found a photo: GOPR0987.JPG INFO:root:Getting the thumbnail for GOPR0987.JPG INFO:root:Sending: http://10.5.5.9:8080/gopro/media/thumbnail?path=100GOPRO/GOPR0987.JPG INFO:root:receiving binary stream to GOPR0987_thumbnail.jpg... TODO Troubleshooting See the previous tutorial’s troubleshooting section. Good Job! Congratulations 🤙 You can now query the GoPro’s media list and retrieve binary information for media file. This is currently last tutorial. Stay tuned for more 👍 At this point you should be able to start creating a useful example using the Open GoPro Interface. For some inspiration check out some of the demos.",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/tutorials/camera-media-list#"
        },]