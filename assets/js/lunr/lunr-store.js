var store = [
        {
            "title": "Bluetooth Low Energy (BLE) Specifications: ",
            "excerpt": "This page will provide links to each version of the Open GoPro Bluetooth Low Energy (BLE) specification, as well as an overview of the changes from the previous version. Click on an individual spec to see it’s complete information including possible commands, settings, etc. Since the Open GoPro API varies based on the version, it is necessary to query the Open GoPro version using the Get Version command upon connection Versions Bluetooth Low Energy (BLE) Specification 2.0 Hilights: Capture media Track camera state Get media list and download files / metadata Load / edit presets Configure and use as webcam Add / remove hilights Breaking changes: Video Digital Lens setting parameter changes: Narrow changed from 6 to 2 Photo Digital Lens setting parameter changes: Wide changed from 22 to 101 Linear changed from 23 to 102 Narrow changed from 24 to 19 Max Superview changed from 25 to 100 Multishot Digital Lens parameter changes: Wide changed from 2 to 101 Narrow changed from 24 to 19 Bluetooth Low Energy (BLE) Specification 1.0 Initial API",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/ble#"
        },
        {
            "title": "Bluetooth Low Energy (BLE) Specification v1.0: ",
            "excerpt": "About This Page This page describes the format, capabilities, and use of Bluetooth Low Energy (BLE) as it pertains to communicating with GoPro cameras. Messages are sent using either TLV or Protobuf format. General Communicating with a GoPro camera via Bluetooth Low Energy involves writing to Bluetooth characteristics and, typically, waiting for a response notification from a corresponding characteristic. The camera organizes its Generic Attribute Profile (GATT) table by broad features: AP control, network management, control &amp; query, etc. Supported Cameras Below is a table of cameras that support GoPro's public BLE API: ID Model Marketing Name Minimal Firmware Version 55 HD9.01 HERO9 Black v1.60 Services and Characteristics Note: GP-XXXX is shorthand for GoPro's 128-bit UUIDs: b5f9xxxx-aa8d-11e3-9046-0002a5d5c51b Service UUID Service Characteristic UUID Description Permissions GP-0001 GoPro WiFi Access Point GP-0002 WiFi AP SSID Read / Write GP-0003 WiFi AP Password Read / Write GP-0004 WiFi AP Power Write GP-0005 WiFi AP State Read / Notify FEA6 Control &amp; Query GP-0072 Command Write GP-0073 Command Response Notify GP-0074 Settings Write GP-0075 Settings Response Notify GP-0076 Query Write GP-0077 Query Response Notify Packet Headers The Bluetooth Low Energy protocol limits messages to 20 Bytes per packet. To accommodate this limitation, the packet header rules below are used. All lengths are in bytes. The packet count starts at 0 for the first continuation packet. Packet Header Format Byte 1 Byte 2 (optional) Byte 3 (optional) 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 0: Start 00: General Message Length: 5 bits 0: Start 01: Extended (13-bit) Message Length: 13 bits 0: Start 10: Extended (16-bit) Message Length: 16 bits 0: Start 11: Reserved 1: Continuation Discovery, Connection and Pairing Advertisements The camera will send BLE advertisements while it is ON and for the first 8 hours after the camera is put to sleep. During this time, the camera is discoverable and can be connected to. If the camera is in sleep mode, connecting to it will cause the camera to wake and boot up. Pairing In order to communicate with a GoPro camera via BLE, a client must first be paired with the camera. The pairing procedure must be done once for each new client. If the camera is factory reset, all clients will need to pair again. To pair with the camera, use the UI to put it into pairing mode, connect via BLE and then initiate pairing. The camera will whitelist the client so subsequent connections do not require pairing. Camera To Enter Pairing Mode HERO9 Black Swipe down, swipe left &gt;&gt; Connections &gt;&gt; Connect Device &gt;&gt; GoPro App Steps Discovery of and connection to the GoPro camera can be done as follows: Put the camera into pairing mode Scan to discover peripherals (which can be narrowed by limiting to peripherals that advertise service FEA6) Connect to the peripheral Finish pairing with the peripheral Discover all advertised services and characteristics Subscribe to notifications from all characteristics that have the notify flag set Sending and Receiving Messages In order to enable two-way communication with a GoPro camera, clients must connect to the camera and subscribe to characteristics that have the notify flag set. Messages are sent to the camera by writing to a write-enabled UUID and then waiting for a notification from the corresponding response UUID. Response notifications indicate whether the message was valid and will be (asynchronously) processed. For example, to send a camera control command, a client should write to GP-0072 and then wait for a response notification from GP-0073. Depending on the camera's state, it may not be ready to accept some commands. This ready state is dependent on the System Busy and the Encoding Active status flags. For example: System Busy flag is set while loading presets, changing settings, formatting sdcard, ... Encoding Active flag is set while capturing photo/video media If the system is not ready, it should reject an incoming command; however, best practice is to always wait for the System Busy and Encode Active flags to go down before sending messages other than get status/setting queries. Keep Alive Unless changed by the user, GoPro cameras will automatically power off after some time (e.g. 5min, 15min, 30min). The Auto Power Down watchdog timer can be reset by sending periodic keep-alive messages to the camera, as below. It is recommended to send a keep-alive at least once every 120 seconds. UUID Write Response UUID Response GP-0074 03:5B:01:42 GP-0075 02:5B:00 Turbo Transfer Some cameras support Turbo Transfer mode, which allows media to be downloaded over WiFi more rapidly. This special mode should only be used during media offload. It is recommended that the user check for and--if necessary--disable Turbo Transfer on connect. For details on which cameras are supported and how to enable and disable Turbo Transfer, see Protobuf Commands. Limitations HERO9 Black The camera will reject requests to change settings while encoding; for example, if Hindsight feature is active, the user cannot change settings General Unless changed by the user, GoPro cameras will automatically power off after some time (e.g. 5min, 15min, 30min). The Auto Power Down watchdog timer can be reset by sending periodic keep-alive messages to the camera. It is recommended to send a keep-alive at least once every 120 seconds. In general, querying the value for a setting that is not associated with the current preset/flatmode results in an undefined value. For example, the user should not try to query the current Photo Digital Lenses (FOV) value while in Standard preset (Video flatmode). TLV GoPro's BLE protocol comes in two flavors: TLV (Type Length Value) and Protobuf. This section describes TLV style messaging. Commands The table below contains command IDs supported by Open GoPro. Command messages are sent to GP-0072 and responses/notifications are received on GP-0073. Command ID Description 0x01 Set shutter 0x05 Sleep 0x17 AP Control 0x3C Get Hardware Info 0x3E Presets: Load Group 0x40 Presets: Load 0x50 Analytics 0x51 Open GoPro Command Format Header/Length Command ID Parameter Length Parameter Value 1-2 bytes 1 byte 1 byte Variable length Command Response The GoPro camera sends responses to most commands received, indicating whether the command was valid and will be processed or not. Unless indicated otherwise in the Quick Reference table below, command responses use the format below. Command Response Format Header/Length Command ID Response Code Response 1-2 bytes 1 byte 1 byte Variable length Command Response Error Codes Error Code Description 0 Success 1 Error 2 Invalid Parameter 3..255 Reserved Commands Quick Reference Below is a table of commands that can be sent to the camera and how to send them. ID Command Description Request Response HERO9 Black 0x01 Set shutter Shutter: on 03:01:01:01 02:01:00 Y 0x01 Set shutter Shutter: off 03:01:01:00 02:01:00 Y 0x05 Sleep Put camera to sleep 01:05 02:05:00 Y 0x17 AP Control WiFi AP: on 03:17:01:01 02:17:00 Y 0x17 AP Control WiFi AP: off 03:17:01:00 02:17:00 Y 0x3C Get Hardware Info Get camera hardware info 01:3C Complex Y 0x3E Presets: Load Group Video 04:3E:02:03:E8 02:3E:00 Y 0x3E Presets: Load Group Photo 04:3E:02:03:E9 02:3E:00 Y 0x3E Presets: Load Group Timelapse 04:3E:02:03:EA 02:3E:00 Y 0x40 Presets: Load Activity 06:40:04:00:00:00:01 02:40:00 Y 0x40 Presets: Load Burst Photo 06:40:04:00:01:00:02 02:40:00 Y 0x40 Presets: Load Cinematic 06:40:04:00:00:00:02 02:40:00 Y 0x40 Presets: Load Live Burst 06:40:04:00:01:00:01 02:40:00 Y 0x40 Presets: Load Night Photo 06:40:04:00:01:00:03 02:40:00 Y 0x40 Presets: Load Night Lapse 06:40:04:00:02:00:02 02:40:00 Y 0x40 Presets: Load Photo 06:40:04:00:01:00:00 02:40:00 Y 0x40 Presets: Load Slo-Mo 06:40:04:00:00:00:03 02:40:00 Y 0x40 Presets: Load Standard 06:40:04:00:00:00:00 02:40:00 Y 0x40 Presets: Load Time Lapse 06:40:04:00:02:00:01 02:40:00 Y 0x40 Presets: Load Time Warp 06:40:04:00:02:00:00 02:40:00 Y 0x40 Presets: Load Max Photo 06:40:04:00:04:00:00 02:40:00 Y 0x40 Presets: Load Max Timewarp 06:40:04:00:05:00:00 02:40:00 Y 0x40 Presets: Load Max Video 06:40:04:00:03:00:00 02:40:00 Y 0x50 Analytics Set third party client 01:50 02:50:00 Y 0x51 Open GoPro Get version 01:51 Complex Y Complex Command Responses Below are clarifications for complex camera responses Get Hardware Info Response Packet Response Byte(s) Description 1 20 Start packet 51 Packet length 3C:00 Command 3C sent successfully 04 Length of model number 00:00:00:13 Model number 0B Length of model name 48:45:52:4F:58:20:42:6C:61:63 \"HEROX Blac\" 2 80 Continuation packet 6B \"k\" 04 Length of board type 30:78:30:35 \"0x05\" 0F Length of firmware version 48:44:58:2E:58:58:2E:58:58:2E:58:58 \"HDX.XX.XX.XX\" 3 81 Continuation packet (1) 2E:58:58 \".XX\" 0E Length of serial number 58:58:58:58:58:58:58:58:58:58:58:58:58:58 \"XXXXXXXXXXXXXX\" 0A Length of AP SSID 4 82 Continuation packet (2) 47:50:32:34:35:30:58:58:58:58 \"GP2450XXXX\" 0C AP MAC Address length 58:58:58:58:58:58:58:58 \"XXXXXXXX\" 5 83 Continuation packet (3) 58:58:58:58 \"XXXX\" Open GoPro Version Given the response 06:51:00:01:01:01:00, the Open GoPro version is v1.0. Response Byte(s) Description 06 Packet length 51 Command ID 00 Status (OK) 01 Length of major version 01 Major version: 1 01 Length of minor version 00 Minor version: 0 Settings GoPro settings can be configured using the GP-Settings (GP-0074) UUID. Setting status is returned on GP-Settings-Status (GP-0075) UUID. Settings Request Format This will configure a setting on the camera. Only one setting may be sent on a packet (GATT notify or write-no-response), although multiple packets may be sent back-to-back. Request Length Setting ID Setting Value Length Setting Value 1-2 bytes 1 byte 1 byte (variable length) Settings Response Format Response Length Setting ID Response Code 1 byte 1 byte 1 byte Settings Quick Reference All settings are sent to UUID GP-0074. All values are hexadecimal and length are in bytes. Setting ID Setting Option Request Response HERO9 Black 2 Resolution Set video resolution (id: 2) to 4k (value: 1) 03:02:01:01 02:02:00 Y 2 Resolution Set video resolution (id: 2) to 2.7k (value: 4) 03:02:01:04 02:02:00 Y 2 Resolution Set video resolution (id: 2) to 2.7k 4:3 (value: 6) 03:02:01:06 02:02:00 Y 2 Resolution Set video resolution (id: 2) to 1440 (value: 7) 03:02:01:07 02:02:00 Y 2 Resolution Set video resolution (id: 2) to 1080 (value: 9) 03:02:01:09 02:02:00 Y 2 Resolution Set video resolution (id: 2) to 4k 4:3 (value: 18) 03:02:01:12 02:02:00 Y 2 Resolution Set video resolution (id: 2) to 5k (value: 24) 03:02:01:18 02:02:00 Y 3 Frames Per Second Set video fps (id: 3) to 240 (value: 0) 03:03:01:00 02:03:00 Y 3 Frames Per Second Set video fps (id: 3) to 120 (value: 1) 03:03:01:01 02:03:00 Y 3 Frames Per Second Set video fps (id: 3) to 100 (value: 2) 03:03:01:02 02:03:00 Y 3 Frames Per Second Set video fps (id: 3) to 60 (value: 5) 03:03:01:05 02:03:00 Y 3 Frames Per Second Set video fps (id: 3) to 50 (value: 6) 03:03:01:06 02:03:00 Y 3 Frames Per Second Set video fps (id: 3) to 30 (value: 8) 03:03:01:08 02:03:00 Y 3 Frames Per Second Set video fps (id: 3) to 25 (value: 9) 03:03:01:09 02:03:00 Y 3 Frames Per Second Set video fps (id: 3) to 24 (value: 10) 03:03:01:0A 02:03:00 Y 3 Frames Per Second Set video fps (id: 3) to 200 (value: 13) 03:03:01:0D 02:03:00 Y 59 Auto Off Set setup auto power down (id: 59) to never (value: 0) 03:3B:01:00 01:3B:00 Y 59 Auto Off Set setup auto power down (id: 59) to 5 min (value: 4) 03:3B:01:04 01:3B:00 Y 59 Auto Off Set setup auto power down (id: 59) to 15 min (value: 6) 03:3B:01:06 01:3B:00 Y 59 Auto Off Set setup auto power down (id: 59) to 30 min (value: 7) 03:3B:01:07 01:3B:00 Y 121 Lens Set video digital lenses (id: 121) to wide (value: 0) 03:79:01:00 02:79:00 Y 121 Lens Set video digital lenses (id: 121) to narrow (value: 6) 03:79:01:06 02:79:00 Y 121 Lens Set video digital lenses (id: 121) to superview (value: 3) 03:79:01:03 02:79:00 Y 121 Lens Set video digital lenses (id: 121) to linear (value: 4) 03:79:01:04 02:79:00 Y 121 Lens Set video digital lenses (id: 121) to max superview (value: 7) 03:79:01:07 02:79:00 Y 121 Lens Set video digital lenses (id: 121) to linear + horizon leveling (value: 8) 03:79:01:08 02:79:00 Y 122 Lens Set photo digital lenses (id: 122) to narrow (value: 24) 03:7A:01:18 02:7A:00 Y 122 Lens Set photo digital lenses (id: 122) to max superview (value: 25) 03:7A:01:19 02:7A:00 Y 122 Lens Set photo digital lenses (id: 122) to wide (value: 22) 03:7A:01:16 02:7A:00 Y 122 Lens Set photo digital lenses (id: 122) to linear (value: 23) 03:7A:01:17 02:7A:00 Y 123 Lens Set multi shot digital lenses (id: 123) to narrow (value: 24) 03:7B:01:18 02:7B:00 Y 123 Lens Set multi shot digital lenses (id: 123) to wide (value: 22) 03:7B:01:16 02:7B:00 Y 123 Lens Set multi shot digital lenses (id: 123) to linear (value: 23) 03:7B:01:17 02:7B:00 Y 162 Max Lens Mod Enable Set mods max lens enable (id: 162) to off (value: 0) 03:A2:01:00 02:A2:00 Y 162 Max Lens Mod Enable Set mods max lens enable (id: 162) to on (value: 1) 03:A2:01:01 02:A2:00 Y Camera Capabilities Below are tables detailing supported features for Open GoPro cameras. HERO9 Black Resolution Anti-Flicker Frames Per Second Lens 1080 50Hz 24 Wide Superview Linear Narrow Linear + Horizon Leveling 25 Wide Superview Linear Narrow Linear + Horizon Leveling 50 Wide Superview Linear Narrow Linear + Horizon Leveling 100 Wide Superview Linear Narrow Linear + Horizon Leveling 200 Wide Linear Narrow Linear + Horizon Leveling 60Hz 24 Wide Superview Linear Narrow Linear + Horizon Leveling 30 Wide Superview Linear Narrow Linear + Horizon Leveling 60 Wide Superview Linear Narrow Linear + Horizon Leveling 120 Wide Superview Linear Narrow Linear + Horizon Leveling 240 Wide Linear Narrow Linear + Horizon Leveling 1440 50Hz 24 Wide Linear Narrow Linear + Horizon Leveling 25 Wide Linear Narrow Linear + Horizon Leveling 50 Wide Linear Narrow Linear + Horizon Leveling 100 Wide Linear Narrow Linear + Horizon Leveling 60Hz 24 Wide Linear Narrow Linear + Horizon Leveling 30 Wide Linear Narrow Linear + Horizon Leveling 60 Wide Linear Narrow Linear + Horizon Leveling 120 Wide Linear Narrow Linear + Horizon Leveling 2.7K 50Hz 50 Wide Superview Linear Narrow Linear + Horizon Leveling 100 Wide Linear Narrow Linear + Horizon Leveling 60Hz 60 Wide Superview Linear Narrow Linear + Horizon Leveling 120 Wide Linear Narrow Linear + Horizon Leveling 2.7K 4:3 50Hz 50 Wide Linear Narrow Linear + Horizon Leveling 60Hz 60 Wide Linear Narrow Linear + Horizon Leveling 4K 50Hz 24 Wide Superview Linear Narrow Linear + Horizon Leveling 25 Wide Superview Linear Narrow Linear + Horizon Leveling 50 Wide Linear Narrow Linear + Horizon Leveling 60Hz 24 Wide Superview Linear Narrow Linear + Horizon Leveling 30 Wide Superview Linear Narrow Linear + Horizon Leveling 60 Wide Linear Narrow Linear + Horizon Leveling 4K 4:3 50Hz 24 Wide Linear Narrow Linear + Horizon Leveling 25 Wide Linear Narrow Linear + Horizon Leveling 60Hz 24 Wide Linear Narrow Linear + Horizon Leveling 30 Wide Linear Narrow Linear + Horizon Leveling 5K 50Hz 24 Wide Linear Narrow Linear + Horizon Leveling 25 Wide Linear Narrow Linear + Horizon Leveling 60Hz 24 Wide Linear Narrow Linear + Horizon Leveling 30 Wide Linear Narrow Linear + Horizon Leveling Query The camera provides two basic types of state information: Camera status and settings. Camera status info includes information such as the current preset/mode, whether the system is encoding, remaining sdcard space, the date, etc. Settings info gives the currently selected option for each setting; for example, this includes the current video resolution, frame rate, digital lens (FOV), etc. Queries are sent to to GP-0076 and responses are received on GP-0077. All packets sent and received are in Big Endian. Query Format Header/Length Query Command ID Array of IDs 1-2 bytes 1 byte Variable Length Query Commands All query commands are sent to GP-0076. Responses are received on GP-0077. Note: omitting :xx:... from (un)register query commands will result in being (un)registered for all possible updates Query ID Query Request Notes 0x12 Get setting value 02:12:xx xx -&gt; Setting ID 0x12 Get all setting values 01:12 0x13 Get status value 02:13:xx xx -&gt; status code 0x13 Get all status values 01:13 0x52 Register for setting updates nn:52:xx:... nn -&gt; message length xx -&gt; setting id 0x53 Register for status updates nn:53:xx:... nn -&gt; message length xx -&gt; status code 0x72 Unregister for setting updates nn:72:xx:... nn -&gt; message length xx -&gt; setting id 0x73 Unregister for status updates nn:73:xx:... nn -&gt; message length xx -&gt; status code Query Response Format Query responses are pushed asynchronously in the following scenarios: The user queries for current status/settings The user registers for settings/status updates The user is registered to receive updates for a status/setting and the value changes Message Length Query ID Command Status Status ID Status Value Length Status Value 1-2 bytes 1 byte 1 byte 1 byte 1 byte 1-255 bytes Multi-Value Responses When querying for or receiving a push notifications about more than one setting/status, the Status ID, Status Value Length, and Status Value fields become collectively repeatable. Example: [MESSAGE LENGTH]:[QUERY ID]:[COMMAND STATUS]:[ID1]:[LENGTH1]:[VALUE1]:[ID2]:[LENGTH2]:[VALUE2]:... Push Notification Responses The Query ID for settings/status push notifications replaces the upper 4 bits with 1001 (nine). For example, if the original query comand ID was 0x52, the query ID of the push notification will be 0x92. Status Codes Below is a table of all possible camera status codes. Status ID Name Description Type Values 1 Internal battery present Is the system's internal battery present? boolean 0: False 1: True 2 Internal battery level Rough approximation of internal battery level in bars integer 0: Zero 1: One 2: Two 3: Three 3 External battery present Is an external battery connected? boolean 0: False 1: True 4 External battery level External battery power level in percent percent 0-100 5 Unused Unused None 6 System hot Is the system currently overheating? boolean 0: False 1: True 7 Unused Unused None 8 System busy Is the camera busy? boolean 0: False 1: True 9 Quick capture active Is Quick Capture feature enabled? boolean 0: False 1: True 10 Encoding active Is the system encoding right now? boolean 0: False 1: True 11 Lcd lock active Is LCD lock active? boolean 0: False 1: True 12 Unused Unused None 13 Video progress counter When encoding video, this is the duration (seconds) of the video so far; 0 otherwise integer * 17 Enable Are Wireless Connections enabled? boolean 0: False 1: True 18 Unused Unused * 19 State The pairing state of the camera integer 0: Success 1: In Progress 2: Failed 3: Stopped 20 Type The last type of pairing that the camera was engaged in integer 0: Not Pairing 1: Pairing App 2: Pairing Remote Control 3: Pairing Bluetooth Device 21 Pair time Time (milliseconds) since boot of last successful pairing complete action integer * 22 State State of current scan for WiFi Access Points. Appears to only change for CAH-related scans integer 0: Never started 1: Started 2: Aborted 3: Canceled 4: Completed 23 Scan time msec The time, in milliseconds since boot that the WiFi Access Point scan completed integer * 24 Provision status WiFi AP provisioning state integer 0: Never started 1: Started 2: Aborted 3: Canceled 4: Completed 25 Unused Unused None 26 Remote control version Wireless remote control version integer * 27 Remote control connected Is a wireless remote control connected? boolean 0: False 1: True 28 Pairing Wireless Pairing State integer * 29 Wlan ssid Provisioned WIFI AP SSID. On BLE connection, value is big-endian byte-encoded int string * 30 Ap ssid Camera's WIFI SSID. On BLE connection, value is big-endian byte-encoded int string * 31 App count The number of wireless devices connected to the camera integer * 32 Enable Is Preview Stream enabled? boolean 0: False 1: True 33 Sd status Primary Storage Status integer -1: Unknown 0: OK 1: SD Card Full 2: SD Card Removed 3: SD Card Format Error 4: SD Card Busy 8: SD Card Swapped 34 Remaining photos How many photos can be taken before sdcard is full integer * 35 Remaining video time How many minutes of video can be captured with current settings before sdcard is full integer * 36 Num group photos How many group photos can be taken with current settings before sdcard is full integer * 37 Num group videos Total number of group videos on sdcard integer * 38 Num total photos Total number of photos on sdcard integer * 39 Num total videos Total number of videos on sdcard integer * 40 Date time Current date/time (format: %YY%MM%DD%HH%MM%SS, all values in hex) string * 41 Ota status The current status of Over The Air (OTA) update integer 0: Idle 1: Downloading 2: Verifying 3: Download Failed 4: Verify Failed 5: Ready 6: GoPro App: Downloading 7: GoPro App: Verifying 8: GoPro App: Download Failed 9: GoPro App: Verify Failed 10: GoPro App: Ready 42 Download cancel request pending Is there a pending request to cancel a firmware update download? boolean 0: False 1: True 45 Camera locate active Is locate camera feature active? boolean 0: False 1: True 49 Multi shot count down The current timelapse interval countdown value (e.g. 5...4...3...2...1...) integer * 50 Unused Unused None 51 Unused Unused None 52 Unused Unused None 53 Unused Unused None 54 Remaining space Remaining space on the sdcard in Kilobytes integer * 55 Supported Is preview stream supported in current recording/flatmode/secondary-stream? boolean 0: False 1: True 56 Wifi bars WiFi signal strength in bars integer * 57 Current time msec System time in milliseconds since system was booted integer * 58 Num hilights The number of hilights in encoding video (set to 0 when encoding stops) integer * 59 Last hilight time msec Time since boot (msec) of most recent hilight in encoding video (set to 0 when encoding stops) integer * 60 Next poll msec The min time between camera status updates (msec). Do not poll for status more often than this integer * 63 In contextual menu Is the camera currently in a contextual menu (e.g. Preferences)? boolean 0: False 1: True 64 Remaining timelapse time How many min of Timelapse video can be captured with current settings before sdcard is full integer * 65 Exposure select type Liveview Exposure Select Mode integer 0: Disabled 1: Auto 2: ISO Lock 3: Hemisphere 66 Exposure select x Liveview Exposure Select: y-coordinate (percent) percent 0-100 67 Exposure select y Liveview Exposure Select: y-coordinate (percent) percent 0-100 68 Gps status Does the camera currently have a GPS lock? boolean 0: False 1: True 69 Ap state Is the WiFi radio enabled? boolean 0: False 1: True 70 Internal battery percentage Internal battery level (percent) percent 0-100 74 Acc mic status Microphone Accesstory status integer 0: Microphone mod not connected 1: Microphone mod connected 2: Microphone mod connected and microphone plugged into Microphone mod 75 Digital zoom Digital Zoom level (percent) percent 0-100 76 Wireless band Wireless Band integer 0: 2.4 GHz 1: 5 GHz 2: Max 77 Digital zoom active Is Digital Zoom feature available? boolean 0: False 1: True 78 Mobile friendly video Are current video settings mobile friendly? (related to video compression and frame rate) boolean 0: False 1: True 79 First time use Is the camera currently in First Time Use (FTU) UI flow? boolean 0: False 1: True 81 Band 5ghz avail Is 5GHz wireless band available? boolean 0: False 1: True 82 System ready Is the system ready to accept commands? boolean 0: False 1: True 83 Batt okay for ota Is the internal battery charged sufficiently to start Over The Air (OTA) update? boolean 0: False 1: True 85 Video low temp alert Is the camera getting too cold to continue recording? boolean 0: False 1: True 86 Actual orientation The rotational orientation of the camera integer 0: 0 degrees (upright) 1: 180 degrees (upside down) 2: 90 degrees (laying on right side) 3: 270 degrees (laying on left side) 87 Thermal mitigation mode Can camera use high resolution/fps (based on temperature)? (HERO7 Silver/White only) boolean 0: False 1: True 88 Zoom while encoding Is this camera capable of zooming while encoding (static value based on model, not settings) boolean 0: False 1: True 89 Current mode Current flatmode ID integer * 91 Logs ready Are system logs ready to be downloaded? boolean 0: False 1: True 92 Timewarp 1x active Is Timewarp 1x active? boolean 0: False 1: True 93 Active video presets Current Video Preset (ID) integer * 94 Active photo presets Current Photo Preset (ID) integer * 95 Active timelapse presets Current Timelapse Preset (ID) integer * 96 Active presets group Current Preset Group (ID) integer * 97 Active preset Current Preset (ID) integer * 98 Preset modified Preset Modified Status, which contains an event ID and a preset (group) ID integer * 99 Remaining live bursts How many Live Bursts can be captured before sdcard is full integer * 100 Num total live bursts Total number of Live Bursts on sdcard integer * 101 Capture delay active Is Capture Delay currently active (i.e. counting down)? boolean 0: False 1: True 102 Media mod mic status Media mod State integer 0: Media mod microphone removed 2: Media mod microphone only 3: Media mod microphone with external microphone 103 Timewarp speed ramp active Time Warp Speed integer 0: 15x 1: 30x 2: 60x 3: 150x 4: 300x 5: 900x 6: 1800x 7: 2x 8: 5x 9: 10x 10: Auto 11: 1x (realtime) 12: 1/2x (slow-motion) 104 Linux core active Is the system's Linux core active? boolean 0: False 1: True 105 Camera lens type Camera lens type (reflects changes to setting 162) integer 0: Default 1: Max Lens 106 Video hindsight capture active Is Video Hindsight Capture Active? boolean 0: False 1: True 107 Scheduled preset Scheduled Capture Preset ID integer * 108 Scheduled enabled Is Scheduled Capture set? boolean 0: False 1: True 109 Creating preset Is the camera in the process of creating a custom preset? boolean 0: False 1: True 110 Media mod status Media Mode Status (bitmasked) integer 0: Display (selfie) mod: 0, HDMI: 0, Media Mod Connected: False 1: Display (selfie) mod: 0, HDMI: 0, Media Mod Connected: True 2: Display (selfie) mod: 0, HDMI: 1, Media Mod Connected: False 3: Display (selfie) mod: 0, HDMI: 1, Media Mod Connected: True 4: Display (selfie) mod: 1, HDMI: 0, Media Mod Connected: False 5: Display (selfie) mod: 1, HDMI: 0, Media Mod Connected: True 6: Display (selfie) mod: 1, HDMI: 1, Media Mod Connected: False 7: Display (selfie) mod: 1, HDMI: 1, Media Mod Connected: True 113 Turbo transfer Is Turbo Transfer active? boolean 0: False 1: True Protobuf In order to maximize BLE bandwidth, some complex messages are sent using Google Protobuf (Protocol Buffers). Protobuf Message Format Protobuf communications with the camera differ from TLV-style communications. Rather than having a Type, Length, and Value, protobuf messages sent to a GoPro device have a Command Type (called a Feature), a Sub-command Type (called an Action) and a Value (serialization of a protobuf object). Note: For commands that do not require any protobuf inputs, Value would be empty (0 bytes). Message Length Feature ID Action ID Protobuf Bytestream 1-2 bytes 1 byte 1 byte Variable Length Protobuf Commands Open GoPro supports the following protobuf commands: Feature ID Action ID Description Request Response 0xF1 0x6B Request set turbo active RequestSetTurboActive ResponseGeneric 0xF5 0x72 Request get preset status RequestGetPresetStatus NotifyPresetStatus Protobuf Command Details Below are additional details about specific protobuf commands: RequestSetTurboActive Turbo Transfer Mode is a special feature that serves two purposes: Temporarily modify low-level settings in the OS to prioritize WiFi offload speeds Put up a UI on the camera indicating that media is being transferred and preventing the user from inadvertently changing settings or capturing new media Developers can query whether the camera is currently in Turbo Transfer Mode from camera status 113. While in Turbo Transfer Mode, if the user presses the Mode/Power or Shutter buttons on the camera, Turbo Transfer Mode will be deactivated. Some cameras are already optimized for WiFi transfer and do not gain additional speed from this feature. RequestGetPresetStatus This command is used to get information about what Preset Groups and Presets the camera supports in its current state. Each Preset Group contains an ID, whether additional presets can be added, and an array of existing Presets. Each Preset contains information about its ID, associated flatmode, title, icon, whether it's a user-defined preset, whether the preset has been modified from its factory-default state (for factory-default presets only) and a list of settings associated with the Preset. Preset Status should not be confused with camera status, which contains hundreds of camera/setting statuses on a system level.",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/ble_1_0#"
        },
        {
            "title": "Bluetooth Low Energy (BLE) Specification v2.0: ",
            "excerpt": "About This Page This page describes the format, capabilities, and use of Bluetooth Low Energy (BLE) as it pertains to communicating with GoPro cameras. Messages are sent using either TLV or Protobuf format. General Communicating with a GoPro camera via Bluetooth Low Energy involves writing to Bluetooth characteristics and, typically, waiting for a response notification from a corresponding characteristic. The camera organizes its Generic Attribute Profile (GATT) table by broad features: AP control, control &amp; query, etc. Supported Cameras Below is a table of cameras that support GoPro's public BLE API: ID Model Marketing Name Minimal Firmware Version 57 H21.01 HERO10 Black v01.10.00 Services and Characteristics Note: GP-XXXX is shorthand for GoPro's 128-bit UUIDs: b5f9xxxx-aa8d-11e3-9046-0002a5d5c51b Service UUID Service Characteristic UUID Description Permissions GP-0001 GoPro WiFi Access Point GP-0002 WiFi AP SSID Read / Write GP-0003 WiFi AP Password Read / Write GP-0004 WiFi AP Power Write GP-0005 WiFi AP State Read / Indicate FEA6 Control &amp; Query GP-0072 Command Write GP-0073 Command Response Notify GP-0074 Settings Write GP-0075 Settings Response Notify GP-0076 Query Write GP-0077 Query Response Notify Packet Headers The Bluetooth Low Energy protocol limits messages to 20 Bytes per packet. To accommodate this limitation, the packet header rules below are used. All lengths are in bytes. The packet count starts at 0 for the first continuation packet. Packet Header Format Byte 1 Byte 2 (optional) Byte 3 (optional) 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 0: Start 00: General Message Length: 5 bits 0: Start 01: Extended (13-bit) Message Length: 13 bits 0: Start 10: Extended (16-bit) Message Length: 16 bits 0: Start 11: Reserved 1: Continuation Discovery, Connection and Pairing Advertisements The camera will send BLE advertisements while it is ON and for the first 8 hours after the camera is put to sleep. During this time, the camera is discoverable and can be connected to. If the camera is in sleep mode, connecting to it will cause the camera to wake and boot up. Pairing In order to communicate with a GoPro camera via BLE, a client must first be paired with the camera. The pairing procedure must be done once for each new client. If the camera is factory reset, all clients will need to pair again. To pair with the camera, use the UI to put it into pairing mode, connect via BLE and then initiate pairing. The camera will whitelist the client so subsequent connections do not require pairing. Camera To Enter Pairing Mode HERO10 Black Swipe down, swipe left &gt;&gt; Connections &gt;&gt; Connect Device &gt;&gt; GoPro Quik App Steps Discovery of and connection to the GoPro camera can be done as follows: Put the camera into pairing mode Scan to discover peripherals (which can be narrowed by limiting to peripherals that advertise service FEA6) Connect to the peripheral Finish pairing with the peripheral Discover all advertised services and characteristics Subscribe to notifications from all characteristics that have the notify flag set Sending and Receiving Messages In order to enable two-way communication with a GoPro camera, clients must connect to the camera and subscribe to characteristics that have the notify flag set. Messages are sent to the camera by writing to a write-enabled UUID and then waiting for a notification from the corresponding response UUID. Response notifications indicate whether the message was valid and will be (asynchronously) processed. For example, to send a camera control command, a client should write to GP-0072 and then wait for a response notification from GP-0073. Depending on the camera's state, it may not be ready to accept specific commands. This ready state is dependent on the System Busy and the Encoding Active status flags. For example: System Busy flag is set while loading presets, changing settings, formatting sdcard, ... Encoding Active flag is set while capturing photo/video media If the system is not ready, it should reject an incoming command; however, best practice is to always wait for the System Busy and Encode Active flags to be unset before sending messages other than get status/setting queries. Presets The camera organizes modes of operation into presets. A preset is a logical wrapper around a specific camera flatmode and a collection of settings that target different ways of capturing media. The set of presets available to load at any moment depends on the value of certain camera settings, which are outlined in the table below. For per-preset firmware compatibility information, see Commands Quick Reference. Setting Preset Preset ID Max Lens: OFF Standard 0x00000000 Activity 0x00000001 Cinematic 0x00000002 Ultra Slo-Mo 0x00000004 Basic 0x00000005 Photo 0x00010000 Live Burst 0x00010001 Burst Photo 0x00010002 Night Photo 0x00010003 Time Warp 0x00020000 Time Lapse 0x00020001 Night Lapse 0x00020002 Max Lens: ON Max Video 0x00030000 Max Photo 0x00040000 Max Timewarp 0x00050000 Video Performance Mode: Maximum Video Performance Standard 0x00000000 Activity 0x00000001 Cinematic 0x00000002 Ultra Slo-Mo 0x00000004 Basic 0x00000005 Photo 0x00010000 Live Burst 0x00010001 Burst Photo 0x00010002 Night Photo 0x00010003 Time Warp 0x00020000 Time Lapse 0x00020001 Night Lapse 0x00020002 Video Performance Mode: Extended Battery Photo 0x00010000 Live Burst 0x00010001 Burst Photo 0x00010002 Night Photo 0x00010003 Time Warp 0x00020000 Time Lapse 0x00020001 Night Lapse 0x00020002 Standard [EB] 0x00080000 Activity [EB] 0x00080001 Cinematic [EB] 0x00080002 Slo-Mo [EB] 0x00080003 Video Performance Mode: Tripod / Stationary Video Photo 0x00010000 Live Burst 0x00010001 Burst Photo 0x00010002 Night Photo 0x00010003 Time Warp 0x00020000 Time Lapse 0x00020001 Night Lapse 0x00020002 4K Tripod 0x00090000 5.3K Tripod 0x00090001 Keep Alive Unless changed by the user, GoPro cameras will automatically power off after some time (e.g. 5min, 15min, 30min). The Auto Power Down watchdog timer can be reset by sending periodic keep-alive messages to the camera, as below. It is recommended to send a keep-alive at least once every 120 seconds. UUID Write Response UUID Response GP-0074 03:5B:01:42 GP-0075 02:5B:00 Turbo Transfer Some cameras support Turbo Transfer mode, which allows media to be downloaded over WiFi more rapidly. This special mode should only be used during media offload. It is recommended that the user check for and--if necessary--disable Turbo Transfer on connect. For details on which cameras are supported and how to enable and disable Turbo Transfer, see Protobuf Commands. Global Behaviors In order to prevent undefined behavior between the camera and a connected app, simultaneous use of the camera and a connected app is discouraged. Best practice for synchronizing user/app control is to use the Set Camera Control Status command and corresponding Camera Control Status (CCS) camera statuses in alignment with the finite state machine below: Limitations HERO10 Black The camera will reject requests to change settings while encoding; for example, if Hindsight feature is active, the user cannot change settings General Unless changed by the user, GoPro cameras will automatically power off after some time (e.g. 5min, 15min, 30min). The Auto Power Down watchdog timer can be reset by sending periodic keep-alive messages to the camera. It is recommended to send a keep-alive at least once every 120 seconds. In general, querying the value for a setting that is not associated with the current preset/flatmode results in an undefined value. For example, the user should not try to query the current Photo Digital Lenses (FOV) value while in Standard preset (Video flatmode). USB command and control is not supported on HERO9 Black. TLV GoPro's BLE protocol comes in two flavors: TLV (Type Length Value) and Protobuf. This section describes TLV style messaging. Commands The table below contains command IDs supported by Open GoPro. Command messages are sent to GP-0072 and responses/notifications are received on GP-0073. Command ID Description 0x01 Set shutter 0x05 Sleep 0x0D Set Date/Time 0x0E Get Date/Time 0x17 AP Control 0x3C Get Hardware Info 0x3E Presets: Load Group 0x40 Presets: Load 0x50 Analytics 0x51 Open GoPro Command Format Header/Length Command ID Parameter Length Parameter Value 1-2 bytes 1 byte 1 byte Variable length Command Response The GoPro camera sends responses to most commands received, indicating whether the command was valid and will be processed or not. Unless indicated otherwise in the Quick Reference table below, command responses use the format below. Command Response Format Header/Length Command ID Response Code Response 1-2 bytes 1 byte 1 byte Variable length Command Response Error Codes Error Code Description 0 Success 1 Error 2 Invalid Parameter 3..255 Reserved Commands Quick Reference Below is a table of commands that can be sent to the camera and how to send them. ✔ Indicates support for all Open GoPro firmware versions. ❌ Indicates a lack of support for all Open GoPro firmware versions. &gt;= vXX.YY.ZZ indicates support for firmware versions equal to or newer than vXX.YY.ZZ ID Command Description Request Response HERO10 Black 0x01 Set shutter Shutter: off 03:01:01:00 02:01:00 ✔ 0x01 Set shutter Shutter: on 03:01:01:01 02:01:00 ✔ 0x05 Sleep Put camera to sleep 01:05 02:05:00 ✔ 0x0D Set Date/Time Set date/time to 2022-01-02 03:04:05 09:0D:07:07:E6:01:02:03:04:05 02:0D:00 ✔ 0x0E Get Date/Time Get date/time 01:0E Complex ✔ 0x17 AP Control WiFi AP: off 03:17:01:00 02:17:00 ✔ 0x17 AP Control WiFi AP: on 03:17:01:01 02:17:00 ✔ 0x3C Get Hardware Info Get camera hardware info 01:3C Complex ✔ 0x3E Presets: Load Group Video 04:3E:02:03:E8 02:3E:00 ✔ 0x3E Presets: Load Group Photo 04:3E:02:03:E9 02:3E:00 ✔ 0x3E Presets: Load Group Timelapse 04:3E:02:03:EA 02:3E:00 ✔ 0x40 Presets: Load Standard 06:40:04:00:00:00:00 02:40:00 ✔ 0x40 Presets: Load Activity 06:40:04:00:00:00:01 02:40:00 ✔ 0x40 Presets: Load Cinematic 06:40:04:00:00:00:02 02:40:00 ✔ 0x40 Presets: Load Ultra Slo-Mo 06:40:04:00:00:00:04 02:40:00 \\&gt;= v01.16.00 0x40 Presets: Load Basic 06:40:04:00:00:00:05 02:40:00 \\&gt;= v01.16.00 0x40 Presets: Load Photo 06:40:04:00:01:00:00 02:40:00 ✔ 0x40 Presets: Load Live Burst 06:40:04:00:01:00:01 02:40:00 ✔ 0x40 Presets: Load Burst Photo 06:40:04:00:01:00:02 02:40:00 ✔ 0x40 Presets: Load Night Photo 06:40:04:00:01:00:03 02:40:00 ✔ 0x40 Presets: Load Time Warp 06:40:04:00:02:00:00 02:40:00 ✔ 0x40 Presets: Load Time Lapse 06:40:04:00:02:00:01 02:40:00 ✔ 0x40 Presets: Load Night Lapse 06:40:04:00:02:00:02 02:40:00 ✔ 0x40 Presets: Load Max Video 06:40:04:00:03:00:00 02:40:00 \\&gt;= v01.20.00 0x40 Presets: Load Max Photo 06:40:04:00:04:00:00 02:40:00 \\&gt;= v01.20.00 0x40 Presets: Load Max Timewarp 06:40:04:00:05:00:00 02:40:00 \\&gt;= v01.20.00 0x40 Presets: Load Standard [EB] 06:40:04:00:08:00:00 02:40:00 \\&gt;= v01.16.00 0x40 Presets: Load Activity [EB] 06:40:04:00:08:00:01 02:40:00 \\&gt;= v01.16.00 0x40 Presets: Load Cinematic [EB] 06:40:04:00:08:00:02 02:40:00 \\&gt;= v01.16.00 0x40 Presets: Load Slo-Mo [EB] 06:40:04:00:08:00:03 02:40:00 \\&gt;= v01.16.00 0x40 Presets: Load 4K Tripod 06:40:04:00:09:00:00 02:40:00 \\&gt;= v01.16.00 0x40 Presets: Load 5.3K Tripod 06:40:04:00:09:00:01 02:40:00 \\&gt;= v01.16.00 0x50 Analytics Set third party client 01:50 02:50:00 ✔ 0x51 Open GoPro Get version 01:51 Complex ✔ Complex Command Responses Below are clarifications for complex camera responses Get Hardware Info Response Packet Response Byte(s) Description 1 20 Start packet 51 Packet length 3C:00 Command 3C sent successfully 04 Length of model number 00:00:00:13 Model number 0B Length of model name 48:45:52:4F:58:20:42:6C:61:63 \"HEROX Blac\" 2 80 Continuation packet 6B \"k\" 04 Length of board type 30:78:30:35 \"0x05\" 0F Length of firmware version 48:44:58:2E:58:58:2E:58:58:2E:58:58 \"HDX.XX.XX.XX\" 3 81 Continuation packet (1) 2E:58:58 \".XX\" 0E Length of serial number 58:58:58:58:58:58:58:58:58:58:58:58:58:58 \"XXXXXXXXXXXXXX\" 0A Length of AP SSID 4 82 Continuation packet (2) 47:50:32:34:35:30:58:58:58:58 \"GP2450XXXX\" 0C AP MAC Address length 58:58:58:58:58:58:58:58 \"XXXXXXXX\" 5 83 Continuation packet (3) 58:58:58:58 \"XXXX\" Open GoPro Version Given the response 06:51:00:01:01:01:00, the Open GoPro version would be vXX.YY. Response Byte(s) Description 06 Packet length 51 Command ID 00 Status (OK) 01 Length of major version 01 Major version: 1 01 Length of minor version 00 Minor version: 0 Get Date/Time Given the response 0b:0e:00:08:07:e5:01:02:03:04:05:06, the date/time would be 2021-01-02 03:04:05 (Saturday). Response Byte(s) Description 0B Packet length 0E Command ID 00 Status (OK) 08 Date length (bytes) 07:E5 Year (big endian) 01 Month 02 Day 03 Hour 04 Minute 05 Second 06 Day of the week (Sun=0, Sat=6) Settings GoPro settings can be configured using the GP-Settings (GP-0074) UUID. Setting status is returned on GP-Settings-Status (GP-0075) UUID. Settings Request Format This will configure a setting on the camera. Only one setting may be sent on a packet (GATT notify or write-no-response), although multiple packets may be sent back-to-back. Request Length Setting ID Setting Value Length Setting Value 1-2 bytes 1 byte 1 byte (variable length) Settings Response Format Response Length Setting ID Response Code 1 byte 1 byte 1 byte Settings Quick Reference All settings are sent to UUID GP-0074. All values are hexadecimal and length are in bytes. ✔ Indicates support for all Open GoPro firmware versions. ❌ Indicates a lack of support for all Open GoPro firmware versions. &gt;= vXX.YY.ZZ indicates support for firmware versions equal to or newer than vXX.YY.ZZ Setting ID Setting Option Request Response HERO10 Black 2 Resolution Set video resolution (id: 2) to 4k (id: 1) 03:02:01:01 02:02:00 ✔ 2 Resolution Set video resolution (id: 2) to 2.7k (id: 4) 03:02:01:04 02:02:00 ✔ 2 Resolution Set video resolution (id: 2) to 2.7k 4:3 (id: 6) 03:02:01:06 02:02:00 ✔ 2 Resolution Set video resolution (id: 2) to 1080 (id: 9) 03:02:01:09 02:02:00 ✔ 2 Resolution Set video resolution (id: 2) to 4k 4:3 (id: 18) 03:02:01:12 02:02:00 ✔ 2 Resolution Set video resolution (id: 2) to 5k 4:3 (id: 25) 03:02:01:19 02:02:00 ✔ 2 Resolution Set video resolution (id: 2) to 5.3k (id: 100) 03:02:01:64 02:02:00 ✔ 3 Frames Per Second Set video fps (id: 3) to 240 (id: 0) 03:03:01:00 02:03:00 ✔ 3 Frames Per Second Set video fps (id: 3) to 120 (id: 1) 03:03:01:01 02:03:00 ✔ 3 Frames Per Second Set video fps (id: 3) to 100 (id: 2) 03:03:01:02 02:03:00 ✔ 3 Frames Per Second Set video fps (id: 3) to 60 (id: 5) 03:03:01:05 02:03:00 ✔ 3 Frames Per Second Set video fps (id: 3) to 50 (id: 6) 03:03:01:06 02:03:00 ✔ 3 Frames Per Second Set video fps (id: 3) to 30 (id: 8) 03:03:01:08 02:03:00 ✔ 3 Frames Per Second Set video fps (id: 3) to 25 (id: 9) 03:03:01:09 02:03:00 ✔ 3 Frames Per Second Set video fps (id: 3) to 24 (id: 10) 03:03:01:0A 02:03:00 ✔ 3 Frames Per Second Set video fps (id: 3) to 200 (id: 13) 03:03:01:0D 02:03:00 ✔ 59 Auto Power Down Set auto power down (id: 59) to never (id: 0) 03:3B:01:00 01:3B:00 ✔ 59 Auto Power Down Set auto power down (id: 59) to 5 min (id: 4) 03:3B:01:04 01:3B:00 ✔ 59 Auto Power Down Set auto power down (id: 59) to 15 min (id: 6) 03:3B:01:06 01:3B:00 ✔ 59 Auto Power Down Set auto power down (id: 59) to 30 min (id: 7) 03:3B:01:07 01:3B:00 ✔ 121 Video Digital Lenses Set video digital lenses (id: 121) to wide (id: 0) 03:79:01:00 02:79:00 ✔ 121 Video Digital Lenses Set video digital lenses (id: 121) to narrow (id: 2) 03:79:01:02 02:79:00 ✔ 121 Video Digital Lenses Set video digital lenses (id: 121) to superview (id: 3) 03:79:01:03 02:79:00 ✔ 121 Video Digital Lenses Set video digital lenses (id: 121) to linear (id: 4) 03:79:01:04 02:79:00 ✔ 121 Video Digital Lenses Set video digital lenses (id: 121) to max superview (id: 7) 03:79:01:07 02:79:00 ✔ 121 Video Digital Lenses Set video digital lenses (id: 121) to linear + horizon leveling (id: 8) 03:79:01:08 02:79:00 ✔ 122 Photo Digital Lenses Set photo digital lenses (id: 122) to narrow (id: 19) 03:7A:01:13 02:7A:00 ✔ 122 Photo Digital Lenses Set photo digital lenses (id: 122) to max superview (id: 100) 03:7A:01:64 02:7A:00 ✔ 122 Photo Digital Lenses Set photo digital lenses (id: 122) to wide (id: 101) 03:7A:01:65 02:7A:00 ✔ 122 Photo Digital Lenses Set photo digital lenses (id: 122) to linear (id: 102) 03:7A:01:66 02:7A:00 ✔ 123 Time Lapse Digital Lenses Set time lapse digital lenses (id: 123) to narrow (id: 19) 03:7B:01:13 02:7B:00 ✔ 123 Time Lapse Digital Lenses Set time lapse digital lenses (id: 123) to max superview (id: 100) 03:7B:01:64 02:7B:00 ✔ 123 Time Lapse Digital Lenses Set time lapse digital lenses (id: 123) to wide (id: 101) 03:7B:01:65 02:7B:00 ✔ 123 Time Lapse Digital Lenses Set time lapse digital lenses (id: 123) to linear (id: 102) 03:7B:01:66 02:7B:00 ✔ 128 Media Format Set media format (id: 128) to time lapse video (id: 13) 03:80:01:0D 02:80:00 ✔ 128 Media Format Set media format (id: 128) to time lapse photo (id: 20) 03:80:01:14 02:80:00 ✔ 128 Media Format Set media format (id: 128) to night lapse photo (id: 21) 03:80:01:15 02:80:00 ✔ 128 Media Format Set media format (id: 128) to night lapse video (id: 26) 03:80:01:1A 02:80:00 ✔ 134 Anti-Flicker Set setup anti flicker (id: 134) to 60hz (id: 2) 03:86:01:02 02:86:00 ✔ 134 Anti-Flicker Set setup anti flicker (id: 134) to 50hz (id: 3) 03:86:01:03 02:86:00 ✔ 135 Hypersmooth Set video hypersmooth (id: 135) to off (id: 0) 03:87:01:00 02:87:00 ✔ 135 Hypersmooth Set video hypersmooth (id: 135) to high (id: 2) 03:87:01:02 02:87:00 ✔ 135 Hypersmooth Set video hypersmooth (id: 135) to boost (id: 3) 03:87:01:03 02:87:00 ✔ 135 Hypersmooth Set video hypersmooth (id: 135) to standard (id: 100) 03:87:01:64 02:87:00 ✔ 162 Max Lens Set max lens (id: 162) to off (id: 0) 03:A2:01:00 02:A2:00 \\&gt;= v01.20.00 162 Max Lens Set max lens (id: 162) to on (id: 1) 03:A2:01:01 02:A2:00 \\&gt;= v01.20.00 173 Video Performance Mode Set video performance mode (id: 173) to maximum video performance (id: 0) 03:AD:01:00 02:AD:00 \\&gt;= v01.16.00 173 Video Performance Mode Set video performance mode (id: 173) to extended battery (id: 1) 03:AD:01:01 02:AD:00 \\&gt;= v01.16.00 173 Video Performance Mode Set video performance mode (id: 173) to tripod / stationary video (id: 2) 03:AD:01:02 02:AD:00 \\&gt;= v01.16.00 Camera Capabilities Camera capabilities usually change from one camera to another and often change from one release to the next. Below are documents that detail whitelists for basic video settings for every supported camera release. Note about Dependency Ordering and Blacklisting Capability documents define supported camera states. Each state is comprised of a set of setting options that are presented in dependency order. This means each state is guaranteed to be attainable if and only if the setting options are set in the order presented. Failure to adhere to dependency ordering may result in the camera's blacklist rules rejecting a set-setting command. Example Camera Command 1 Command 2 Command 3 Command 4 Command 5 Guaranteed Valid? HERO10 Black Res: 1080 Anti-Flicker: 60Hz (NTSC) FPS: 240 FOV: Wide Hypersmooth: OFF ✔ HERO10 Black FPS: 240 Anti-Flicker: 60Hz (NTSC) Res: 1080 FOV: Wide Hypersmooth: OFF ❌ In the example above, the first set of commands will always work for basic video presets such as Standard. In the second example, suppose the camera's Video Resolution was previously set to 4K. If the user tries to set Video FPS to 240, it will fail because 4K/240fps is not supported. Capability Documents Documents Product Release capabilities.xlsx capabilities.json HERO10 Black v01.30.00 v01.20.00 v01.16.00 v01.10.00 Spreadsheet Format The capabilities spreadsheet contains worksheets for every supported release. Each row in a worksheet represents a whitelisted state and is presented in dependency order as outlined above. JSON Format The capabilities JSON contains a set of whitelist states for every supported release. Each state is comprised of a list of objects that contain setting and option IDs necessary to construct set-setting commands and are given in dependency order as outlined above. Below is a simplified example of the capabilities JSON file; a formal schema is also available here: capabilities_schema.json { \"(PRODUCT_NAME)\": { \"(RELEASE_VERSION)\": { \"states\": [ [ {\"setting_name\": \"(str)\", \"setting_id\": (int), \"option_name\": \"(str)\", \"option_id\": (int)}, ... ], ... ], }, ... }, ... } Query The camera provides two basic types of state information: Camera status and settings. Camera status info includes information such as the current preset/mode, whether the system is encoding, remaining sdcard space, etc. Settings info gives the currently selected option for each setting; for example, this includes the current video resolution, frame rate, digital lens (FOV), etc. Queries are sent to to GP-0076 and responses are received on GP-0077. All packets sent and received are in Big Endian. Query Format Header/Length Query Command ID Array of IDs 1-2 bytes 1 byte Variable Length Query Commands All query commands are sent to GP-0076. Responses are received on GP-0077. Note: omitting :xx:... from (un)register query commands will result in being (un)registered for all possible updates Query ID Query Request Notes 0x12 Get setting value 02:12:xx xx -&gt; Setting ID 0x12 Get all setting values 01:12 0x13 Get status value 02:13:xx xx -&gt; status code 0x13 Get all status values 01:13 0x52 Register for setting updates nn:52:xx:... nn -&gt; message length xx -&gt; setting id 0x53 Register for status updates nn:53:xx:... nn -&gt; message length xx -&gt; status code 0x72 Unregister for setting updates nn:72:xx:... nn -&gt; message length xx -&gt; setting id 0x73 Unregister for status updates nn:73:xx:... nn -&gt; message length xx -&gt; status code Query Response Format Query responses are pushed asynchronously in the following scenarios: The user queries for current status/settings The user registers for settings/status updates The user is registered to receive updates for a status/setting and the value changes Message Length Query ID Command Status Status ID Status Value Length Status Value 1-2 bytes 1 byte 1 byte 1 byte 1 byte 1-255 bytes Multi-Value Responses When querying for or receiving a push notifications about more than one setting/status, the Status ID, Status Value Length, and Status Value fields become collectively repeatable. Example: [MESSAGE LENGTH]:[QUERY ID]:[COMMAND STATUS]:[ID1]:[LENGTH1]:[VALUE1]:[ID2]:[LENGTH2]:[VALUE2]:... Push Notification Responses The Query ID for settings/status push notifications replaces the upper 4 bits with 1001 (nine). For example, if the original query comand ID was 0x52, the query ID of the push notification will be 0x92. Status Codes Below is a table of supported status codes. ✔ Indicates support for all Open GoPro firmware versions. ❌ Indicates a lack of support for all Open GoPro firmware versions. &gt;= vXX.YY.ZZ indicates support for firmware versions equal to or newer than vXX.YY.ZZ Status ID Name Description Type Values HERO10 Black 1 Internal battery present Is the system's internal battery present? boolean 0: False 1: True ✔ 2 Internal battery level Rough approximation of internal battery level in bars integer 0: Zero 1: One 2: Two 3: Three ✔ 3 External battery present Is an external battery connected? boolean 0: False 1: True ✔ 4 External battery level External battery power level in percent percent 0-100 ✔ 6 System hot Is the system currently overheating? boolean 0: False 1: True ✔ 8 System busy Is the camera busy? boolean 0: False 1: True ✔ 9 Quick capture active Is Quick Capture feature enabled? boolean 0: False 1: True ✔ 10 Encoding active Is the system encoding right now? boolean 0: False 1: True ✔ 11 Lcd lock active Is LCD lock active? boolean 0: False 1: True ✔ 13 Video progress counter When encoding video, this is the duration (seconds) of the video so far; 0 otherwise integer * ✔ 17 Enable Are Wireless Connections enabled? boolean 0: False 1: True ✔ 19 State The pairing state of the camera integer 0: Success 1: In Progress 2: Failed 3: Stopped ✔ 20 Type The last type of pairing that the camera was engaged in integer 0: Not Pairing 1: Pairing App 2: Pairing Remote Control 3: Pairing Bluetooth Device ✔ 21 Pair time Time (milliseconds) since boot of last successful pairing complete action integer * ✔ 22 State State of current scan for WiFi Access Points. Appears to only change for CAH-related scans integer 0: Never started 1: Started 2: Aborted 3: Canceled 4: Completed ✔ 23 Scan time msec The time, in milliseconds since boot that the WiFi Access Point scan completed integer * ✔ 24 Provision status WiFi AP provisioning state integer 0: Never started 1: Started 2: Aborted 3: Canceled 4: Completed ✔ 26 Remote control version Wireless remote control version integer * ✔ 27 Remote control connected Is a wireless remote control connected? boolean 0: False 1: True ✔ 28 Pairing Wireless Pairing State integer * ✔ 29 Wlan ssid Provisioned WIFI AP SSID. On BLE connection, value is big-endian byte-encoded int string * ✔ 30 Ap ssid Camera's WIFI SSID. On BLE connection, value is big-endian byte-encoded int string * ✔ 31 App count The number of wireless devices connected to the camera integer * ✔ 32 Enable Is Preview Stream enabled? boolean 0: False 1: True ✔ 33 Sd status Primary Storage Status integer -1: Unknown 0: OK 1: SD Card Full 2: SD Card Removed 3: SD Card Format Error 4: SD Card Busy 8: SD Card Swapped ✔ 34 Remaining photos How many photos can be taken before sdcard is full integer * ✔ 35 Remaining video time How many minutes of video can be captured with current settings before sdcard is full integer * ✔ 36 Num group photos How many group photos can be taken with current settings before sdcard is full integer * ✔ 37 Num group videos Total number of group videos on sdcard integer * ✔ 38 Num total photos Total number of photos on sdcard integer * ✔ 39 Num total videos Total number of videos on sdcard integer * ✔ 41 Ota status The current status of Over The Air (OTA) update integer 0: Idle 1: Downloading 2: Verifying 3: Download Failed 4: Verify Failed 5: Ready 6: GoPro App: Downloading 7: GoPro App: Verifying 8: GoPro App: Download Failed 9: GoPro App: Verify Failed 10: GoPro App: Ready ✔ 42 Download cancel request pending Is there a pending request to cancel a firmware update download? boolean 0: False 1: True ✔ 45 Camera locate active Is locate camera feature active? boolean 0: False 1: True ✔ 49 Multi shot count down The current timelapse interval countdown value (e.g. 5...4...3...2...1...) integer * ✔ 54 Remaining space Remaining space on the sdcard in Kilobytes integer * ✔ 55 Supported Is preview stream supported in current recording/flatmode/secondary-stream? boolean 0: False 1: True ✔ 56 Wifi bars WiFi signal strength in bars integer * ✔ 58 Num hilights The number of hilights in encoding video (set to 0 when encoding stops) integer * ✔ 59 Last hilight time msec Time since boot (msec) of most recent hilight in encoding video (set to 0 when encoding stops) integer * ✔ 60 Next poll msec The min time between camera status updates (msec). Do not poll for status more often than this integer * ✔ 64 Remaining timelapse time How many min of Timelapse video can be captured with current settings before sdcard is full integer * ✔ 65 Exposure select type Liveview Exposure Select Mode integer 0: Disabled 1: Auto 2: ISO Lock 3: Hemisphere ✔ 66 Exposure select x Liveview Exposure Select: y-coordinate (percent) percent 0-100 ✔ 67 Exposure select y Liveview Exposure Select: y-coordinate (percent) percent 0-100 ✔ 68 Gps status Does the camera currently have a GPS lock? boolean 0: False 1: True ✔ 69 Ap state Is the WiFi radio enabled? boolean 0: False 1: True ✔ 70 Internal battery percentage Internal battery level (percent) percent 0-100 ✔ 74 Acc mic status Microphone Accesstory status integer 0: Microphone mod not connected 1: Microphone mod connected 2: Microphone mod connected and microphone plugged into Microphone mod ✔ 75 Digital zoom Digital Zoom level (percent) percent 0-100 ✔ 76 Wireless band Wireless Band integer 0: 2.4 GHz 1: 5 GHz 2: Max ✔ 77 Digital zoom active Is Digital Zoom feature available? boolean 0: False 1: True ✔ 78 Mobile friendly video Are current video settings mobile friendly? (related to video compression and frame rate) boolean 0: False 1: True ✔ 79 First time use Is the camera currently in First Time Use (FTU) UI flow? boolean 0: False 1: True ✔ 81 Band 5ghz avail Is 5GHz wireless band available? boolean 0: False 1: True ✔ 82 System ready Is the system ready to accept commands? boolean 0: False 1: True ✔ 83 Batt okay for ota Is the internal battery charged sufficiently to start Over The Air (OTA) update? boolean 0: False 1: True ✔ 85 Video low temp alert Is the camera getting too cold to continue recording? boolean 0: False 1: True ✔ 86 Actual orientation The rotational orientation of the camera integer 0: 0 degrees (upright) 1: 180 degrees (upside down) 2: 90 degrees (laying on right side) 3: 270 degrees (laying on left side) ✔ 88 Zoom while encoding Is this camera capable of zooming while encoding (static value based on model, not settings) boolean 0: False 1: True ✔ 89 Current mode Current flatmode ID integer * ✔ 91 Logs ready Are system logs ready to be downloaded? boolean 0: False 1: True ✔ 93 Active video presets Current Video Preset (ID) integer * ✔ 94 Active photo presets Current Photo Preset (ID) integer * ✔ 95 Active timelapse presets Current Timelapse Preset (ID) integer * ✔ 96 Active presets group Current Preset Group (ID) integer * ✔ 97 Active preset Current Preset (ID) integer * ✔ 98 Preset modified Preset Modified Status, which contains an event ID and a preset (group) ID integer * ✔ 99 Remaining live bursts How many Live Bursts can be captured before sdcard is full integer * ✔ 100 Num total live bursts Total number of Live Bursts on sdcard integer * ✔ 101 Capture delay active Is Capture Delay currently active (i.e. counting down)? boolean 0: False 1: True ✔ 102 Media mod mic status Media mod State integer 0: Media mod microphone removed 2: Media mod microphone only 3: Media mod microphone with external microphone ✔ 103 Timewarp speed ramp active Time Warp Speed integer 0: 15x 1: 30x 2: 60x 3: 150x 4: 300x 5: 900x 6: 1800x 7: 2x 8: 5x 9: 10x 10: Auto 11: 1x (realtime) 12: 1/2x (slow-motion) ✔ 104 Linux core active Is the system's Linux core active? boolean 0: False 1: True ✔ 105 Camera lens type Camera lens type (reflects changes to setting 162) integer 0: Default 1: Max Lens ✔ 106 Video hindsight capture active Is Video Hindsight Capture Active? boolean 0: False 1: True ✔ 107 Scheduled preset Scheduled Capture Preset ID integer * ✔ 108 Scheduled enabled Is Scheduled Capture set? boolean 0: False 1: True ✔ 109 Creating preset Is the camera in the process of creating a custom preset? boolean 0: False 1: True ✔ 110 Media mod status Media Mode Status (bitmasked) integer 0: Display (selfie) mod: 0, HDMI: 0, Media Mod Connected: False 1: Display (selfie) mod: 0, HDMI: 0, Media Mod Connected: True 2: Display (selfie) mod: 0, HDMI: 1, Media Mod Connected: False 3: Display (selfie) mod: 0, HDMI: 1, Media Mod Connected: True 4: Display (selfie) mod: 1, HDMI: 0, Media Mod Connected: False 5: Display (selfie) mod: 1, HDMI: 0, Media Mod Connected: True 6: Display (selfie) mod: 1, HDMI: 1, Media Mod Connected: False 7: Display (selfie) mod: 1, HDMI: 1, Media Mod Connected: True ✔ 111 Sd rating check error Does sdcard meet specified minimum write speed? boolean 0: False 1: True ✔ 112 Sd write speed error Number of sdcard write speed errors since device booted integer * ✔ 113 Turbo transfer Is Turbo Transfer active? boolean 0: False 1: True ✔ 114 Camera control status Camera control status ID integer 0: Camera Idle: No one is attempting to change camera settings 1: Camera Control: Camera is in a menu or changing settings. To intervene, app must request control 2: Camera External Control: An outside entity (app) has control and is in a menu or modifying settings ✔ 115 Usb connected Is the camera connected to a PC via USB? boolean 0: False 1: True ✔ 116 Allow control over usb Camera control over USB state integer 0: Disabled 1: Enabled \\&gt;= v01.30.00 Protobuf In order to maximize BLE bandwidth, some messages and their corresponding notifications utilize Google Protobuf (Protocol Buffers). Protobuf Message Format Protobuf communications with the camera differ from TLV-style communications. Rather than having a Type, Length, and Value, GoPro protobuf messages utilize the following: Feature: Indicates command type (e.g. command, setting, query) Action: Specific camera action; value indicates whether message was sent or an (aync) notification was received Value: Serialized protobuf object Requests Sent Message Length Feature ID Action ID Protobuf Bytestream 1-2 bytes 1 byte 1 byte Variable Length Notifications Received Message Length Feature ID Response Action ID Protobuf Bytestream 1-2 bytes 1 byte 1 byte Variable Length Protobuf UUIDs Below is a map of Protobuf Feature IDs and the characteristics used to write/notify. For additional details, see Services and Characteristics. Feature Feature ID UUID Response UUID Command 0xF1 GP-0072 GP-0073 Settings 0xF3 GP-0074 GP-0075 Query 0xF5 GP-0076 GP-0077 Protobuf Commands Below is a table of protobuf commands that can be sent to the camera and their expected response. ✔ Indicates support for all Open GoPro firmware versions. ❌ Indicates a lack of support for all Open GoPro firmware versions. &gt;= vXX.YY.ZZ indicates support for firmware versions equal to or newer than vXX.YY.ZZ Feature ID Action ID Response Action ID Description Request Response HERO10 Black 0xF1 0x69 0xE9 Request set camera control status RequestSetCameraControlStatus ResponseGeneric \\&gt;= v01.20.00 0x6B 0xEB Request set turbo active RequestSetTurboActive ResponseGeneric ✔ 0xF5 0x72 0xF2 Request get preset status RequestGetPresetStatus NotifyPresetStatus ✔ 0xF3 Async status update NotifyPresetStatus ✔ Protobuf Command Details Below are additional details about specific protobuf commands: RequestSetCameraControlStatus As part of the Global Behaviors feature, this command is used to tell the camera that the app (i.e. External Control) wants to be in control, which causes the camera to immediately exit any contextual menus and return to the idle screen. Developers can query who is currently claiming control of the camera from camera status 114. Developers can query whether the camera is currently in a contextual menu from camera status 63. When the user interacts with the camera UI, the camera reclaims control and updates camera status to Control. When the user returns the camera UI to the idle screen, the camera updates camera status to Idle. RequestSetTurboActive Turbo Transfer Mode is a special feature that serves two purposes: Temporarily modify low-level settings in the OS to prioritize WiFi offload speeds Put up a UI on the camera indicating that media is being transferred and preventing the user from inadvertently changing settings or capturing new media Developers can query whether the camera is currently in Turbo Transfer Mode from camera status 113. While in Turbo Transfer Mode, if the user presses the Mode/Power or Shutter buttons on the camera, Turbo Transfer Mode will be deactivated. Some cameras are already optimized for WiFi transfer and do not gain additional speed from this feature. RequestGetPresetStatus This command serves two purposes: Describe which Preset Groups and Presets the camera supports in its current state (Un)register to be notified when a Preset is modified (e.g. resolution changes from 1080p to 4K) or a Preset Group is modified (e.g. presets are reordered/create/deleted) Each Preset Group contains an ID, whether additional presets can be added, and an array of existing Presets. Each Preset contains information about its ID, associated flatmode, title, icon, whether it's a user-defined preset, whether the preset has been modified from its factory-default state (for factory-default presets only) and a list of settings associated with the Preset. Preset Status should not be confused with camera status, which contains hundreds of camera/setting statuses on a system level.",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/ble_2_0#"
        },
        {
            "title": "Demos: ",
            "excerpt": "C C++ GoPro C/C++ Demos Two C / C++ demos to send media commands and start/stop the preview stream Csharp GoProCSharpSample A C demo for discovering, pairing, connecting and controlling a camera CSharp Webcam Demo A C demo to demonstrate webcam functionality Ionic Go Pro demo Ionic + Capacitor 3 Ionic demo for transfering files from GoPro to Mobile over Wi-Fi here are demos for iOS &amp; Android Python Open GoPro Python SDK A Python package to easily exercise the Open GoPro APIs + CLIs for taking pictures, videos, etc Swift Swift Enable WiFi Demo A swift demo for discovering, connecting and enabling Wi-Fi on a GoPro camera",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/demos#"
        },
        {
            "title": "Frequently Asked Questions: ",
            "excerpt": "If you have somehow stumbled here first, note that there are specifications, demos, and tutorials which expand upon much of the information here. These can be found, among other places, from the home page. Connectivity What is the distance from the camera that BLE will still work? It is standard Bluetooth 4.0 range and it depends on external factors such as: Interference: anything interfering with the signal will shorten the range. The type of device that the camera is connected to: BT classification distinguishes 3 device classes based on their power levels. Depending on the class of the connected device, the range varies from less than 10 meters to 100 meters. Can I connect using WiFi only? Theoretically yes, if you already know the SSID, password, and the camera’s WiFi AP has been enabled. However, practically no because BLE is required in order to discover this information and configure the AP. Can I connect using BLE only? Yes, however there is some functionality that is not possible over BLE such as accessing the media list and downloading files. How many devices can connect to the camera? Simultaneously, only one device can connect at a time. However, the camera stores BLE security keys and other connection information so it is possible to connect multiple devices sequentially. General Is preview turned off during record for all video settings? Yes, preview is disabled during record on all video settings. How can I view the live stream? In VLC, for example, you need to open network stream udp://@0.0.0.0:8554. You may see some latency due to VLC caching. See the Preview Stream tutorial for more information. Troubleshooting If you are able to consistently reproduce a problem, please file a bug on Github Issues Why isn’t the camera advertising? If you have not yet paired to the camera with the desired device, then you need to first set the camera into pairing mode (Connections-&gt;Connect Device-&gt;Quick App). If you have already paired, then the camera should be advertising and ready to connect. If it is not advertising, it is possible you are already connected to it from a previous session. To be sure, power cycle both the camera and the peer device.",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/faq#"
        },
        {
            "title": "HTTP Specifications: ",
            "excerpt": "This page will provide links to each version of the Open GoPro HTTP specification, as well as an overview of the changes from the previous version. Click on an individual spec to see its complete information including possible commands, settings, etc. Since the Open GoPro API varies based on the version, it is necessary to query the Open GoPro version using the Get Version command upon connection Versions HTTP Specification 2.0 Hilights: Capture media Track camera state Get media list and download files / metadata Load / edit presets Configure and use as webcam Add / remove hilights Breaking changes: Settings endpoint has changed to: gopro/camera/setting?setting={setting}&amp;option={option} See the quick reference for more information Video Digital Lens setting parameter changes: Narrow changed from 6 to 2 Photo Digital Lens setting parameter changes: Wide changed from 22 to 101 Linear changed from 23 to 102 Narrow changed from 24 to 19 Max Superview changed from 25 to 100 Multishot Digital Lens parameter changes: Wide changed from 2 to 101 Narrow changed from 24 to 19 HTTP Specification 1.0 Initial API",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/http#"
        },
        {
            "title": "HTTP Specification v1.0: ",
            "excerpt": "Overview The GoPro API allows developers to create apps and utilities that interact with and control a GoPro camera. What can you do with GoPro API? The GoPro API allows you to control and query the camera: Capture photo/video media Get media list Change settings Set date/time Get camera status Get media metadata (file size, width, height, duration, tags, etc) and more! Supported Cameras Below is a table of cameras that support GoPro's public REST API: ID Model Marketing Name Minimal Firmware Version 55 HD9.01 HERO9 Black v1.60 The Basics Turning on Camera WiFi Access Point In order to maximize the battery life of the camera, the camera's WiFi AP is turned off by default. Turning on the WiFi AP requires connecting to the camera via Bluetooth Low Energy (BLE) and sending an AP Control command. Authentication Once the WiFi Access Point has been turned on, authentication with the camera simply requries connecting with the correct SSID and password. This information is available in the camera UI by putting the camera into pairing mode and tapping the \"i\" in the top-right corner of the screen. Additionally, when the camera is in pairing mode, the SSID and password can be read directly via Bluetooth Low Energy. See Services and Characteristics in BLE documentation for details. Request and Response Formats The camera will respond to REST commands and queries according to the table below. Most commands are sent via HTTP/GET and require no special HTTP headers. Responses come in two parts: The standard HTTP return codes and JSON containing any additional information. Typically, when the camera accepts a command and begins to (asynchronously) work on it, it will return HTTP 200 (OK) and empty JSON (i.e. { }) to indicate success. If an error occurs, the camera will return a standard HTTP error code and JSON with helpful error/debug information. Protocol Address Port Base URL WiFi 10.5.5.9 8080 http://10.5.5.9:8080 Depending on the command sent, the camera can return JSON, binary, or Protobuf data. Get Camera State -&gt; JSON Get Media Info -&gt; JSON Get Media GPMF -&gt; Binary Get Media List -&gt; JSON Get Media Screennail (JPEG) -&gt; Binary Get Media Thumbnail (JPEG) -&gt; Binary Get Presets -&gt; JSON Sending Commands Depending on the camera's state, it may not be ready to accept some commands. This ready state is dependent on the System Busy and the Encoding Active status flags. For example: System Busy flag is set while loading presets, changing settings, formatting sdcard, ... Encoding Active flag is set while capturing photo/video media If the system is not ready, it should reject an incoming command; however, best practice is to always wait for the System Busy and Encode Active flags to go down before sending messages other than queries to get camera status. For details regarding camera state, see Camera Status Codes. Presets Presets were first added to the GoPro product line with the release of HERO8 Black. A preset represents a targeted camera state; for example, the built-in \"Activity\" preset is useful for capturing video with lots of quick motion while \"Cinematic\" is good for third-person and follow style shots. Each preset is associated with: A preset group (i.e. Video, Photo, Time Lapse) A camera mode (e.g. Video, Photo, Time Warp, ...) An icon A title A collection of settings specific to the preset (e.g. Resolution, Frame Rate and Digital Lens for video presets) Different collections of presets will be available depending on the current camera state. For example: Cameras that support Max Lens have special presets that are only available to load when Max Lens Mod is enabled (see Settings Quick Reference for details) Limitations HERO9 Black The HTTP server is not available while the camera is encoding, which means shutter controls are not supported over WiFi. This limitation can be overcome by using Bluetooth Low Energy for command and control and HTTP/REST for quering media content such as media list, media info, preview stream, etc. General Unless changed by the user, GoPro cameras will automatically power off after some time (e.g. 5min, 15min, 30min). The Auto Power Down watchdog timer can be reset by sending periodic keep-alive messages to the camera. It is recommended to send a keep-alive at least once every 120 seconds. In general, querying the value for a setting that is not associated with the current preset/flatmode results in an undefined value. For example, the user should not try to query the current Photo Digital Lenses (FOV) value while in Standard preset (Video flatmode). Commands Using the Open GoPro API, a client can perform various command, control, and query operations! Commands Quick Reference Below is a table of commands that can be sent to the camera and how to send them. Command Description HTTP Method Endpoint HERO9 Black Camera: Digital Zoom Digital zoom 50% GET /gopro/camera/digital_zoom?percent=50 Y Camera: Get State Get camera state (status + settings) GET /gopro/camera/state Y Keep-alive Send keep-alive GET /gopro/camera/keep_alive Y Media: GPMF Get GPMF data (MP4) GET /gopro/media/gpmf?path=100GOPRO/XXX.MP4 Y Media: GPMF Get GPMF data (JPG) GET /gopro/media/gpmf?path=100GOPRO/XXX.JPG Y Media: Info Get media info (MP4) GET /gopro/media/info?path=100GOPRO/XXX.MP4 Y Media: Info Get media info (JPG) GET /gopro/media/info?path=100GOPRO/XXX.JPG Y Media: List Get media list GET /gopro/media/list Y Media: Screennail Get screennail for \"100GOPRO/xxx.MP4\" GET /gopro/media/screennail?path=100GOPRO/XXX.MP4 Y Media: Screennail Get screennail for \"100GOPRO/xxx.JPG\" GET /gopro/media/screennail?path=100GOPRO/XXX.JPG Y Media: Telemetry Get telemetry track data (MP4) GET /gopro/media/telemetry?path=100GOPRO/XXX.MP4 Y Media: Telemetry Get telemetry track data (JPG) GET /gopro/media/telemetry?path=100GOPRO/XXX.JPG Y Media: Thumbnail Get thumbnail for \"100GOPRO/xxx.MP4\" GET /gopro/media/thumbnail?path=100GOPRO/XXX.MP4 Y Media: Thumbnail Get thumbnail for \"100GOPRO/xxx.JPG\" GET /gopro/media/thumbnail?path=100GOPRO/XXX.JPG Y Media: Turbo Transfer Turbo transfer: on GET /gopro/media/turbo_transfer?p=1 Y Media: Turbo Transfer Turbo transfer: off GET /gopro/media/turbo_transfer?p=0 Y Open GoPro Get version GET /gopro/version Y Presets: Get Status Get preset status GET /gopro/camera/presets/get Y Presets: Load Activity GET /gopro/camera/presets/load?id=1 Y Presets: Load Burst Photo GET /gopro/camera/presets/load?id=65538 Y Presets: Load Cinematic GET /gopro/camera/presets/load?id=2 Y Presets: Load Live Burst GET /gopro/camera/presets/load?id=65537 Y Presets: Load Night Photo GET /gopro/camera/presets/load?id=65539 Y Presets: Load Night Lapse GET /gopro/camera/presets/load?id=131074 Y Presets: Load Photo GET /gopro/camera/presets/load?id=65536 Y Presets: Load Slo-Mo GET /gopro/camera/presets/load?id=3 Y Presets: Load Standard GET /gopro/camera/presets/load?id=0 Y Presets: Load Time Lapse GET /gopro/camera/presets/load?id=131073 Y Presets: Load Time Warp GET /gopro/camera/presets/load?id=131072 Y Presets: Load Max Photo GET /gopro/camera/presets/load?id=262144 Y Presets: Load Max Timewarp GET /gopro/camera/presets/load?id=327680 Y Presets: Load Max Video GET /gopro/camera/presets/load?id=196608 Y Presets: Load Group Video GET /gopro/camera/presets/set_group?id=1000 Y Presets: Load Group Photo GET /gopro/camera/presets/set_group?id=1001 Y Presets: Load Group Timelapse GET /gopro/camera/presets/set_group?id=1002 Y Stream: Start Start preview stream GET /gopro/camera/stream/start Y Stream: Stop Stop preview stream GET /gopro/camera/stream/stop Y Settings GoPro cameras have hundreds of setting options to choose from, all of which can be set using a single endpoint. The endpoint is configured with a setting id and an option value. Note that setting option values are not globally unique. While most option values are enumerated values, some are complex bitmasked values. Settings Quick Reference Below is a table of setting options detailing how to set every option supported by Open GoPro cameras. Setting ID Setting Option HTTP Method Endpoint HERO9 Black 2 Resolution Set video resolution (id: 2) to 4k (value: 1) GET /gopro/camera/setting?setting_id=2&amp;opt_value=1 Y 2 Resolution Set video resolution (id: 2) to 2.7k (value: 4) GET /gopro/camera/setting?setting_id=2&amp;opt_value=4 Y 2 Resolution Set video resolution (id: 2) to 2.7k 4:3 (value: 6) GET /gopro/camera/setting?setting_id=2&amp;opt_value=6 Y 2 Resolution Set video resolution (id: 2) to 1440 (value: 7) GET /gopro/camera/setting?setting_id=2&amp;opt_value=7 Y 2 Resolution Set video resolution (id: 2) to 1080 (value: 9) GET /gopro/camera/setting?setting_id=2&amp;opt_value=9 Y 2 Resolution Set video resolution (id: 2) to 4k 4:3 (value: 18) GET /gopro/camera/setting?setting_id=2&amp;opt_value=18 Y 2 Resolution Set video resolution (id: 2) to 5k (value: 24) GET /gopro/camera/setting?setting_id=2&amp;opt_value=24 Y 3 Frames Per Second Set video fps (id: 3) to 240 (value: 0) GET /gopro/camera/setting?setting_id=3&amp;opt_value=0 Y 3 Frames Per Second Set video fps (id: 3) to 120 (value: 1) GET /gopro/camera/setting?setting_id=3&amp;opt_value=1 Y 3 Frames Per Second Set video fps (id: 3) to 100 (value: 2) GET /gopro/camera/setting?setting_id=3&amp;opt_value=2 Y 3 Frames Per Second Set video fps (id: 3) to 60 (value: 5) GET /gopro/camera/setting?setting_id=3&amp;opt_value=5 Y 3 Frames Per Second Set video fps (id: 3) to 50 (value: 6) GET /gopro/camera/setting?setting_id=3&amp;opt_value=6 Y 3 Frames Per Second Set video fps (id: 3) to 30 (value: 8) GET /gopro/camera/setting?setting_id=3&amp;opt_value=8 Y 3 Frames Per Second Set video fps (id: 3) to 25 (value: 9) GET /gopro/camera/setting?setting_id=3&amp;opt_value=9 Y 3 Frames Per Second Set video fps (id: 3) to 24 (value: 10) GET /gopro/camera/setting?setting_id=3&amp;opt_value=10 Y 3 Frames Per Second Set video fps (id: 3) to 200 (value: 13) GET /gopro/camera/setting?setting_id=3&amp;opt_value=13 Y 59 Auto Off Set setup auto power down (id: 59) to never (value: 0) GET /gopro/camera/setting?setting_id=59&amp;opt_value=0 Y 59 Auto Off Set setup auto power down (id: 59) to 5 min (value: 4) GET /gopro/camera/setting?setting_id=59&amp;opt_value=4 Y 59 Auto Off Set setup auto power down (id: 59) to 15 min (value: 6) GET /gopro/camera/setting?setting_id=59&amp;opt_value=6 Y 59 Auto Off Set setup auto power down (id: 59) to 30 min (value: 7) GET /gopro/camera/setting?setting_id=59&amp;opt_value=7 Y 121 Lens Set video digital lenses (id: 121) to wide (value: 0) GET /gopro/camera/setting?setting_id=121&amp;opt_value=0 Y 121 Lens Set video digital lenses (id: 121) to narrow (value: 6) GET /gopro/camera/setting?setting_id=121&amp;opt_value=6 Y 121 Lens Set video digital lenses (id: 121) to superview (value: 3) GET /gopro/camera/setting?setting_id=121&amp;opt_value=3 Y 121 Lens Set video digital lenses (id: 121) to linear (value: 4) GET /gopro/camera/setting?setting_id=121&amp;opt_value=4 Y 121 Lens Set video digital lenses (id: 121) to max superview (value: 7) GET /gopro/camera/setting?setting_id=121&amp;opt_value=7 Y 121 Lens Set video digital lenses (id: 121) to linear + horizon leveling (value: 8) GET /gopro/camera/setting?setting_id=121&amp;opt_value=8 Y 122 Lens Set photo digital lenses (id: 122) to narrow (value: 24) GET /gopro/camera/setting?setting_id=122&amp;opt_value=24 Y 122 Lens Set photo digital lenses (id: 122) to max superview (value: 25) GET /gopro/camera/setting?setting_id=122&amp;opt_value=25 Y 122 Lens Set photo digital lenses (id: 122) to wide (value: 22) GET /gopro/camera/setting?setting_id=122&amp;opt_value=22 Y 122 Lens Set photo digital lenses (id: 122) to linear (value: 23) GET /gopro/camera/setting?setting_id=122&amp;opt_value=23 Y 123 Lens Set multi shot digital lenses (id: 123) to narrow (value: 24) GET /gopro/camera/setting?setting_id=123&amp;opt_value=24 Y 123 Lens Set multi shot digital lenses (id: 123) to wide (value: 22) GET /gopro/camera/setting?setting_id=123&amp;opt_value=22 Y 123 Lens Set multi shot digital lenses (id: 123) to linear (value: 23) GET /gopro/camera/setting?setting_id=123&amp;opt_value=23 Y 162 Max Lens Mod Enable Set mods max lens enable (id: 162) to off (value: 0) GET /gopro/camera/setting?setting_id=162&amp;opt_value=0 Y 162 Max Lens Mod Enable Set mods max lens enable (id: 162) to on (value: 1) GET /gopro/camera/setting?setting_id=162&amp;opt_value=1 Y Camera Capabilities Below are tables detailing supported features for Open GoPro cameras. HERO9 Black Resolution Anti-Flicker Frames Per Second Lens 1080 50Hz 24 Wide Superview Linear Narrow Linear + Horizon Leveling 25 Wide Superview Linear Narrow Linear + Horizon Leveling 50 Wide Superview Linear Narrow Linear + Horizon Leveling 100 Wide Superview Linear Narrow Linear + Horizon Leveling 200 Wide Linear Narrow Linear + Horizon Leveling 60Hz 24 Wide Superview Linear Narrow Linear + Horizon Leveling 30 Wide Superview Linear Narrow Linear + Horizon Leveling 60 Wide Superview Linear Narrow Linear + Horizon Leveling 120 Wide Superview Linear Narrow Linear + Horizon Leveling 240 Wide Linear Narrow Linear + Horizon Leveling 1440 50Hz 24 Wide Linear Narrow Linear + Horizon Leveling 25 Wide Linear Narrow Linear + Horizon Leveling 50 Wide Linear Narrow Linear + Horizon Leveling 100 Wide Linear Narrow Linear + Horizon Leveling 60Hz 24 Wide Linear Narrow Linear + Horizon Leveling 30 Wide Linear Narrow Linear + Horizon Leveling 60 Wide Linear Narrow Linear + Horizon Leveling 120 Wide Linear Narrow Linear + Horizon Leveling 2.7K 50Hz 50 Wide Superview Linear Narrow Linear + Horizon Leveling 100 Wide Linear Narrow Linear + Horizon Leveling 60Hz 60 Wide Superview Linear Narrow Linear + Horizon Leveling 120 Wide Linear Narrow Linear + Horizon Leveling 2.7K 4:3 50Hz 50 Wide Linear Narrow Linear + Horizon Leveling 60Hz 60 Wide Linear Narrow Linear + Horizon Leveling 4K 50Hz 24 Wide Superview Linear Narrow Linear + Horizon Leveling 25 Wide Superview Linear Narrow Linear + Horizon Leveling 50 Wide Linear Narrow Linear + Horizon Leveling 60Hz 24 Wide Superview Linear Narrow Linear + Horizon Leveling 30 Wide Superview Linear Narrow Linear + Horizon Leveling 60 Wide Linear Narrow Linear + Horizon Leveling 4K 4:3 50Hz 24 Wide Linear Narrow Linear + Horizon Leveling 25 Wide Linear Narrow Linear + Horizon Leveling 60Hz 24 Wide Linear Narrow Linear + Horizon Leveling 30 Wide Linear Narrow Linear + Horizon Leveling 5K 50Hz 24 Wide Linear Narrow Linear + Horizon Leveling 25 Wide Linear Narrow Linear + Horizon Leveling 60Hz 24 Wide Linear Narrow Linear + Horizon Leveling 30 Wide Linear Narrow Linear + Horizon Leveling Media The camera provides an endpoint to query basic details about media captured on the sdcard. Chapters All GoPro cameras break longer videos into chapters. GoPro cameras currently limit file sizes on sdcards to 4GB for both FAT32 and exFAT file systems. This limitation is most commonly seen when recording longer (10+ minute) videos. In practice, the camera will split video media into chapters named Gqccmmmm.MP4 (and ones for THM/LRV) such that: q: Quality Level (X: Extreme, H: High, M: Medium, L: Low) cc: Chapter Number (01-99) mmmm: Media ID (0001-9999) When media becomes chaptered, the camera increments subsequent Chapter Numbers while leaving the Media ID unchanged. For example, if the user records a long High-quality video that results in 4 chapters, the files on the sdcard may look like the following: -rwxrwxrwx@ 1 gopro 123456789 4006413091 Jan 1 00:00 GH010078.MP4 -rwxrwxrwx@ 1 gopro 123456789 17663 Jan 1 00:00 GH010078.THM -rwxrwxrwx@ 1 gopro 123456789 4006001541 Jan 1 00:00 GH020078.MP4 -rwxrwxrwx@ 1 gopro 123456789 17357 Jan 1 00:00 GH020078.THM -rwxrwxrwx@ 1 gopro 123456789 4006041985 Jan 1 00:00 GH030078.MP4 -rwxrwxrwx@ 1 gopro 123456789 17204 Jan 1 00:00 GH030078.THM -rwxrwxrwx@ 1 gopro 123456789 756706872 Jan 1 00:00 GH040078.MP4 -rwxrwxrwx@ 1 gopro 123456789 17420 Jan 1 00:00 GH040078.THM -rwxrwxrwx@ 1 gopro 123456789 184526939 Jan 1 00:00 GL010078.LRV -rwxrwxrwx@ 1 gopro 123456789 184519787 Jan 1 00:00 GL020078.LRV -rwxrwxrwx@ 1 gopro 123456789 184517614 Jan 1 00:00 GL030078.LRV -rwxrwxrwx@ 1 gopro 123456789 34877660 Jan 1 00:00 GL040078.LRV Media List Format The format of the media list is given below. { \"id\": \"&lt;MEDIA SESSION ID&gt;\", \"media\": [ { \"d\": \"&lt;DIRECTORY NAME&gt;\", \"fs\": [ {&lt;MEDIA ITEM INFO&gt;}, ... ] }, ... ] } Media List Keys The outer structure of the media list and the inner structure of individual media items use the keys in the table below. Key Description b ID of first member of a group (for grouped media items) d Directory name fs File system. Contains listing of media items in directory g Group ID (if grouped media item) id Media list session identifier l ID of last member of a group (for grouped media items) ls Low resolution video file size m List of missing/deleted group member IDs (for grouped media items) media Contains media info for for each directory (e.g. 100GOPRO/, 101GOPRO/, ...) mod Last modified time (seconds since epoch) n Media filename s Size of (group) media in bytes t Group type (for grouped media items) (b -&gt; burst, c -&gt; continuous shot, n -&gt; night lapse, t -&gt; time lapse) Grouped Media Items In order to minimize the size of the JSON transmitted by the camera, grouped media items such as Burst Photos, Time Lapse Photos, Night Lapse Photos, etc are represented with a single item in the media list with additional keys that allow the user to extrapolate individual filenames for each member of the group. Filenames for group media items have the form \"GXXXYYYY.ZZZ\" where XXX is the group ID, YYY is the group member ID and ZZZ is the file extension. For example, take the media list below, which contains a Time Lapse Photo group media item: { \"id\": \"2530266050123724003\", \"media\": [ { \"d\": \"100GOPRO\", \"fs\": [ { \"b\": \"8\", \"cre\": \"1613669353\", \"g\": \"1\", \"l\": \"396\", \"m\": ['75', '139'], \"mod\": \"1613669353\", \"n\": \"G0010008.JPG\", \"s\": \"773977407\", \"t\": \"t\" } ] } ] } The first filename in the group is \"G0010008.JPG\" (key: \"n\"). The ID of the first group member in this case is \"008\" (key: \"b\"). The ID of the last group member in this case is \"396\" (key: \"l\"). The IDs of deleted members in this case are \"75\" and \"139\" (key: \"m\") Given this information, the user can extrapolate that the group currently contains G0010008.JPG, G0010009.JPG, G0010010.JPG, ..., G0010074.JPG, G0010076.JPG, ..., G0010138.JPG, G0010140.JPG, ..., G0010394.JPG, G0010395.JPG. G0010396.JPG Downloading Media The URL to download/stream media from the DCIM/ directory on the sdcard is the Base URL plus /videos/DCIM/XXX/YYY where XXX is the directory name within DCIM/ given by the media list and YYY is the target media filename. For example: Given the following media list: { \"id\": \"3586667939918700960\", \"media\": [ { \"d\": \"100GOPRO\", \"fs\": [ { \"n\": \"GH010397.MP4\", \"cre\": \"1613672729\", \"mod\": \"1613672729\", \"glrv\": \"1895626\", \"ls\": \"-1\", \"s\": \"19917136\" }, { \"cre\": \"1614340213\", \"mod\": \"1614340213\", \"n\": \"GOPR0001.JPG\", \"s\": \"6961371\" } ] } ] } The URL to download GH010397.MP4 over WiFi would be http://10.5.5.9:8080/videos/DCIM/100GOPRO/GH010397.MP4 The URL to download GOPR0001.JPG over WiFi would be http://10.5.5.9:8080/videos/DCIM/100GOPRO/GOPR0001.JPG Turbo Transfer Some cameras support Turbo Transfer mode, which allows media to be downloaded over WiFi more rapidly. This special mode should only be used during media offload. It is recommended that the user check for and--if necessary--disable Turbo Transfer on connect. For details on which cameras are supported and how to enable and disable Turbo Transfer, see Commands Quick Reference. Downloading Preview Stream When the preview stream is started, the camera starts up a UDP client and begins writing MPEG Transport Stream data to the connected client on port 8554. In order to stream and save this data, the user can implement a UDP server that binds to the same port and appends datagrams to a file when they are received. Camera State The camera provides multiple types of state, all of which can be queried: Camera state: Contains information about camera status (photos taken, date, is-camera-encoding, etc) and settings (current video resolution, current frame rate, etc) Preset State: How presets are arranged into preset groups, their titles, icons, settings closely associated with each preset, etc Camera State Format Camera state is given in the following form: { \"status\": { \"1\": &lt;status 1 value&gt;, \"2\": &lt;status 2 value&gt;, ... }, \"settings: { \"2\": &lt;setting 2 value&gt;, \"3\": &lt;setting 3 value&gt;, ... } } Where status X value and setting X value are almost always integer values. See Status Codes table in this document for exceptions. For status, keys are status codes and values are status values. For settings, keys are setting IDs, and values are option values Camera Status Codes Below is a table of supported camera status codes. Status ID Name Description Type Values 1 Internal battery present Is the system's internal battery present? boolean 0: False 1: True 2 Internal battery level Rough approximation of internal battery level in bars integer 0: Zero 1: One 2: Two 3: Three 3 External battery present Is an external battery connected? boolean 0: False 1: True 4 External battery level External battery power level in percent percent 0-100 5 Unused Unused None 6 System hot Is the system currently overheating? boolean 0: False 1: True 7 Unused Unused None 8 System busy Is the camera busy? boolean 0: False 1: True 9 Quick capture active Is Quick Capture feature enabled? boolean 0: False 1: True 10 Encoding active Is the system encoding right now? boolean 0: False 1: True 11 Lcd lock active Is LCD lock active? boolean 0: False 1: True 12 Unused Unused None 13 Video progress counter When encoding video, this is the duration (seconds) of the video so far; 0 otherwise integer * 17 Enable Are Wireless Connections enabled? boolean 0: False 1: True 18 Unused Unused * 19 State The pairing state of the camera integer 0: Success 1: In Progress 2: Failed 3: Stopped 20 Type The last type of pairing that the camera was engaged in integer 0: Not Pairing 1: Pairing App 2: Pairing Remote Control 3: Pairing Bluetooth Device 21 Pair time Time (milliseconds) since boot of last successful pairing complete action integer * 22 State State of current scan for WiFi Access Points. Appears to only change for CAH-related scans integer 0: Never started 1: Started 2: Aborted 3: Canceled 4: Completed 23 Scan time msec The time, in milliseconds since boot that the WiFi Access Point scan completed integer * 24 Provision status WiFi AP provisioning state integer 0: Never started 1: Started 2: Aborted 3: Canceled 4: Completed 25 Unused Unused None 26 Remote control version Wireless remote control version integer * 27 Remote control connected Is a wireless remote control connected? boolean 0: False 1: True 28 Pairing Wireless Pairing State integer * 29 Wlan ssid Provisioned WIFI AP SSID. On BLE connection, value is big-endian byte-encoded int string * 30 Ap ssid Camera's WIFI SSID. On BLE connection, value is big-endian byte-encoded int string * 31 App count The number of wireless devices connected to the camera integer * 32 Enable Is Preview Stream enabled? boolean 0: False 1: True 33 Sd status Primary Storage Status integer -1: Unknown 0: OK 1: SD Card Full 2: SD Card Removed 3: SD Card Format Error 4: SD Card Busy 8: SD Card Swapped 34 Remaining photos How many photos can be taken before sdcard is full integer * 35 Remaining video time How many minutes of video can be captured with current settings before sdcard is full integer * 36 Num group photos How many group photos can be taken with current settings before sdcard is full integer * 37 Num group videos Total number of group videos on sdcard integer * 38 Num total photos Total number of photos on sdcard integer * 39 Num total videos Total number of videos on sdcard integer * 40 Date time Current date/time (format: %YY%MM%DD%HH%MM%SS, all values in hex) string * 41 Ota status The current status of Over The Air (OTA) update integer 0: Idle 1: Downloading 2: Verifying 3: Download Failed 4: Verify Failed 5: Ready 6: GoPro App: Downloading 7: GoPro App: Verifying 8: GoPro App: Download Failed 9: GoPro App: Verify Failed 10: GoPro App: Ready 42 Download cancel request pending Is there a pending request to cancel a firmware update download? boolean 0: False 1: True 45 Camera locate active Is locate camera feature active? boolean 0: False 1: True 49 Multi shot count down The current timelapse interval countdown value (e.g. 5...4...3...2...1...) integer * 50 Unused Unused None 51 Unused Unused None 52 Unused Unused None 53 Unused Unused None 54 Remaining space Remaining space on the sdcard in Kilobytes integer * 55 Supported Is preview stream supported in current recording/flatmode/secondary-stream? boolean 0: False 1: True 56 Wifi bars WiFi signal strength in bars integer * 57 Current time msec System time in milliseconds since system was booted integer * 58 Num hilights The number of hilights in encoding video (set to 0 when encoding stops) integer * 59 Last hilight time msec Time since boot (msec) of most recent hilight in encoding video (set to 0 when encoding stops) integer * 60 Next poll msec The min time between camera status updates (msec). Do not poll for status more often than this integer * 63 In contextual menu Is the camera currently in a contextual menu (e.g. Preferences)? boolean 0: False 1: True 64 Remaining timelapse time How many min of Timelapse video can be captured with current settings before sdcard is full integer * 65 Exposure select type Liveview Exposure Select Mode integer 0: Disabled 1: Auto 2: ISO Lock 3: Hemisphere 66 Exposure select x Liveview Exposure Select: y-coordinate (percent) percent 0-100 67 Exposure select y Liveview Exposure Select: y-coordinate (percent) percent 0-100 68 Gps status Does the camera currently have a GPS lock? boolean 0: False 1: True 69 Ap state Is the WiFi radio enabled? boolean 0: False 1: True 70 Internal battery percentage Internal battery level (percent) percent 0-100 74 Acc mic status Microphone Accesstory status integer 0: Microphone mod not connected 1: Microphone mod connected 2: Microphone mod connected and microphone plugged into Microphone mod 75 Digital zoom Digital Zoom level (percent) percent 0-100 76 Wireless band Wireless Band integer 0: 2.4 GHz 1: 5 GHz 2: Max 77 Digital zoom active Is Digital Zoom feature available? boolean 0: False 1: True 78 Mobile friendly video Are current video settings mobile friendly? (related to video compression and frame rate) boolean 0: False 1: True 79 First time use Is the camera currently in First Time Use (FTU) UI flow? boolean 0: False 1: True 81 Band 5ghz avail Is 5GHz wireless band available? boolean 0: False 1: True 82 System ready Is the system ready to accept commands? boolean 0: False 1: True 83 Batt okay for ota Is the internal battery charged sufficiently to start Over The Air (OTA) update? boolean 0: False 1: True 85 Video low temp alert Is the camera getting too cold to continue recording? boolean 0: False 1: True 86 Actual orientation The rotational orientation of the camera integer 0: 0 degrees (upright) 1: 180 degrees (upside down) 2: 90 degrees (laying on right side) 3: 270 degrees (laying on left side) 87 Thermal mitigation mode Can camera use high resolution/fps (based on temperature)? (HERO7 Silver/White only) boolean 0: False 1: True 88 Zoom while encoding Is this camera capable of zooming while encoding (static value based on model, not settings) boolean 0: False 1: True 89 Current mode Current flatmode ID integer * 91 Logs ready Are system logs ready to be downloaded? boolean 0: False 1: True 92 Timewarp 1x active Is Timewarp 1x active? boolean 0: False 1: True 93 Active video presets Current Video Preset (ID) integer * 94 Active photo presets Current Photo Preset (ID) integer * 95 Active timelapse presets Current Timelapse Preset (ID) integer * 96 Active presets group Current Preset Group (ID) integer * 97 Active preset Current Preset (ID) integer * 98 Preset modified Preset Modified Status, which contains an event ID and a preset (group) ID integer * 99 Remaining live bursts How many Live Bursts can be captured before sdcard is full integer * 100 Num total live bursts Total number of Live Bursts on sdcard integer * 101 Capture delay active Is Capture Delay currently active (i.e. counting down)? boolean 0: False 1: True 102 Media mod mic status Media mod State integer 0: Media mod microphone removed 2: Media mod microphone only 3: Media mod microphone with external microphone 103 Timewarp speed ramp active Time Warp Speed integer 0: 15x 1: 30x 2: 60x 3: 150x 4: 300x 5: 900x 6: 1800x 7: 2x 8: 5x 9: 10x 10: Auto 11: 1x (realtime) 12: 1/2x (slow-motion) 104 Linux core active Is the system's Linux core active? boolean 0: False 1: True 105 Camera lens type Camera lens type (reflects changes to setting 162) integer 0: Default 1: Max Lens 106 Video hindsight capture active Is Video Hindsight Capture Active? boolean 0: False 1: True 107 Scheduled preset Scheduled Capture Preset ID integer * 108 Scheduled enabled Is Scheduled Capture set? boolean 0: False 1: True 109 Creating preset Is the camera in the process of creating a custom preset? boolean 0: False 1: True 110 Media mod status Media Mode Status (bitmasked) integer 0: Display (selfie) mod: 0, HDMI: 0, Media Mod Connected: False 1: Display (selfie) mod: 0, HDMI: 0, Media Mod Connected: True 2: Display (selfie) mod: 0, HDMI: 1, Media Mod Connected: False 3: Display (selfie) mod: 0, HDMI: 1, Media Mod Connected: True 4: Display (selfie) mod: 1, HDMI: 0, Media Mod Connected: False 5: Display (selfie) mod: 1, HDMI: 0, Media Mod Connected: True 6: Display (selfie) mod: 1, HDMI: 1, Media Mod Connected: False 7: Display (selfie) mod: 1, HDMI: 1, Media Mod Connected: True 113 Turbo transfer Is Turbo Transfer active? boolean 0: False 1: True Preset Status Format Preset Status is returned as JSON, whose content is the serialization of the protobuf message: NotifyPresetStatus. Using Google protobuf APIs, the JSON can be converted back into a programmatic object in the user's language of choice.",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/http_1_0#"
        },
        {
            "title": "HTTP Specification v2.0: ",
            "excerpt": "Overview The GoPro API allows developers to create apps and utilities that interact with and control a GoPro camera. What can you do with the GoPro API? The GoPro API allows you to control and query the camera: Capture photo/video media Get media list Change settings Get and set the date/time Get camera status Get media metadata (file size, width, height, duration, tags, etc) and more! Supported Cameras Below is a table of cameras that support GoPro's public HTTP API: ID Model Marketing Name Minimal Firmware Version 57 H21.01 HERO10 Black v01.10.00 The Basics Connection WiFi Connection to the camera via WiFi requires that the camera's WiFi Access Point be enabled. This can be done by connecting to the camera via Bluetooth Low Energy (BLE) and sending the AP Control command: WIFI AP ON. USB OpenGoPro systems that utilize USB must support the Network Control Model (NCM) protocol. Connecting via USB requires the following steps: Physically connect the camera's USB-C port to your system Send HTTP command to enable wired USB control Authentication WiFi Once the WiFi Access Point has been turned on, authentication with the camera simply requries connecting with the correct SSID and password. This information can be obtained in two ways: Put the camera into pairing mode and tap the info button in the top-right corner of the screen. Read the SSID/password directly via Bluetooth Low Energy. See Services and Characteristics seciton in BLE Specification for details. USB No authentication is necessary. Socket Address WiFi The socket address for WiFi connections is 10.5.5.9:8080. USB The socket address for USB connections is 172.2X.1YZ.51:8080 where: X is the 100's digit from the camera serial number Y is the 10's digit from the camera serial number Z is the 1's digit from the camera serial number The camera's serial number can be obtained in any of the following ways: Reading the sticker inside the camera's battery enclosure Camera UI: Preferences &gt;&gt; About &gt;&gt; Camera Info Bluetooth Low Energy by reading directly from Hardware Info . See Commands in BLE Specification for details. For example, if the camera's serial number is C0000123456789, the IP address for USB connections would be 172.27.189.51. Alternatively, the IP address can be discovered via mDNS as the camera registers the _gopro-web service. Request and Response Formats Most commands are sent via HTTP/GET and require no special headers. Responses come in two parts: The standard HTTP return codes and JSON containing any additional information. The typical use case is that the camera accepts a valid command, returns HTTP/200 (OK) and empty JSON (i.e. { }) and begins asynchronously working on the command. If an error occurs, the camera will return a standard HTTP error code and JSON with helpful error/debug information. Depending on the command sent, the camera can return JSON, binary, or Protobuf data. Some examples are listed below: Command Return Type Get Camera State JSON Get Media Info JSON Get Media GPMF Binary Get Media List JSON Get Media Screennail (JPEG) Binary Get Media Thumbnail (JPEG) Binary Get Presets JSON Sending Commands Depending on the camera's state, it may not be ready to accept specific commands. This ready state is dependent on the System Busy and the Encoding Active status flags. For example: System Busy flag is set while loading presets, changing settings, formatting sdcard, ... Encoding Active flag is set while capturing photo/video media If the system is not ready, it should reject an incoming command; however, best practice is to always wait for the System Busy and Encode Active flags to be unset before sending messages other than camera status queries. For details regarding camera state, see Status Codes. Features Presets The camera organizes modes of operation into presets. A preset is a logical wrapper around a specific camera flatmode and a collection of settings that target different ways of capturing media. The set of presets available to load at any moment depends on the value of certain camera settings, which are outlined in the table below. For per-preset firmware compatibility information, see Commands Quick Reference. Setting Preset Preset ID Max Lens: OFF Standard 0x00000000 Activity 0x00000001 Cinematic 0x00000002 Ultra Slo-Mo 0x00000004 Basic 0x00000005 Photo 0x00010000 Live Burst 0x00010001 Burst Photo 0x00010002 Night Photo 0x00010003 Time Warp 0x00020000 Time Lapse 0x00020001 Night Lapse 0x00020002 Max Lens: ON Max Video 0x00030000 Max Photo 0x00040000 Max Timewarp 0x00050000 Video Performance Mode: Maximum Video Performance Standard 0x00000000 Activity 0x00000001 Cinematic 0x00000002 Ultra Slo-Mo 0x00000004 Basic 0x00000005 Photo 0x00010000 Live Burst 0x00010001 Burst Photo 0x00010002 Night Photo 0x00010003 Time Warp 0x00020000 Time Lapse 0x00020001 Night Lapse 0x00020002 Video Performance Mode: Extended Battery Photo 0x00010000 Live Burst 0x00010001 Burst Photo 0x00010002 Night Photo 0x00010003 Time Warp 0x00020000 Time Lapse 0x00020001 Night Lapse 0x00020002 Standard [EB] 0x00080000 Activity [EB] 0x00080001 Cinematic [EB] 0x00080002 Slo-Mo [EB] 0x00080003 Video Performance Mode: Tripod / Stationary Video Photo 0x00010000 Live Burst 0x00010001 Burst Photo 0x00010002 Night Photo 0x00010003 Time Warp 0x00020000 Time Lapse 0x00020001 Night Lapse 0x00020002 4K Tripod 0x00090000 5.3K Tripod 0x00090001 Global Behaviors In order to prevent undefined behavior between the camera and a connected app, simultaneous use of the camera and a connected app is discouraged. Best practice for synchronizing user/app control is to use the Set Camera Control Status command and corresponding Camera Control Status (CCS) camera statuses in alignment with the finite state machine below: Limitations HERO10 Black The camera will reject requests to change settings while encoding; for example, if Hindsight feature is active, the user cannot change settings General Unless changed by the user, GoPro cameras will automatically power off after some time (e.g. 5min, 15min, 30min). The Auto Power Down watchdog timer can be reset by sending periodic keep-alive messages to the camera. It is recommended to send a keep-alive at least once every 120 seconds. In general, querying the value for a setting that is not associated with the current preset/flatmode results in an undefined value. For example, the user should not try to query the current Photo Digital Lenses (FOV) value while in Standard preset (Video flatmode). USB command and control is not supported on HERO9 Black. Webcam The webcam feature enables developers who are interested in writing custom drivers to make the camera broadcast its video preview with a limited set of resolution and field of view options. While active, the webcam feature runs a UDP client that sends raw Transport Stream data to the connected client on port 8554. To test basic functionality, connect the camera to your system, start the webcam, and use an application such as VLC to start a network stream on udp://@0.0.0.0:8554. For readers interested in using a GoPro camera as a webcam with preexisting tools, please see How to use GoPro as a Webcam. Webcam Finite State Machine Webcam Commands For details about how to send webcam commands, see Commands Quick Reference. Command Connections Description Webcam: Start USB Enters webcam mode, uses default resolution and last-used fov, starts high-res stream to the IP address of caller Webcam: Start (with args) USB Enters webcam mode, uses specified resolution and/or fov, starts streaming to the IP address of caller Webcam: Preview USB Enters webcam mode, sets stream resolution and bitrate, starts low-res stream to the IP address of caller. Can set Webcam Digital Lenses and Digital Zoom levels while streaming Webcam: Stop USB Stops the webcam stream Webcam: Exit USB Stops the webcam stream and exits webcam mode Webcam: Status WIFI, USB Returns the current state of the webcam endpoint, including status and error codes (see tables below) Webcam: Version WIFI, USB Provides version information about webcam implementation in JSON format Status Codes Status Code OFF 0 IDLE 1 HIGH_POWER_PREVIEW 2 LOW_POWER_PREVIEW 3 Error Codes Status Code NONE 0 SET_PRESET 1 SET_WINDOW_SIZE 2 EXEC_STREAM 3 SHUTTER 4 COM_TIMEOUT 5 INVALID_PARAM 6 UNAVAILABLE 7 EXIT 8 Resolutions Note: If resolution is not set, 1080p will be used by default Resolution ID 480 4 720 7 1080 12 Webcam Digital Lenses (FOV) Note: If fov is not set, camera will default to the last-set fov or Wide if fov has never been set. Webcam Digital Lens (FOV) ID WIDE 0 NARROW 2 SUPERVIEW 3 LINEAR 4 Commands Using the Open GoPro API, a client can perform various command, control, and query operations! Commands Quick Reference Below is a table of commands that can be sent to the camera and how to send them. ✔ Indicates support for all Open GoPro firmware versions. ❌ Indicates a lack of support for all Open GoPro firmware versions. &gt;= vXX.YY.ZZ indicates support for firmware versions equal to or newer than vXX.YY.ZZ Command Description HTTP Method Endpoint HERO10 Black Camera: Get State Get camera state (status + settings) GET /gopro/camera/state ✔ Digital Zoom Digital zoom 50% GET /gopro/camera/digital_zoom?percent=50 ✔ Get Date/Time Get date/time GET /gopro/camera/get_date_time \\&gt;= v01.30.00 Keep-alive Send keep-alive GET /gopro/camera/keep_alive ✔ Media: GPMF Get GPMF data (JPG) GET /gopro/media/gpmf?path=100GOPRO/XXX.JPG ✔ Media: GPMF Get GPMF data (MP4) GET /gopro/media/gpmf?path=100GOPRO/XXX.MP4 ✔ Media: HiLight (Add) Add hilight to 100GOPRO/xxx.JPG GET /gopro/media/hilight/file?path=100GOPRO/XXX.JPG \\&gt;= v01.30.00 Media: HiLight (Add) Add hilight to 100GOPRO/xxx.MP4 at offset 2500 ms GET /gopro/media/hilight/file?path=100GOPRO/XXX.MP4&amp;ms=2500 \\&gt;= v01.30.00 Media: HiLight (Remove) Remove hilight from 100GOPRO/xxx.JPG GET /gopro/media/hilight/remove?path=100GOPRO/XXX.JPG \\&gt;= v01.30.00 Media: HiLight (Remove) Remove hilight from 100GOPRO/xxx.MP4 at offset 2500ms GET /gopro/media/hilight/remove?path=100GOPRO/XXX.MP4&amp;ms=2500 \\&gt;= v01.30.00 Media: HiLight moment Hilight moment during encoding GET /gopro/media/hilight/moment \\&gt;= v01.30.00 Media: Info Get media info (JPG) GET /gopro/media/info?path=100GOPRO/XXX.JPG ✔ Media: Info Get media info (MP4) GET /gopro/media/info?path=100GOPRO/XXX.MP4 ✔ Media: List Get media list GET /gopro/media/list ✔ Media: Screennail Get screennail for \"100GOPRO/xxx.JPG\" GET /gopro/media/screennail?path=100GOPRO/XXX.JPG ✔ Media: Screennail Get screennail for \"100GOPRO/xxx.MP4\" GET /gopro/media/screennail?path=100GOPRO/XXX.MP4 ✔ Media: Telemetry Get telemetry track data (JPG) GET /gopro/media/telemetry?path=100GOPRO/XXX.JPG ✔ Media: Telemetry Get telemetry track data (MP4) GET /gopro/media/telemetry?path=100GOPRO/XXX.MP4 ✔ Media: Thumbnail Get thumbnail for \"100GOPRO/xxx.JPG\" GET /gopro/media/thumbnail?path=100GOPRO/XXX.JPG ✔ Media: Thumbnail Get thumbnail for \"100GOPRO/xxx.MP4\" GET /gopro/media/thumbnail?path=100GOPRO/XXX.MP4 ✔ Media: Turbo Transfer Turbo transfer: off GET /gopro/media/turbo_transfer?p=0 ✔ Media: Turbo Transfer Turbo transfer: on GET /gopro/media/turbo_transfer?p=1 ✔ Open GoPro Get version GET /gopro/version ✔ Presets: Get Status Get preset status GET /gopro/camera/presets/get ✔ Presets: Load Standard GET /gopro/camera/presets/load?id=0 ✔ Presets: Load Activity GET /gopro/camera/presets/load?id=1 ✔ Presets: Load Cinematic GET /gopro/camera/presets/load?id=2 ✔ Presets: Load Ultra Slo-Mo GET /gopro/camera/presets/load?id=4 \\&gt;= v01.16.00 Presets: Load Basic GET /gopro/camera/presets/load?id=5 \\&gt;= v01.16.00 Presets: Load Photo GET /gopro/camera/presets/load?id=65536 ✔ Presets: Load Live Burst GET /gopro/camera/presets/load?id=65537 ✔ Presets: Load Burst Photo GET /gopro/camera/presets/load?id=65538 ✔ Presets: Load Night Photo GET /gopro/camera/presets/load?id=65539 ✔ Presets: Load Time Warp GET /gopro/camera/presets/load?id=131072 ✔ Presets: Load Time Lapse GET /gopro/camera/presets/load?id=131073 ✔ Presets: Load Night Lapse GET /gopro/camera/presets/load?id=131074 ✔ Presets: Load Max Video GET /gopro/camera/presets/load?id=196608 \\&gt;= v01.20.00 Presets: Load Max Photo GET /gopro/camera/presets/load?id=262144 \\&gt;= v01.20.00 Presets: Load Max Timewarp GET /gopro/camera/presets/load?id=327680 \\&gt;= v01.20.00 Presets: Load Standard [EB] GET /gopro/camera/presets/load?id=524288 \\&gt;= v01.16.00 Presets: Load Activity [EB] GET /gopro/camera/presets/load?id=524289 \\&gt;= v01.16.00 Presets: Load Cinematic [EB] GET /gopro/camera/presets/load?id=524290 \\&gt;= v01.16.00 Presets: Load Slo-Mo [EB] GET /gopro/camera/presets/load?id=524291 \\&gt;= v01.16.00 Presets: Load 4K Tripod GET /gopro/camera/presets/load?id=589824 \\&gt;= v01.16.00 Presets: Load 5.3K Tripod GET /gopro/camera/presets/load?id=589825 \\&gt;= v01.16.00 Presets: Load Group Video GET /gopro/camera/presets/set_group?id=1000 ✔ Presets: Load Group Photo GET /gopro/camera/presets/set_group?id=1001 ✔ Presets: Load Group Timelapse GET /gopro/camera/presets/set_group?id=1002 ✔ Set Camera Control Status Set camera control status to idle GET /gopro/camera/control/set_ui_controller?p=0 \\&gt;= v01.20.00 Set Camera Control Status Set camera control status to external_control GET /gopro/camera/control/set_ui_controller?p=2 \\&gt;= v01.20.00 Set Date/Time Set date/time to 2022-01-02 03:04:05 GET /gopro/camera/set_date_time?date=2022_1_2&amp;time=3_4_5 \\&gt;= v01.30.00 Set shutter Shutter: on GET /gopro/camera/shutter/start ✔ Set shutter Shutter: off GET /gopro/camera/shutter/stop ✔ Stream: Start Start preview stream GET /gopro/camera/stream/start ✔ Stream: Stop Stop preview stream GET /gopro/camera/stream/stop ✔ Webcam: Exit Exit webcam mode GET /gopro/webcam/exit ✔ Webcam: Preview Start preview stream GET /gopro/webcam/preview ✔ Webcam: Start Start webcam GET /gopro/webcam/start ✔ Webcam: Start Start webcam (res: 1080, fov: wide) GET /gopro/webcam/start?res=12&amp;fov=0 ✔ Webcam: Status Get webcam status GET /gopro/webcam/status ✔ Webcam: Stop Stop webcam GET /gopro/webcam/stop ✔ Webcam: Version Get webcam api version GET /gopro/webcam/version ✔ Wired USB Disable wired usb control GET /gopro/camera/control/wired_usb?p=0 \\&gt;= v01.30.00 Wired USB Enable wired usb control GET /gopro/camera/control/wired_usb?p=1 \\&gt;= v01.30.00 Settings GoPro cameras have hundreds of setting options to choose from, all of which can be set using a single endpoint. The endpoint is configured with a setting id and an option value. Note that setting option values are not globally unique. While most option values are enumerated values, some are complex bitmasked values. Settings Quick Reference Below is a table of setting options detailing how to set every option supported by Open GoPro cameras. ✔ Indicates support for all Open GoPro firmware versions. ❌ Indicates a lack of support for all Open GoPro firmware versions. &gt;= vXX.YY.ZZ indicates support for firmware versions equal to or newer than vXX.YY.ZZ Setting ID Setting Option HTTP Method Endpoint HERO10 Black 2 Resolution Set video resolution (id: 2) to 4k (id: 1) GET /gopro/camera/setting?setting=2&amp;option=1 ✔ 2 Resolution Set video resolution (id: 2) to 2.7k (id: 4) GET /gopro/camera/setting?setting=2&amp;option=4 ✔ 2 Resolution Set video resolution (id: 2) to 2.7k 4:3 (id: 6) GET /gopro/camera/setting?setting=2&amp;option=6 ✔ 2 Resolution Set video resolution (id: 2) to 1080 (id: 9) GET /gopro/camera/setting?setting=2&amp;option=9 ✔ 2 Resolution Set video resolution (id: 2) to 4k 4:3 (id: 18) GET /gopro/camera/setting?setting=2&amp;option=18 ✔ 2 Resolution Set video resolution (id: 2) to 5k 4:3 (id: 25) GET /gopro/camera/setting?setting=2&amp;option=25 ✔ 2 Resolution Set video resolution (id: 2) to 5.3k (id: 100) GET /gopro/camera/setting?setting=2&amp;option=100 ✔ 3 Frames Per Second Set video fps (id: 3) to 240 (id: 0) GET /gopro/camera/setting?setting=3&amp;option=0 ✔ 3 Frames Per Second Set video fps (id: 3) to 120 (id: 1) GET /gopro/camera/setting?setting=3&amp;option=1 ✔ 3 Frames Per Second Set video fps (id: 3) to 100 (id: 2) GET /gopro/camera/setting?setting=3&amp;option=2 ✔ 3 Frames Per Second Set video fps (id: 3) to 60 (id: 5) GET /gopro/camera/setting?setting=3&amp;option=5 ✔ 3 Frames Per Second Set video fps (id: 3) to 50 (id: 6) GET /gopro/camera/setting?setting=3&amp;option=6 ✔ 3 Frames Per Second Set video fps (id: 3) to 30 (id: 8) GET /gopro/camera/setting?setting=3&amp;option=8 ✔ 3 Frames Per Second Set video fps (id: 3) to 25 (id: 9) GET /gopro/camera/setting?setting=3&amp;option=9 ✔ 3 Frames Per Second Set video fps (id: 3) to 24 (id: 10) GET /gopro/camera/setting?setting=3&amp;option=10 ✔ 3 Frames Per Second Set video fps (id: 3) to 200 (id: 13) GET /gopro/camera/setting?setting=3&amp;option=13 ✔ 43 Webcam Digital Lenses Set webcam digital lenses (id: 43) to wide (id: 0) GET /gopro/camera/setting?setting=43&amp;option=0 ✔ 43 Webcam Digital Lenses Set webcam digital lenses (id: 43) to narrow (id: 2) GET /gopro/camera/setting?setting=43&amp;option=2 ✔ 43 Webcam Digital Lenses Set webcam digital lenses (id: 43) to superview (id: 3) GET /gopro/camera/setting?setting=43&amp;option=3 ✔ 43 Webcam Digital Lenses Set webcam digital lenses (id: 43) to linear (id: 4) GET /gopro/camera/setting?setting=43&amp;option=4 ✔ 59 Auto Power Down Set auto power down (id: 59) to never (id: 0) GET /gopro/camera/setting?setting=59&amp;option=0 ✔ 59 Auto Power Down Set auto power down (id: 59) to 5 min (id: 4) GET /gopro/camera/setting?setting=59&amp;option=4 ✔ 59 Auto Power Down Set auto power down (id: 59) to 15 min (id: 6) GET /gopro/camera/setting?setting=59&amp;option=6 ✔ 59 Auto Power Down Set auto power down (id: 59) to 30 min (id: 7) GET /gopro/camera/setting?setting=59&amp;option=7 ✔ 121 Video Digital Lenses Set video digital lenses (id: 121) to wide (id: 0) GET /gopro/camera/setting?setting=121&amp;option=0 ✔ 121 Video Digital Lenses Set video digital lenses (id: 121) to narrow (id: 2) GET /gopro/camera/setting?setting=121&amp;option=2 ✔ 121 Video Digital Lenses Set video digital lenses (id: 121) to superview (id: 3) GET /gopro/camera/setting?setting=121&amp;option=3 ✔ 121 Video Digital Lenses Set video digital lenses (id: 121) to linear (id: 4) GET /gopro/camera/setting?setting=121&amp;option=4 ✔ 121 Video Digital Lenses Set video digital lenses (id: 121) to max superview (id: 7) GET /gopro/camera/setting?setting=121&amp;option=7 ✔ 121 Video Digital Lenses Set video digital lenses (id: 121) to linear + horizon leveling (id: 8) GET /gopro/camera/setting?setting=121&amp;option=8 ✔ 122 Photo Digital Lenses Set photo digital lenses (id: 122) to narrow (id: 19) GET /gopro/camera/setting?setting=122&amp;option=19 ✔ 122 Photo Digital Lenses Set photo digital lenses (id: 122) to max superview (id: 100) GET /gopro/camera/setting?setting=122&amp;option=100 ✔ 122 Photo Digital Lenses Set photo digital lenses (id: 122) to wide (id: 101) GET /gopro/camera/setting?setting=122&amp;option=101 ✔ 122 Photo Digital Lenses Set photo digital lenses (id: 122) to linear (id: 102) GET /gopro/camera/setting?setting=122&amp;option=102 ✔ 123 Time Lapse Digital Lenses Set time lapse digital lenses (id: 123) to narrow (id: 19) GET /gopro/camera/setting?setting=123&amp;option=19 ✔ 123 Time Lapse Digital Lenses Set time lapse digital lenses (id: 123) to max superview (id: 100) GET /gopro/camera/setting?setting=123&amp;option=100 ✔ 123 Time Lapse Digital Lenses Set time lapse digital lenses (id: 123) to wide (id: 101) GET /gopro/camera/setting?setting=123&amp;option=101 ✔ 123 Time Lapse Digital Lenses Set time lapse digital lenses (id: 123) to linear (id: 102) GET /gopro/camera/setting?setting=123&amp;option=102 ✔ 128 Media Format Set media format (id: 128) to time lapse video (id: 13) GET /gopro/camera/setting?setting=128&amp;option=13 ✔ 128 Media Format Set media format (id: 128) to time lapse photo (id: 20) GET /gopro/camera/setting?setting=128&amp;option=20 ✔ 128 Media Format Set media format (id: 128) to night lapse photo (id: 21) GET /gopro/camera/setting?setting=128&amp;option=21 ✔ 128 Media Format Set media format (id: 128) to night lapse video (id: 26) GET /gopro/camera/setting?setting=128&amp;option=26 ✔ 134 Anti-Flicker Set setup anti flicker (id: 134) to 60hz (id: 2) GET /gopro/camera/setting?setting=134&amp;option=2 ✔ 134 Anti-Flicker Set setup anti flicker (id: 134) to 50hz (id: 3) GET /gopro/camera/setting?setting=134&amp;option=3 ✔ 162 Max Lens Set max lens (id: 162) to off (id: 0) GET /gopro/camera/setting?setting=162&amp;option=0 \\&gt;= v01.20.00 162 Max Lens Set max lens (id: 162) to on (id: 1) GET /gopro/camera/setting?setting=162&amp;option=1 \\&gt;= v01.20.00 173 Video Performance Mode Set video performance mode (id: 173) to maximum video performance (id: 0) GET /gopro/camera/setting?setting=173&amp;option=0 \\&gt;= v01.16.00 173 Video Performance Mode Set video performance mode (id: 173) to extended battery (id: 1) GET /gopro/camera/setting?setting=173&amp;option=1 \\&gt;= v01.16.00 173 Video Performance Mode Set video performance mode (id: 173) to tripod / stationary video (id: 2) GET /gopro/camera/setting?setting=173&amp;option=2 \\&gt;= v01.16.00 Camera Capabilities Camera capabilities usually change from one camera to another and often change from one release to the next. Below are documents that detail whitelists for basic video settings for every supported camera release. Note about Dependency Ordering and Blacklisting Capability documents define supported camera states. Each state is comprised of a set of setting options that are presented in dependency order. This means each state is guaranteed to be attainable if and only if the setting options are set in the order presented. Failure to adhere to dependency ordering may result in the camera's blacklist rules rejecting a set-setting command. Example Camera Command 1 Command 2 Command 3 Command 4 Command 5 Guaranteed Valid? HERO10 Black Res: 1080 Anti-Flicker: 60Hz (NTSC) FPS: 240 FOV: Wide Hypersmooth: OFF ✔ HERO10 Black FPS: 240 Anti-Flicker: 60Hz (NTSC) Res: 1080 FOV: Wide Hypersmooth: OFF ❌ In the example above, the first set of commands will always work for basic video presets such as Standard. In the second example, suppose the camera's Video Resolution was previously set to 4K. If the user tries to set Video FPS to 240, it will fail because 4K/240fps is not supported. Capability Documents Documents Product Release capabilities.xlsx capabilities.json HERO10 Black v01.30.00 v01.20.00 v01.16.00 v01.10.00 Spreadsheet Format The capabilities spreadsheet contains worksheets for every supported release. Each row in a worksheet represents a whitelisted state and is presented in dependency order as outlined above. JSON Format The capabilities JSON contains a set of whitelist states for every supported release. Each state is comprised of a list of objects that contain setting and option IDs necessary to construct set-setting commands and are given in dependency order as outlined above. Below is a simplified example of the capabilities JSON file; a formal schema is also available here: capabilities_schema.json { \"(PRODUCT_NAME)\": { \"(RELEASE_VERSION)\": { \"states\": [ [ {\"setting_name\": \"(str)\", \"setting_id\": (int), \"option_name\": \"(str)\", \"option_id\": (int)}, ... ], ... ], }, ... }, ... } Media The camera provides an endpoint to query basic details about media captured on the sdcard. Chapters All GoPro cameras break longer videos into chapters. GoPro cameras currently limit file sizes on sdcards to 4GB for both FAT32 and exFAT file systems. This limitation is most commonly seen when recording longer (10+ minute) videos. In practice, the camera will split video media into chapters named Gqccmmmm.MP4 (and ones for THM/LRV) such that: q: Quality Level (X: Extreme, H: High, M: Medium, L: Low) cc: Chapter Number (01-99) mmmm: Media ID (0001-9999) When media becomes chaptered, the camera increments subsequent Chapter Numbers while leaving the Media ID unchanged. For example, if the user records a long High-quality video that results in 4 chapters, the files on the sdcard may look like the following: -rwxrwxrwx@ 1 gopro 123456789 4006413091 Jan 1 00:00 GH010078.MP4 -rwxrwxrwx@ 1 gopro 123456789 17663 Jan 1 00:00 GH010078.THM -rwxrwxrwx@ 1 gopro 123456789 4006001541 Jan 1 00:00 GH020078.MP4 -rwxrwxrwx@ 1 gopro 123456789 17357 Jan 1 00:00 GH020078.THM -rwxrwxrwx@ 1 gopro 123456789 4006041985 Jan 1 00:00 GH030078.MP4 -rwxrwxrwx@ 1 gopro 123456789 17204 Jan 1 00:00 GH030078.THM -rwxrwxrwx@ 1 gopro 123456789 756706872 Jan 1 00:00 GH040078.MP4 -rwxrwxrwx@ 1 gopro 123456789 17420 Jan 1 00:00 GH040078.THM -rwxrwxrwx@ 1 gopro 123456789 184526939 Jan 1 00:00 GL010078.LRV -rwxrwxrwx@ 1 gopro 123456789 184519787 Jan 1 00:00 GL020078.LRV -rwxrwxrwx@ 1 gopro 123456789 184517614 Jan 1 00:00 GL030078.LRV -rwxrwxrwx@ 1 gopro 123456789 34877660 Jan 1 00:00 GL040078.LRV Media List Format The format of the media list is given below. { \"id\": \"&lt;MEDIA SESSION ID&gt;\", \"media\": [ { \"d\": \"&lt;DIRECTORY NAME&gt;\", \"fs\": [ {&lt;MEDIA ITEM INFO&gt;}, ... ] }, ... ] } Media List Keys The outer structure of the media list and the inner structure of individual media items use the keys in the table below. Key Description b ID of first member of a group (for grouped media items) d Directory name fs File system. Contains listing of media items in directory g Group ID (if grouped media item) id Media list session identifier l ID of last member of a group (for grouped media items) ls Low resolution video file size m List of missing/deleted group member IDs (for grouped media items) media Contains media info for for each directory (e.g. 100GOPRO/, 101GOPRO/, ...) mod Last modified time (seconds since epoch) n Media filename s Size of (group) media in bytes t Group type (for grouped media items) (b -&gt; burst, c -&gt; continuous shot, n -&gt; night lapse, t -&gt; time lapse) Grouped Media Items In order to minimize the size of the JSON transmitted by the camera, grouped media items such as Burst Photos, Time Lapse Photos, Night Lapse Photos, etc are represented with a single item in the media list with additional keys that allow the user to extrapolate individual filenames for each member of the group. Filenames for group media items have the form \"GXXXYYYY.ZZZ\" where XXX is the group ID, YYY is the group member ID and ZZZ is the file extension. For example, take the media list below, which contains a Time Lapse Photo group media item: { \"id\": \"2530266050123724003\", \"media\": [ { \"d\": \"100GOPRO\", \"fs\": [ { \"b\": \"8\", \"cre\": \"1613669353\", \"g\": \"1\", \"l\": \"396\", \"m\": ['75', '139'], \"mod\": \"1613669353\", \"n\": \"G0010008.JPG\", \"s\": \"773977407\", \"t\": \"t\" } ] } ] } The first filename in the group is \"G0010008.JPG\" (key: \"n\"). The ID of the first group member in this case is \"008\" (key: \"b\"). The ID of the last group member in this case is \"396\" (key: \"l\"). The IDs of deleted members in this case are \"75\" and \"139\" (key: \"m\") Given this information, the user can extrapolate that the group currently contains G0010008.JPG, G0010009.JPG, G0010010.JPG, ..., G0010074.JPG, G0010076.JPG, ..., G0010138.JPG, G0010140.JPG, ..., G0010394.JPG, G0010395.JPG. G0010396.JPG Media HiLights The HiLight Tags feature allows the user to tag moments of interest either during video capture or on existing media. Add/Remove HiLights Below is a table of all HiLight commands. For details on how to send HiLight commands, see Commands Quick Reference. Command Description Media: HiLight (Add) Video: Add a tag at a specific time offset (ms) Photo: Add a tag Media: HiLight (Remove) Video: Remove a tag at a specific time offset (ms) Photo: Remove tag Media: HiLight Moment Add a tag to the current time offset (ms) while encoding video Note: Attempting to add a HiLight tag at a time offset that exceeds the duration of the video or removing a non-existent HiLight tag will result in an HTTP/500 error. Get HiLights Once HiLight tags have been added, they can be queried by calling the Media: Info command; the response content will be JSON that contains HiLight information: Media Type Key Value Photo hc HiLight Count Video hc HiLight Count Video hi HiLights (list of time offsets in ms) Example The JSON sample below shows media that contains three HiLights at time offsets 2502ms, 5839ms, and 11478ms. Note: Photo info will not have an \"hi\":[...] key-value pair. { ..., \"hc\":\"3\", \"hi\":[2502,5839,11478], ..., } Downloading Media The URL to download/stream media from the DCIM/ directory on the sdcard is the Base URL plus /videos/DCIM/XXX/YYY where XXX is the directory name within DCIM/ given by the media list and YYY is the target media filename. For example: Given the following media list: { \"id\": \"3586667939918700960\", \"media\": [ { \"d\": \"100GOPRO\", \"fs\": [ { \"n\": \"GH010397.MP4\", \"cre\": \"1613672729\", \"mod\": \"1613672729\", \"glrv\": \"1895626\", \"ls\": \"-1\", \"s\": \"19917136\" }, { \"cre\": \"1614340213\", \"mod\": \"1614340213\", \"n\": \"GOPR0001.JPG\", \"s\": \"6961371\" } ] } ] } The URL to download GH010397.MP4 over WiFi would be http://10.5.5.9:8080/videos/DCIM/100GOPRO/GH010397.MP4 The URL to download GOPR0001.JPG over WiFi would be http://10.5.5.9:8080/videos/DCIM/100GOPRO/GOPR0001.JPG Turbo Transfer Some cameras support Turbo Transfer mode, which allows media to be downloaded over WiFi more rapidly. This special mode should only be used during media offload. It is recommended that the user check for and--if necessary--disable Turbo Transfer on connect. For details on which cameras are supported and how to enable and disable Turbo Transfer, see Commands Quick Reference. Downloading Preview Stream When the preview stream is started, the camera starts up a UDP client and begins writing MPEG Transport Stream data to the connected client on port 8554. In order to stream and save this data, the user can implement a UDP server that binds to the same port and appends datagrams to a file when they are received. Camera State The camera provides multiple types of state, all of which can be queried: Camera state: Contains information about camera status (photos taken, date, is-camera-encoding, etc) and settings (current video resolution, current frame rate, etc) Preset State: How presets are arranged into preset groups, their titles, icons, settings closely associated with each preset, etc Camera State Format Camera state is given in the following form: { \"status\": { \"1\": &lt;status 1 value&gt;, \"2\": &lt;status 2 value&gt;, ... }, \"settings: { \"2\": &lt;setting 2 value&gt;, \"3\": &lt;setting 3 value&gt;, ... } } Where status X value and setting X value are almost always integer values. See Status Codes table in this document for exceptions. For status, keys are status codes and values are status values. For settings, keys are setting IDs, and values are option values Status Codes Below is a table of supported status codes. ✔ Indicates support for all Open GoPro firmware versions. ❌ Indicates a lack of support for all Open GoPro firmware versions. &gt;= vXX.YY.ZZ indicates support for firmware versions equal to or newer than vXX.YY.ZZ Status ID Name Description Type Values HERO10 Black 1 Internal battery present Is the system's internal battery present? boolean 0: False 1: True ✔ 2 Internal battery level Rough approximation of internal battery level in bars integer 0: Zero 1: One 2: Two 3: Three ✔ 3 External battery present Is an external battery connected? boolean 0: False 1: True ✔ 4 External battery level External battery power level in percent percent 0-100 ✔ 6 System hot Is the system currently overheating? boolean 0: False 1: True ✔ 8 System busy Is the camera busy? boolean 0: False 1: True ✔ 9 Quick capture active Is Quick Capture feature enabled? boolean 0: False 1: True ✔ 10 Encoding active Is the system encoding right now? boolean 0: False 1: True ✔ 11 Lcd lock active Is LCD lock active? boolean 0: False 1: True ✔ 13 Video progress counter When encoding video, this is the duration (seconds) of the video so far; 0 otherwise integer * ✔ 17 Enable Are Wireless Connections enabled? boolean 0: False 1: True ✔ 19 State The pairing state of the camera integer 0: Success 1: In Progress 2: Failed 3: Stopped ✔ 20 Type The last type of pairing that the camera was engaged in integer 0: Not Pairing 1: Pairing App 2: Pairing Remote Control 3: Pairing Bluetooth Device ✔ 21 Pair time Time (milliseconds) since boot of last successful pairing complete action integer * ✔ 22 State State of current scan for WiFi Access Points. Appears to only change for CAH-related scans integer 0: Never started 1: Started 2: Aborted 3: Canceled 4: Completed ✔ 23 Scan time msec The time, in milliseconds since boot that the WiFi Access Point scan completed integer * ✔ 24 Provision status WiFi AP provisioning state integer 0: Never started 1: Started 2: Aborted 3: Canceled 4: Completed ✔ 26 Remote control version Wireless remote control version integer * ✔ 27 Remote control connected Is a wireless remote control connected? boolean 0: False 1: True ✔ 28 Pairing Wireless Pairing State integer * ✔ 29 Wlan ssid Provisioned WIFI AP SSID. On BLE connection, value is big-endian byte-encoded int string * ✔ 30 Ap ssid Camera's WIFI SSID. On BLE connection, value is big-endian byte-encoded int string * ✔ 31 App count The number of wireless devices connected to the camera integer * ✔ 32 Enable Is Preview Stream enabled? boolean 0: False 1: True ✔ 33 Sd status Primary Storage Status integer -1: Unknown 0: OK 1: SD Card Full 2: SD Card Removed 3: SD Card Format Error 4: SD Card Busy 8: SD Card Swapped ✔ 34 Remaining photos How many photos can be taken before sdcard is full integer * ✔ 35 Remaining video time How many minutes of video can be captured with current settings before sdcard is full integer * ✔ 36 Num group photos How many group photos can be taken with current settings before sdcard is full integer * ✔ 37 Num group videos Total number of group videos on sdcard integer * ✔ 38 Num total photos Total number of photos on sdcard integer * ✔ 39 Num total videos Total number of videos on sdcard integer * ✔ 41 Ota status The current status of Over The Air (OTA) update integer 0: Idle 1: Downloading 2: Verifying 3: Download Failed 4: Verify Failed 5: Ready 6: GoPro App: Downloading 7: GoPro App: Verifying 8: GoPro App: Download Failed 9: GoPro App: Verify Failed 10: GoPro App: Ready ✔ 42 Download cancel request pending Is there a pending request to cancel a firmware update download? boolean 0: False 1: True ✔ 45 Camera locate active Is locate camera feature active? boolean 0: False 1: True ✔ 49 Multi shot count down The current timelapse interval countdown value (e.g. 5...4...3...2...1...) integer * ✔ 54 Remaining space Remaining space on the sdcard in Kilobytes integer * ✔ 55 Supported Is preview stream supported in current recording/flatmode/secondary-stream? boolean 0: False 1: True ✔ 56 Wifi bars WiFi signal strength in bars integer * ✔ 58 Num hilights The number of hilights in encoding video (set to 0 when encoding stops) integer * ✔ 59 Last hilight time msec Time since boot (msec) of most recent hilight in encoding video (set to 0 when encoding stops) integer * ✔ 60 Next poll msec The min time between camera status updates (msec). Do not poll for status more often than this integer * ✔ 64 Remaining timelapse time How many min of Timelapse video can be captured with current settings before sdcard is full integer * ✔ 65 Exposure select type Liveview Exposure Select Mode integer 0: Disabled 1: Auto 2: ISO Lock 3: Hemisphere ✔ 66 Exposure select x Liveview Exposure Select: y-coordinate (percent) percent 0-100 ✔ 67 Exposure select y Liveview Exposure Select: y-coordinate (percent) percent 0-100 ✔ 68 Gps status Does the camera currently have a GPS lock? boolean 0: False 1: True ✔ 69 Ap state Is the WiFi radio enabled? boolean 0: False 1: True ✔ 70 Internal battery percentage Internal battery level (percent) percent 0-100 ✔ 74 Acc mic status Microphone Accesstory status integer 0: Microphone mod not connected 1: Microphone mod connected 2: Microphone mod connected and microphone plugged into Microphone mod ✔ 75 Digital zoom Digital Zoom level (percent) percent 0-100 ✔ 76 Wireless band Wireless Band integer 0: 2.4 GHz 1: 5 GHz 2: Max ✔ 77 Digital zoom active Is Digital Zoom feature available? boolean 0: False 1: True ✔ 78 Mobile friendly video Are current video settings mobile friendly? (related to video compression and frame rate) boolean 0: False 1: True ✔ 79 First time use Is the camera currently in First Time Use (FTU) UI flow? boolean 0: False 1: True ✔ 81 Band 5ghz avail Is 5GHz wireless band available? boolean 0: False 1: True ✔ 82 System ready Is the system ready to accept commands? boolean 0: False 1: True ✔ 83 Batt okay for ota Is the internal battery charged sufficiently to start Over The Air (OTA) update? boolean 0: False 1: True ✔ 85 Video low temp alert Is the camera getting too cold to continue recording? boolean 0: False 1: True ✔ 86 Actual orientation The rotational orientation of the camera integer 0: 0 degrees (upright) 1: 180 degrees (upside down) 2: 90 degrees (laying on right side) 3: 270 degrees (laying on left side) ✔ 88 Zoom while encoding Is this camera capable of zooming while encoding (static value based on model, not settings) boolean 0: False 1: True ✔ 89 Current mode Current flatmode ID integer * ✔ 91 Logs ready Are system logs ready to be downloaded? boolean 0: False 1: True ✔ 93 Active video presets Current Video Preset (ID) integer * ✔ 94 Active photo presets Current Photo Preset (ID) integer * ✔ 95 Active timelapse presets Current Timelapse Preset (ID) integer * ✔ 96 Active presets group Current Preset Group (ID) integer * ✔ 97 Active preset Current Preset (ID) integer * ✔ 98 Preset modified Preset Modified Status, which contains an event ID and a preset (group) ID integer * ✔ 99 Remaining live bursts How many Live Bursts can be captured before sdcard is full integer * ✔ 100 Num total live bursts Total number of Live Bursts on sdcard integer * ✔ 101 Capture delay active Is Capture Delay currently active (i.e. counting down)? boolean 0: False 1: True ✔ 102 Media mod mic status Media mod State integer 0: Media mod microphone removed 2: Media mod microphone only 3: Media mod microphone with external microphone ✔ 103 Timewarp speed ramp active Time Warp Speed integer 0: 15x 1: 30x 2: 60x 3: 150x 4: 300x 5: 900x 6: 1800x 7: 2x 8: 5x 9: 10x 10: Auto 11: 1x (realtime) 12: 1/2x (slow-motion) ✔ 104 Linux core active Is the system's Linux core active? boolean 0: False 1: True ✔ 105 Camera lens type Camera lens type (reflects changes to setting 162) integer 0: Default 1: Max Lens ✔ 106 Video hindsight capture active Is Video Hindsight Capture Active? boolean 0: False 1: True ✔ 107 Scheduled preset Scheduled Capture Preset ID integer * ✔ 108 Scheduled enabled Is Scheduled Capture set? boolean 0: False 1: True ✔ 109 Creating preset Is the camera in the process of creating a custom preset? boolean 0: False 1: True ✔ 110 Media mod status Media Mode Status (bitmasked) integer 0: Display (selfie) mod: 0, HDMI: 0, Media Mod Connected: False 1: Display (selfie) mod: 0, HDMI: 0, Media Mod Connected: True 2: Display (selfie) mod: 0, HDMI: 1, Media Mod Connected: False 3: Display (selfie) mod: 0, HDMI: 1, Media Mod Connected: True 4: Display (selfie) mod: 1, HDMI: 0, Media Mod Connected: False 5: Display (selfie) mod: 1, HDMI: 0, Media Mod Connected: True 6: Display (selfie) mod: 1, HDMI: 1, Media Mod Connected: False 7: Display (selfie) mod: 1, HDMI: 1, Media Mod Connected: True ✔ 111 Sd rating check error Does sdcard meet specified minimum write speed? boolean 0: False 1: True ✔ 112 Sd write speed error Number of sdcard write speed errors since device booted integer * ✔ 113 Turbo transfer Is Turbo Transfer active? boolean 0: False 1: True ✔ 114 Camera control status Camera control status ID integer 0: Camera Idle: No one is attempting to change camera settings 1: Camera Control: Camera is in a menu or changing settings. To intervene, app must request control 2: Camera External Control: An outside entity (app) has control and is in a menu or modifying settings ✔ 115 Usb connected Is the camera connected to a PC via USB? boolean 0: False 1: True ✔ 116 Allow control over usb Camera control over USB state integer 0: Disabled 1: Enabled \\&gt;= v01.30.00 Preset Status Format Preset Status is returned as JSON, whose content is the serialization of the protobuf message: NotifyPresetStatus. Using Google protobuf APIs, the JSON can be converted back into a programmatic object in the user's language of choice.",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/http_2_0#"
        },
        {
            "title": "Open GoPro: ",
            "excerpt": "The Open GoPro API is the primary way for users to interact with a GoPro camera. The camera provides interfaces to HTTP (wired and wireless) and Bluetooth Low Energy that allow users to perform command, control, and query actions including, but not limited to: Capture media Track camera state Get media list and download files / metadata Load / edit presets Configure and use as webcam Add / remove hilights Docs Detailed Bluetooth Low Energy (BLE) and HTTP Interface Specifications. BLE Specs → HTTP Specs → Tutorials Walk-through tutorials in different languages / frameworks for getting started. ✏️ Tutorials → Demos Complete runnable examples in different languages to use as base for your project. ⚙️ Demos →",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/#"
        },
        {
            "title": "Tutorials: ",
            "excerpt": "Several walk-through tutorials in different languages / frameworks exist for getting started with Open GoPro.",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/tutorials/#"
        },
        {
            "title": "Tutorials: Python",
            "excerpt": "This set of tutorials is a series of sample python scripts and accompanying .html walk-throughs to implement basic functionality to interact with a GoPro device using Python. The tutorials support Open GoPro Versions 1.0 and 2.0. They will provide a walk-through to use Python to exercise the Open GoPro Interface using [bleak](https://bleak.readthedocs.io/en/latest/api.html) for Bluetooth Low Energy (BLE) and [requests](https://docs.python-requests.org/en/master/) for HTTP. These tutorials are meant as an introduction to the Open GoPro specification. There is complete documentation available for [BLE]({% link specs/ble.md %}) and [HTTP]({% link specs/http.md %}) which will be the main source of reference after completing the tutorials. {% for tutorial in site.python-tutorials %} - [{{ tutorial.title }}]({{ tutorial.permalink | prepend: site.baseurl }}) {% endfor %} {% note %} These are stripped down Python tutorials that are only meant to show the basics. {% endnote %} For a complete Python SDK that uses [bleak](https://bleak.readthedocs.io/en/latest/) as the backend as well as a cross-platform WiFi backend to easily write Python apps that control the GoPro, see the [Open GoPro Python SDK](https://gopro.github.io/OpenGoPro/python_sdk/)",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/tutorials/#python"
        },
        {
            "title": "Tutorials: Bash",
            "excerpt": "BlueZ tutorial for Ubuntu using the command line: {% for tutorial in site.bash-tutorials %} - [{{ tutorial.title }}]({{ tutorial.permalink | prepend: site.baseurl }}) {% endfor %}",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/tutorials/#bash"
        },
        {
            "title": "BlueZ Bash Tutorial: ",
            "excerpt": "This document will provide a walk-through tutorial to use BlueZ to interact with the Open GoPro Interface. It is ok not to have read the interface documentation first as we will describe it as needed here. After completing this tutorial, you will need to reference it for future development. Requirements Hardware A platform that is supported by Bluez A GoPro camera that is supported by Open GoPro Software BlueZ must be installed. Follow the steps here Test that installation was successful with: $ bluetoothctl --version bluetoothctl: 5.58 Basic BLE Tutorial This tutorial will walk through a process of connecting to the GoPro via Bluetooth Low Energy (BLE) and taking a picture / video. First, invoke the bluetooth control tool from BlueZ with: $ bluetoothctl Agent registered [CHG] Controller FC:44:82:DD:5A:3F Pairable: yes [bluetooth] Advertise Now, we need to ensure the camera is discoverable (i.e. it is advertising). Ensure that the Camera is powered on, then select Connections –&gt; Connect Device –&gt; Quik App The screen should appear as such: Camera is discoverable. This step may vary slightly by camera Scan code output Input Output Next, we must find the GoPro Camera using bleak. Let’s initialize an empty dict that will store discovered devices, indexed by name: Map of devices indexed by name devices: Dict[str, BleakDevice] = {} We’re then going to scan for all devices. We are passing a scan callback to bleak in order to also find non-connectable scan responses. We are keeping any devices that have a device name. Scan callback to also catch nonconnectable scan responses def _scan_callback(device: BleakDevice, _: Any) -&gt; None: Add to the dict if not unknown if device.name != \"Unknown\" and device.name is not None: devices[device.name] = device Now discover and add connectable advertisements for device in await BleakScanner.discover(timeout=5, detection_callback=_scan_callback): if device.name != \"Unknown\" and device.name is not None: devices[device.name] = device Now we can search through the discovered devices to see if we found a GoPro. Any GoPro device name will be structured as GoPro XXXX where XXXX is the last four digits of your camera’s serial number. First, we define a regex which is either “GoPro “ followed by any four alphanumeric characters if no identifier was passed, or “GoPro “ concatenated with the identifier if it exists. In the demo ble_connect.py, the identifier is taken from the command-line arguments. token = re.compile(r\"GoPro [A-Z0-9]{4}\" if identifier is None else f\"GoPro {identifier}\") Now we build a list of matched devices by checking if each device’s name includes the token regex. matched_devices: List[BleakDevice] = [] Now look for our matching device(s) matched_devices = [device for name, device in devices.items() if token.match(name)] Due to potential RF interference and the asynchronous nature of BLE advertising / scanning, it is possible that the advertising GoPro will not be discovered by the scanning PC in one scan. Therefore, you may need to redo the scan (as ble_connect.py does) until a GoPro is found. That is, matched_device must contain at least one device. When running the demo, discovered devices will be logged to the console as they are found. Click the output tab to see an example of this. Here is an example of the log from `ble_connect.py` of scanning for devices. Note that this includes several rescans until the devices was found. $ python ble_connect.py INFO:root:Scanning for bluetooth devices... INFO:root: Discovered: INFO:root: Discovered: TR8600 seri INFO:root:Found 0 matching devices. INFO:root: Discovered: INFO:root: Discovered: TR8600 seri INFO:root: Discovered: GoPro Cam INFO:root: Discovered: GoPro 0456 INFO:root:Found 1 matching devices. Among other devices, you should see GoPro XXXX where XXXX is the last four digits of your camera’s serial number. Next, we must find the GoPro Camera from BlueZ. Scan for devices via: [bluetooth] scan on As BlueZ discovers devices, it will display them to the console. Click the output tab to see the output. [bluetooth] scan on Discovery started [CHG] Controller FC:44:82:DD:5A:3F Discovering: yes [NEW] Device 6E:0A:B0:76:36:49 6E-0A-B0-76-36-49 [NEW] Device DF:34:ED:D1:DA:E8 GoPro 0456 [NEW] Device 26:A2:8C:82:74:6E 26-A2-8C-82-74-6E [CHG] Device F8:A2:6D:4C:5D:E0 RSSI: -60 Among other devices, you should see GoPro XXXX where XXXX is the last four digits of your camera’s serial number. Take note of the address to the left of this string (DF:34:ED:D1:DA:E8 in the example above). This is how the camera will be identified via bluetoothctl. Connect Input Output Now that we know the address to connect to, the next step is to establish a BLE connection to the camera as such: [bluetooth] connect DF:34:ED:D1:DA:E8 Click the output tab to see the output. When the connection is successfully established, the list of services and characteristics will be displayed as such: We will make use of these attributes later on. [CHG] Device DF:34:ED:D1:DA:E8 Connected: yes Connection successful [NEW] Primary Service (Handle 0xe461) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0001 00001801-0000-1000-8000-00805f9b34fb Generic Attribute Profile [NEW] Primary Service (Handle 0xe461) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service000b 00001804-0000-1000-8000-00805f9b34fb Tx Power [NEW] Characteristic (Handle 0xe461) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service000b/char000c 00002a07-0000-1000-8000-00805f9b34fb Tx Power Level [NEW] Primary Service (Handle 0xe461) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service000e 0000180f-0000-1000-8000-00805f9b34fb Battery Service [NEW] Characteristic (Handle 0xe461) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service000e/char000f 00002a19-0000-1000-8000-00805f9b34fb Battery Level [NEW] Descriptor (Handle 0xea04) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service000e/char000f/desc0011 00002902-0000-1000-8000-00805f9b34fb Client Characteristic Configuration [NEW] Primary Service (Handle 0xe461) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0012 0000180a-0000-1000-8000-00805f9b34fb Device Information [NEW] Characteristic (Handle 0xe461) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0012/char0013 00002a29-0000-1000-8000-00805f9b34fb Manufacturer Name String [NEW] Characteristic (Handle 0xea8d) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0012/char0015 00002a24-0000-1000-8000-00805f9b34fb Model Number String [NEW] Characteristic (Handle 0xe461) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0012/char0017 00002a25-0000-1000-8000-00805f9b34fb Serial Number String [NEW] Characteristic (Handle 0xe461) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0012/char0019 00002a27-0000-1000-8000-00805f9b34fb Hardware Revision String [NEW] Characteristic (Handle 0xe461) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0012/char001b 00002a26-0000-1000-8000-00805f9b34fb Firmware Revision String [NEW] Characteristic (Handle 0xe461) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0012/char001d 00002a28-0000-1000-8000-00805f9b34fb Software Revision String [NEW] Characteristic (Handle 0xe461) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0012/char001f 00002a23-0000-1000-8000-00805f9b34fb System ID [NEW] Characteristic (Handle 0xe461) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0012/char0021 00002a2a-0000-1000-8000-00805f9b34fb IEEE 11073-20601 Regulatory Cert. Data List [NEW] Characteristic (Handle 0xe461) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0012/char0023 00002a50-0000-1000-8000-00805f9b34fb PnP ID [NEW] Primary Service (Handle 0xe461) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0025 b5f90001-aa8d-11e3-9046-0002a5d5c51b Vendor specific [NEW] Characteristic (Handle 0xe461) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0025/char0026 b5f90002-aa8d-11e3-9046-0002a5d5c51b Vendor specific [NEW] Characteristic (Handle 0xe461) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0025/char0028 b5f90003-aa8d-11e3-9046-0002a5d5c51b Vendor specific [NEW] Characteristic (Handle 0xe461) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0025/char002a b5f90004-aa8d-11e3-9046-0002a5d5c51b Vendor specific [NEW] Characteristic (Handle 0xe461) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0025/char002c b5f90005-aa8d-11e3-9046-0002a5d5c51b Vendor specific [NEW] Descriptor (Handle 0x32a4) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0025/char002c/desc002e 00002902-0000-1000-8000-00805f9b34fb Client Characteristic Configuration [NEW] Characteristic (Handle 0xe461) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0025/char002f b5f90006-aa8d-11e3-9046-0002a5d5c51b Vendor specific [NEW] Primary Service (Handle 0xe461) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0031 0000fea6-0000-1000-8000-00805f9b34fb GoPro, Inc. [NEW] Characteristic (Handle 0xe461) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0031/char0032 b5f90072-aa8d-11e3-9046-0002a5d5c51b Vendor specific [NEW] Characteristic (Handle 0xe461) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0031/char0034 b5f90073-aa8d-11e3-9046-0002a5d5c51b Vendor specific [NEW] Descriptor (Handle 0x4174) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0031/char0034/desc0036 00002902-0000-1000-8000-00805f9b34fb Client Characteristic Configuration [NEW] Characteristic (Handle 0xe461) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0031/char0037 b5f90074-aa8d-11e3-9046-0002a5d5c51b Vendor specific [NEW] Characteristic (Handle 0xe461) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0031/char0039 b5f90075-aa8d-11e3-9046-0002a5d5c51b Vendor specific [NEW] Descriptor (Handle 0x4b84) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0031/char0039/desc003b 00002902-0000-1000-8000-00805f9b34fb Client Characteristic Configuration [NEW] Characteristic (Handle 0xe461) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0031/char003c b5f90076-aa8d-11e3-9046-0002a5d5c51b Vendor specific [NEW] Characteristic (Handle 0xe461) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0031/char003e b5f90077-aa8d-11e3-9046-0002a5d5c51b Vendor specific [NEW] Descriptor (Handle 0x5494) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0031/char003e/desc0040 00002902-0000-1000-8000-00805f9b34fb Client Characteristic Configuration [NEW] Characteristic (Handle 0xe461) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0031/char0041 b5f90078-aa8d-11e3-9046-0002a5d5c51b Vendor specific [NEW] Characteristic (Handle 0xe461) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0031/char0043 b5f90079-aa8d-11e3-9046-0002a5d5c51b Vendor specific [NEW] Descriptor (Handle 0x5da4) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0031/char0043/desc0045 00002902-0000-1000-8000-00805f9b34fb Client Characteristic Configuration [NEW] Primary Service (Handle 0xe461) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0046 b5f90090-aa8d-11e3-9046-0002a5d5c51b Vendor specific [NEW] Characteristic (Handle 0xe461) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0046/char0047 b5f90091-aa8d-11e3-9046-0002a5d5c51b Vendor specific [NEW] Characteristic (Handle 0xe461) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0046/char0049 b5f90092-aa8d-11e3-9046-0002a5d5c51b Vendor specific [NEW] Descriptor (Handle 0x6984) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0046/char0049/desc004b 00002902-0000-1000-8000-00805f9b34fb Client Characteristic Configuration [NEW] Primary Service (Handle 0xe461) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service004c b5f90080-aa8d-11e3-9046-0002a5d5c51b Vendor specific [NEW] Characteristic (Handle 0xe461) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service004c/char004d b5f90081-aa8d-11e3-9046-0002a5d5c51b Vendor specific [NEW] Descriptor (Handle 0x7274) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service004c/char004d/desc004f 00002902-0000-1000-8000-00805f9b34fb Client Characteristic Configuration [NEW] Characteristic (Handle 0xe461) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service004c/char0050 b5f90082-aa8d-11e3-9046-0002a5d5c51b Vendor specific [NEW] Characteristic (Handle 0xe461) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service004c/char0052 b5f90083-aa8d-11e3-9046-0002a5d5c51b Vendor specific [NEW] Descriptor (Handle 0x8104) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service004c/char0052/desc0054 00002902-0000-1000-8000-00805f9b34fb Client Characteristic Configuration [NEW] Characteristic (Handle 0xe461) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service004c/char0055 b5f90084-aa8d-11e3-9046-0002a5d5c51b Vendor specific [NEW] Descriptor (Handle 0x8724) /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service004c/char0055/desc0057 00002902-0000-1000-8000-00805f9b34fb Client Characteristic Configuration [CHG] Device DF:34:ED:D1:DA:E8 UUIDs: 00001800-0000-1000-8000-00805f9b34fb [CHG] Device DF:34:ED:D1:DA:E8 UUIDs: 00001801-0000-1000-8000-00805f9b34fb [CHG] Device DF:34:ED:D1:DA:E8 UUIDs: 00001804-0000-1000-8000-00805f9b34fb [CHG] Device DF:34:ED:D1:DA:E8 UUIDs: 0000180a-0000-1000-8000-00805f9b34fb [CHG] Device DF:34:ED:D1:DA:E8 UUIDs: 0000180f-0000-1000-8000-00805f9b34fb [CHG] Device DF:34:ED:D1:DA:E8 UUIDs: 0000fea6-0000-1000-8000-00805f9b34fb [CHG] Device DF:34:ED:D1:DA:E8 UUIDs: b5f90001-aa8d-11e3-9046-0002a5d5c51b [CHG] Device DF:34:ED:D1:DA:E8 UUIDs: b5f90080-aa8d-11e3-9046-0002a5d5c51b [CHG] Device DF:34:ED:D1:DA:E8 UUIDs: b5f90090-aa8d-11e3-9046-0002a5d5c51b [CHG] Device DF:34:ED:D1:DA:E8 ServicesResolved: yes [CHG] Device DF:34:ED:D1:DA:E8 Appearance: 0x0080 [CHG] Device DF:34:ED:D1:DA:E8 Icon: computer [NEW] Device 6C:4A:85:45:04:D4 6C-4A-85-45-04-D4 [GoPro 0456] Pair The GoPro has encryption-protected characteristics which require us to pair before writing to. Now that you are connected (the prompt should now show GoPro XXXX instead of bluetooth), do: [GoPro 0456] pair Attempting to pair with DF:34:ED:D1:DA:E8 [CHG] Device DF:34:ED:D1:DA:E8 Paired: yes Pairing successful Once paired, the camera should beep and display “Connection Successful”. Also, the device should show up when querying bluetoothctl for paired devices: [GoPro 0456] paired-devices Device DF:34:ED:D1:DA:E8 GoPro 0456 It is now no longer necessary to pair on subsequent connections. Enable Notifications Enter Gatt Menu Enable Notifications As specified in the Open GoPro Bluetooth API, we must enable notifications for a given characteristic to receive responses from it. First, let’s enter the gatt submenu: [GoPro 0456] menu gatt Menu gatt: Available commands: ------------------- list-attributes [dev/local] List attributes select-attribute &lt;attribute/UUID&gt; Select attribute attribute-info [attribute/UUID] Select attribute read [offset] Read attribute value write &lt;data=xx xx ...&gt; [offset] [type] Write attribute value acquire-write Acquire Write file descriptor release-write Release Write file descriptor acquire-notify Acquire Notify file descriptor release-notify Release Notify file descriptor notify &lt;on/off&gt; Notify attribute value clone [dev/attribute/UUID] Clone a device or attribute register-application [UUID ...] Register profile to connect unregister-application Unregister profile register-service &lt;UUID&gt; [handle] Register application service. unregister-service &lt;UUID/object&gt; Unregister application service register-includes &lt;UUID&gt; [handle] Register as Included service in. unregister-includes &lt;Service-UUID&gt;&lt;Inc-UUID&gt; Unregister Included service. register-characteristic &lt;UUID&gt; &lt;Flags=read,write,notify...&gt; [handle] Register application characteristic unregister-characteristic &lt;UUID/object&gt; Unregister application characteristic register-descriptor &lt;UUID&gt; &lt;Flags=read,write...&gt; [handle] Register application descriptor unregister-descriptor &lt;UUID/object&gt; Unregister application descriptor back Return to main menu version Display version quit Quit program exit Quit program help Display help about this program export Print environment variables Go the the next tab to enable notifications Now, we need to enable notifications for the relevant characteristic. In this demo, we will only be setting the shutter. This command is sent on the “Command Request” characteristic and it’s responses are received as notifications on the “Command Response” characteristic. So we only care about the “Command Response” characteristic which has UUID b5f90073-aa8d-11e3-9046-0002a5d5c51b. You can see this UUID listed above when the connection was formed. All attributes can also be found again from bluetoothctl with list-attributes To enable notifications, select the attribute then enable notifications: [GoPro 0456] select-attribute b5f90073-aa8d-11e3-9046-0002a5d5c51b [GoPro 0456:/service0031/char0034] acquire-notify [CHG] Attribute /org/bluez/hci0/dev_CA_D7_FF_49_B1_27/service0031/char0034 NotifyAcquired: yes AcquireNotify success: fd 7 MTU 335 Since we are acquiring (using the BlueZ terminology as in the command) notifications, this means that we will be alerted of responses when the characteristic is notified. Quiz time! 📚 ✏️ How are responses to the Command Request characteristic received over BLE? A: As write responses to the Command Request characteristic B: As notifications of the Command Response characteristic C: There is no response since this characteristic is Write-without-Response D: They must be polled by reading the Command Response characteristic Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is B. All GoPro commands follow the same behavior: a command is first sent on a request characteristic. The response is then notified on the response characteristic (assuming notifications are enabled). How often is it necessary to pair? A: Pairing must occur every time to ensure safe BLE communication B: We never need to pair as the GoPro does not require it to communicate C: Pairing only needs to occur once as BlueZ will automatically re-use the shared keys for future connections Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is C. Pairing is only needed once (assuming neither side deletes the keys). If the GoPro deletes the keys (via Connections-&gt;Reset Connections or a factory reset), the devices will need to re-pair. Sending Commands Now that we are are connected, paired, and have enabled notifications, we can send commands. The command we will be sending is Set Shutter, which at byte level is: Command Bytes Set Shutter Off 0x03 0x01 0x01 0x00 Set Shutter On 0x03 0x01 0x01 0x01 First, we need to choose the attribute to write to which is the “Command Request” characteristic with UUID b5f90072-aa8d-11e3-9046-0002a5d5c51b. This is done via select-attribute: [GoPro 0456:/service0031/char0034] select-attribute b5f90072-aa8d-11e3-9046-0002a5d5c51b [GoPro 0456:/service0031/char0032] attribute-info Characteristic - Vendor specific UUID: b5f90072-aa8d-11e3-9046-0002a5d5c51b Service: /org/bluez/hci0/dev_DF_34_ED_D1_DA_E8/service0031 Flags: write As a bonus, you can then call “attribute-info” to verify that this characteristic is writeable. Send Commands Set Shutter On Set Shutter Off Now, let’s write the bytes to turn the shutter on and start encoding! [GoPro 0456:/service0031/char0032] write \"0x03 0x01 0x01 0x01\" Attempting to write /org/bluez/hci0/dev_CA_D7_FF_49_B1_27/service0031/char0032 [CHG] /org/bluez/hci0/dev_CA_D7_FF_49_B1_27/service0031/char0034 Notification: 02 01 00 You should hear the camera beep and it will either take a picture or start recording depending on what mode it is in. Also note that we have received the “Command Status” notification response from the Command Response characteristic since we acquired it’s notifications in [Enable Notifications] If you are recording a video, go to the next tab to set the shutter off. We can now set the shutter off: [GoPro 0456:/service0031/char0032] write \"0x03 0x01 0x01 0x00\" Attempting to write /org/bluez/hci0/dev_CA_D7_FF_49_B1_27/service0031/char0032 [CHG] /org/bluez/hci0/dev_CA_D7_FF_49_B1_27/service0031/char0034 Notification: 02 01 00 Good Job! Congratulations 🤙 You can now send any of the other BLE commands detailed in the Open GoPro documentation in a similar manner. Troubleshooting GoPro Stops Advertising Sometimes the GoPro will stop advertising. A quick fix at this point is to power cycle the camera by pulling and then re-inserting the battery. Complete System Reset BLE is a fickle beast. If at any point it is impossible to discover or connect to the camera, perform the following. Reset the camera by choosing Connections –&gt; Reset Connections Power cycle the bluetooth adapter: [bluetooth] power off Changing power off succeeded [CHG] Controller FC:44:82:DD:5A:3F Powered: no [CHG] Controller FC:44:82:DD:5A:3F Discovering: no [CHG] Controller FC:44:82:DD:5A:3F Class: 0x00000000 [bluetooth] power on [CHG] Controller FC:44:82:DD:5A:3F Class: 0x002c010c Changing power on succeeded [CHG] Controller FC:44:82:DD:5A:3F Powered: yes Remove the GoPro from the paired devices: [bluetooth] paired-devices Device DF:34:ED:D1:DA:E8 GoPro 0456 [bluetooth] remove DF:34:ED:D1:DA:E8 Restart the procedure detailed above Logs It is also possible to get some bluetooth system logs. To enable debug information and view HCI Trace information from the Bluetooth Monitor: sudo sed -i 's/bluetoothd/bluetoothd \\-d/g' /lib/systemd/system/bluetooth.service sudo btmon To view the DBus log (i.e. to see BlueZ messages): sudo dbus-monitor --system You can search this for “bluez” but not every relevant Bluetooth message will include it.",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/tutorials/bash/bluez#"
        },
        {
            "title": "GoPro C/C++ Demos: ",
            "excerpt": "This folder contains C and C++ examples to perform some Open GoPro functionality. There are two examples, each of which are detailed in a section below. Media Commands Stream Commands Requirements To build these demos as is, libCurl and cJSON are necessary. libCurl is a client-side URL transfer library. This is used to make command requests to the camera over WiFi and get the JSON response. cJSON is an ultra-light JSON parser that can be used to parse the JSON responses from the WiFi commands. Both can be used in either C or C++ and work for MacOS, Linux and Windows. To connect to the camera: Connect BLE to turn on AP and get WiFi SSID/PASSPHRASE Use retrieved WiFi SSID/PASSPHRASE to connect system to GoPro WiFi Media Commands This demo demonstrates one way to get the media list and download the first media file. It also supports requests to get the media list, media info and downloading specific media files. Media List: $ ./bin/media_commands &lt;-l, --list_files&gt; Media List(Pretty Print): $ ./bin/media_commands &lt;-f, --list_files_pretty&gt; Media Info: $ ./bin/media_commands &lt;-i, --info&gt; &lt;camera_file_path&gt; Media Info(Pretty Print): $ ./bin/media_commands &lt;-p, --info_pretty&gt; &lt;camera_file_path&gt; Media Download: $ ./bin/media_commands &lt;-g, --download &lt;camera_file_path&gt; &lt;output_path/output_file_name&gt;&gt; Media Demo: $ ./bin/media_commands &lt;-d, --demo&gt; &lt;output_path&gt; Stream Commands This demo demonstrates one way to start and stop the preview stream. Note: To run the Preview Stream demo. A media player (i.e: VLC) that supports UDP is needed to view the preview stream. The UDP address is udp://0.0.0.0:8554 Start Stream: $ ./bin/stream_commands &lt;-s, --start&gt; Stop Stream: $ ./bin/stream_commands &lt;-e, --end&gt; Preview Stream Demo: $ ./bin/stream_commands &lt;-d, --demo&gt;",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/demos/c_c++/GoProC_C++Demo#"
        },
        {
            "title": "GoProCSharpSample: ",
            "excerpt": "This sample demonstrates how to discover, pair, and connect to a GoPro camera via Bluetooth LE (BLE). Once a connection is established, the code shows how to: Enable Wi-Fi on the GoPro camera Read the camera wifi name and password Get status and notification of camera’s battery level, encoding flag, and wifi ap on flag. Start and stop camera shutter Requirements Visual Studio is required to run the solution. Visit https://visualstudio.microsoft.com/downloads/ to download. The target .NET framework is v4.7.2 GoPro camera must be paired before any other operations will succeed. Put the camera in pairing mode before attempting pairing with the app. Usage Open and run the demo in Visual Studio to show the GUI Scan for GoPro devices Pair to the discovered device that is not GoPro Cam. In the .gif below, this is GoPro 0456 (Only needs to be done once, or if camera is factory reset) After pairing is successful, connect to the same GoPro device Now use any of the GUI buttons to read WiFi info, enable WiFi AP, set shutter, etc.",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/demos/csharp/GoProCSharpSample#"
        },
        {
            "title": "CSharp Webcam Demo: ",
            "excerpt": "This demo implements a simple GUI to interact with a GoPro camera that supports Open GoPro 2.0. Requirements This demo will only run on Windows. Visual Studio is required to run the solution. Visit VisualStudio to download. The target .NET framework is v4.7.2 GoPro camera must be paired before any other operations will succeed. Put the camera in pairing mode before attempting pairing with the app. Prerequisites The correct GoPro Webcam drivers must be installed. To verify this, ensure that you can first use your desired GoPro as a webcam following the steps here. Usage Connect the GoPro to your computer using the USB cable Open the solution (GoProWebCamViewer.sln) in Visual Studio, build and run io to show the Webcam GUI Select Start Player to start the VLC backend. Note that the log and status bar have updated. This will be true for all functionality. Select Show Preview to start a low quality preview stream While in preview, feel free to update the FOV or change the zoom Once you are ready, select Start Webcam to start full resolution streaming",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/demos/csharp/webcam#"
        },
        {
            "title": "Go Pro demo Ionic + Capacitor 3: ",
            "excerpt": "Connect phone to GoPro via bluetooth Send Bluetooth Commands (take photo, get wifi creds, shut down) Connect phone to GoPro via WiFi Download files to phone from GoPro via WiFi You can also preview video demos for iOS Android Dependencies for bluetooth https://github.com/capacitor-community/bluetooth-le plugin is used for WiFI https://github.com/digaus/community-capacitor-wifi plugin is used Run on your computer install ionic CLI git clone https://github.com/gopro/OpenGoPro.git cd project cd OpenGoPro/demos/ionic/file_transfer run npm install run ionic build run ionic cap sync for ios run ionic cap open ios connect real device click run app button for android run ionic cap open android connect real device click run app iOS Android",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/demos/ionic/file_transfer#"
        },
        {
            "title": "Open GoPro Python SDK: ",
            "excerpt": "This is a Python package that provides an interface for the user to exercise the Open GoPro Bluetooth Low Energy (BLE) and Wi-Fi API’s as well as install command line interfaces to take photos, videos, and view the preview stream. Free software: MIT license Documentation: View on Open GoPro View on Github Documentation Note! This README is only an overview of the package. Complete documentation can be found on Open GoPro Features Top-level GoPro class interface to use both BLE / WiFi Cross-platform (tested on MacOS Big Sur, Windows 10, and Ubuntu 20.04) BLE implemented using bleak Wi-Fi controller provided in the Open GoPro package (loosely based on the Wireless Library Supports all commands, settings, and statuses from the Open GoPro API Supports all versions of the Open GoPro API Automatically handles connection maintenance: manage camera ready / encoding periodically sends keep alive signals Includes detailed logging for each module Includes demo scripts installed as command-line applications to show BLE and WiFi functionality Take a photo Take a video View the live stream Log the battery Installation Note! This package requires Python &gt;= 3.8 $ pip install open-gopro Usage To automatically connect to GoPro device via BLE and WiFI, set the preset, set video parameters, take a video, and download all files: import time from open_gopro import GoPro, Params with GoPro() as gopro: gopro.ble_command.load_preset(Params.Preset.CINEMATIC) gopro.ble_setting.resolution.set(Params.Resolution.RES_4K) gopro.ble_setting.fps.set(Params.FPS.FPS_30) gopro.ble_command.set_shutter(Params.Shutter.ON) time.sleep(2) Record for 2 seconds gopro.ble_command.set_shutter(Params.Shutter.OFF) Download all of the files from the camera media_list = [x[\"n\"] for x in gopro.wifi_command.get_media_list().flatten for file in media_list: gopro.wifi_command.download_file(camera_file=file) And much more! Demos Note! These demos can be found on Github Demos can be found in the installed package in the “demos” folder. They are installed as a CLI entrypoint and can be run via: Capture a photo and download it to your computer: $ gopro-photo Capture a video and download it to your computer: $ gopro-video Start the preview stream and view it with VLC: $ gopro-stream Connect to the GoPro and log battery consumption in to a .csv: $ gopro-log-battery Connect to the GoPro’s Wi-Fi AP and maintain the connection: $ gopro-wifi For more information on each, try running with help as such: $ gopro-photo --help usage: gopro-photo [-h] [-i IDENTIFIER] [-l LOG] [-o OUTPUT] [-w WIFI_INTERFACE] Connect to a GoPro camera, take a photo, then download it. optional arguments: -h, --help show this help message and exit -i IDENTIFIER, --identifier IDENTIFIER Last 4 digits of GoPro serial number, which is the last 4 digits of the default camera SSID. If not used, first discovered GoPro will be connected to -l LOG, --log LOG Location to store detailed log -o OUTPUT, --output OUTPUT Where to write the photo to. If not set, write to 'photo.jpg' -w WIFI_INTERFACE, --wifi_interface WIFI_INTERFACE System Wifi Interface. If not set, first discovered interface will be used.",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/demos/python/sdk_wireless_camera_control#"
        },
        {
            "title": "Swift Enable WiFi Demo: ",
            "excerpt": "This demo demonstrates how to discover and connect to a GoPro camera via Bluetooth LE (BLE). Once a connection is established, the demo demonstrates how to enable Wi-Fi on the GoPro camera and join the camera’s Wi-Fi. The steps required to join camera’s Wi-Fi are: Enable Wi-Fi Request camera’s Wi-Fi settings (SSID and password) Use iOS NetworkExtension API to join camera’s WiFi Requirements GoPro camera must be paired with the mobile device. If the camera is not paired, put the camera in pairing mode File Structure BLE CentralManager.swift - A simple wrapper around CBCentralManager to handle CoreBluetooth Central related tasks Peripheral.swift - A simple wrapper around CBPeripheral to handle CoreBluetooth Peripheral related tasks Peripheral+Camera.swift - An extension of Peripheral class for sending commands to a GoPro camera Views CameraSelectionView.swift - A SwiftUI list view for showing the nearby GoPro cameras CameraView.swift - A simple view with a button for initiate the request to enable Wi-Fi on the connected GoPro camera",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/demos/swift/EnableWiFiDemo#"
        },
        {
            "title": "Python Tutorial 1: Connect BLE: ",
            "excerpt": "This tutorial will provide a walk-through to connect to the GoPro camera via BLE using bleak. Requirements Hardware One of the following systems: Windows 10, version 16299 (Fall Creators Update) or greater Linux distribution with BlueZ &gt;= 5.43 OS X/macOS support via Core Bluetooth API, from at least OS X version 10.11 A GoPro camera that is supported by Open GoPro Software Python Python 3.8.x must be installed. See this Python installation guide. Tutorials Package This set of tutorials is accompanied by a Python package consisting of scripts (separated by tutorial module). These can be found on Github. Once the Github repo has been cloned or downloaded to your local machine, the package can be installed as follows: Enter the python tutorials directory at $INSTALL/demos/python/tutorial/ where $INSTALL is the top level of the Open GoPro repo where it exists on your local machine Use pip to install the requirements file: pip install -r requirements.txt This will also install the Open GoPro Python SDK which will be used for some of the optional examples through these tutorials. You can test that installation was successful by viewing the installed package’s information: $ pip show open-gopro-python-tutorials Name: open-gopro-python-tutorials Version: 0.0.2 Summary: Open GoPro Python Tutorials Home-page: https://github.com/gopro/OpenGoPro Author: GoPro Author-email: gopro.com License: MIT Location: c:\\gopro\\opengopro\\tutorials\\python\\bleak Requires: bleak Required-by: The scripts that will be used for this tutorial can be found in the Tutorial 1 Folder. Basic BLE Tutorial This tutorial will walk through the process of connecting to the GoPro via Bluetooth Low Energy (BLE). It is basically just an explanation of the ble_connect.py. This same connect functionality will be used as a foundation for all future BLE tutorials. Here is a summary of the sequence that will be described in detail in the following sections: A Special Consideration for BlueZ The Bleak BLE controller does not currently support autonomous pairing for the BlueZ backend. So if you are using BlueZ (i.e. Ubuntu, RaspberryPi, etc.), you need to first pair the camera from the command line as shown in the BlueZ tutorial. There is work to add this feature and progress can be tracked on the Github Issue. Just Show me the Demo!! If you just want to run the demo, you can do: python ble_connect.py Python &gt;= 3.8.x must be used as specified in the requirements See the help for parameter definition: $ python ble_connect.py --help usage: ble_connect.py [-h] [-i IDENTIFIER] Connect to a GoPro camera, pair, then enable notifications. optional arguments: -h, --help show this help message and exit -i IDENTIFIER, --identifier IDENTIFIER Last 4 digits of GoPro serial number, which is the last 4 digits of the default camera SSID. If not used, first discovered GoPro will be connected to Asyncio The bleak module is based on asyncio which means that its awaitable functions need to be called from an async coroutine. In order to do this, all of the code below should be running in an async function. We accomplish this in the tutorial scripts by making main async as such: import asyncio async def main() -&gt; None: Put our code here if __name__ == \"__main__\": asyncio.run(main()) Advertise First, we need to ensure the camera is discoverable (i.e. it is advertising). Ensure that the Camera is powered on, then select Connections –&gt; Connect Device –&gt; Quik App The screen should appear as such: Camera is discoverable. Scan code output Next, we must find the GoPro Camera using bleak. Let’s initialize an empty dict that will store discovered devices, indexed by name: Map of devices indexed by name devices: Dict[str, BleakDevice] = {} We’re then going to scan for all devices. We are passing a scan callback to bleak in order to also find non-connectable scan responses. We are keeping any devices that have a device name. Scan callback to also catch nonconnectable scan responses def _scan_callback(device: BleakDevice, _: Any) -&gt; None: Add to the dict if not unknown if device.name != \"Unknown\" and device.name is not None: devices[device.name] = device Now discover and add connectable advertisements for device in await BleakScanner.discover(timeout=5, detection_callback=_scan_callback): if device.name != \"Unknown\" and device.name is not None: devices[device.name] = device Now we can search through the discovered devices to see if we found a GoPro. Any GoPro device name will be structured as GoPro XXXX where XXXX is the last four digits of your camera’s serial number. First, we define a regex which is either “GoPro “ followed by any four alphanumeric characters if no identifier was passed, or “GoPro “ concatenated with the identifier if it exists. In the demo ble_connect.py, the identifier is taken from the command-line arguments. token = re.compile(r\"GoPro [A-Z0-9]{4}\" if identifier is None else f\"GoPro {identifier}\") Now we build a list of matched devices by checking if each device’s name includes the token regex. matched_devices: List[BleakDevice] = [] Now look for our matching device(s) matched_devices = [device for name, device in devices.items() if token.match(name)] Due to potential RF interference and the asynchronous nature of BLE advertising / scanning, it is possible that the advertising GoPro will not be discovered by the scanning PC in one scan. Therefore, you may need to redo the scan (as ble_connect.py does) until a GoPro is found. That is, matched_device must contain at least one device. When running the demo, discovered devices will be logged to the console as they are found. Click the output tab to see an example of this. Here is an example of the log from `ble_connect.py` of scanning for devices. Note that this includes several rescans until the devices was found. $ python ble_connect.py INFO:root:Scanning for bluetooth devices... INFO:root: Discovered: INFO:root: Discovered: TR8600 seri INFO:root:Found 0 matching devices. INFO:root: Discovered: INFO:root: Discovered: TR8600 seri INFO:root: Discovered: GoPro Cam INFO:root: Discovered: GoPro 0456 INFO:root:Found 1 matching devices. Among other devices, you should see GoPro XXXX where XXXX is the last four digits of your camera’s serial number. Connect code output Now that we have discovered at least one GoPro device to connect to, the next step is to establish a BLE connection to the camera as such: We're just taking the first device if there are multiple. device = matched_devices[0] client = BleakClient(device) await client.connect(timeout=15) Click the output tab to see an example of what the log from ble_connect.py will show. INFO:root:Establishing BLE connection to EF:5A:F6:13:E6:5A: GoPro 0456... INFO:bleak.backends.dotnet.client:Services resolved for BleakClientDotNet (EF:5A:F6:13:E6:5A) INFO:root:BLE Connected! Here we can see that the connection has successfully been established as well as the GoPro’s BLE MAC address. Pair The GoPro has encryption-protected characteristics which require us to pair before writing to them. Therefore now that we are connected, we need to attempt to pair: try: await client.pair() except NotImplementedError: This is expected on Mac pass Not all OS’s allow pairing but some require it. Rather than checking for the OS, we are just catching the exception when it fails. Once paired, the camera should beep and display “Connection Successful”. It is now no longer necessary to pair on subsequent connections. Enable Notifications enable output As specified in the Open GoPro Bluetooth API, we must enable notifications for a given characteristic to receive responses from it. It is necessary to define a notification handler to pass to the bleak start_notify method. Since we only care about connecting to the device in this tutorial (and not actually receiving data), we are just passing an empty function. A future tutorial will demonstrate how to use this meaningfully. To enable notifications, we loop over each characteristic in each service and enable the characteristic for notification if it has notify properties: for service in client.services: for char in service.characteristics: if \"notify\" in char.properties: await client.start_notify(char, notification_handler) Go to the next tab to see the log output. Here we can see that notifications are enabled for each characteristic that is notifiable. INFO:root:Enabling notifications... INFO:root:Enabling notification on char 00002a19-0000-1000-8000-00805f9b34fb INFO:root:Enabling notification on char b5f90073-aa8d-11e3-9046-0002a5d5c51b INFO:root:Enabling notification on char b5f90075-aa8d-11e3-9046-0002a5d5c51b INFO:root:Enabling notification on char b5f90077-aa8d-11e3-9046-0002a5d5c51b INFO:root:Enabling notification on char b5f90079-aa8d-11e3-9046-0002a5d5c51b INFO:root:Enabling notification on char b5f90092-aa8d-11e3-9046-0002a5d5c51b INFO:root:Enabling notification on char b5f90081-aa8d-11e3-9046-0002a5d5c51b INFO:root:Enabling notification on char b5f90083-aa8d-11e3-9046-0002a5d5c51b INFO:root:Enabling notification on char b5f90084-aa8d-11e3-9046-0002a5d5c51b INFO:root:Done enabling notifications The characteristics that correspond to each UUID listed in the log can be found in the Open GoPro API. These will be used in a future tutorial to send data. Quiz time! 📚 ✏️ How often is it necessary to pair? A: Pairing must occur every time to ensure safe BLE communication. B: We never need to pair as the GoPro does not require it to communicate. C: Pairing only needs to occur once as the keys will be automatically re-used for future connections. Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is C. Pairing is only needed once (assuming neither side deletes the keys). If the GoPro deletes the keys (via Connections-&gt;Reset Connections), the devices will need to re-pair. Troubleshooting Device not connecting If the connection is not starting, it is likely because the camera is not advertising. This can be due to either: The camera is not in pairing mode. Ensure that this is achieved as done in the advertise section. The devices never disconnected from the previous session so are thus already connected. If this is the case, perform the “Complete System Reset” shown below. Complete System Reset BLE is a fickle beast. If at any point it is impossible to discover or connect to the camera, perform the following. Reset the camera by choosing Connections –&gt; Reset Connections Use your OS’s bluetooth settings GUI to remove / unpair the Gopro Restart the procedure detailed above Logs The demo program has enabled bleak logs and is also using the default python logging module to write its own logs. To enable more bleak logs, follow bleak’s troubleshooting section. Good Job! Congratulations 🤙 You can now successfully connect to the GoPro via BLE and prepare it to receive / send data. To see how to send commands, you should advance to the next tutorial.",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/tutorials/python/connect-ble#"
        },
        {
            "title": "Python Tutorial 2: Send BLE Commands: ",
            "excerpt": "This document will provide a walk-through tutorial to use bleak to implement the Open GoPro Interface to send commands and receive responses. Commands in this sense are specifically procedures that are initiated by either: Writing to the Command Request UUID and receiving responses via the Command Response UUID. They are listed here. Writing to the Setting UUID and receiving responses via the Setting Response UUID. They are listed here. It is required that you have first completed the connect tutorial before going through this tutorial. This tutorial only considers sending these commands as one-off commands. That is, it does not consider state management / synchronization when sending multiple commands. This will be discussed in a future lab. Requirements It is assumed that the hardware and software requirements from the connect tutorial are present and configured correctly. The scripts that will be used for this tutorial can be found in the Tutorial 2 Folder. Just Show me the Demo(s)!! Each of the commands detailed in Sending Commands has a corresponding script to demo it. If you don’t want to read this tutorial and just want to see the demo, for example, run: $ python ble_command_set_shutter.py Python &gt;= 3.8.x must be used as specified in the requirements Note that each script has a command-line help which can be found via: $ python ./ble_command_set_shutter.py --help usage: ble_command_set_shutter.py [-h] [-i IDENTIFIER] Connect to a GoPro camera, set the shutter on, wait 2 seconds, then set the shutter off. optional arguments: -h, --help show this help message and exit -i IDENTIFIER, --identifier IDENTIFIER Last 4 digits of GoPro serial number, which is the last 4 digits of the default camera SSID. If not used, first discovered GoPro will be connected to Setup We must first connect as was discussed in the connect tutorial. In this case, however, we are defining a meaningful (albeit naive) notification handler that will: print byte data and handle that the notification was received on check if the response is what we expected set an event to notify the writer that the response was received This is a very simple handler: response parsing will be expanded upon in the next tutorial. def notification_handler(handle: int, data: bytes) -&gt; None: logger.info(f'Received response at {handle=}: {hexlify(data, \":\")!r}') If this is the correct handle and the status is success, the command was a success if client.services.characteristics[handle].uuid == response_uuid and data[2] == 0x00: logger.info(\"Command sent successfully\") Anything else is unexpected. This shouldn't happen else: logger.error(\"Unexpected response\") Notify the writer event.set() The event used above is a simple synchronization event that is only alerting the writer that a notification was received. There is much more to the synchronization and data parsing than this but this will be discussed in future tutorials. For now, we’re just checking that the handle matches what is expected and that the status (third byte) is success (0x00). Command Overview Both Command Requests and Setting Requests follow the same procedure: Write to relevant request UUID Receive confirmation from GoPro (via notification from relevant response UUID) that request was received. GoPro reacts to command The notification response only indicates that the request was received and whether it was accepted or rejected. The relevant behavior of the GoPro must be observed to verify when the command’s effects have been applied. Here is the procedure from power-on to finish: Sending Commands Now that we are are connected, paired, and have enabled notifications (using our defined callback), we can send commands. First, we need to define the attributes to write to and receive responses from, which, for commands, are the “Command Request” characteristic (UUID b5f90072-aa8d-11e3-9046-0002a5d5c51b) and “Command Response” characteristic (UUID b5f90073-aa8d-11e3-9046-0002a5d5c51b). COMMAND_REQ_UUID = GOPRO_BASE_UUID.format(\"0072\") COMMAND_RSP_UUID = GOPRO_BASE_UUID.format(\"0073\") Or, for settings, the “Settings” characteristic (UUID b5f90074-aa8d-11e3-9046-0002a5d5c51b) and “Settings Response” (UUID b5f90075-aa8d-11e3-9046-0002a5d5c51b). SETTINGS_REQ_UUID = GOPRO_BASE_UUID.format(\"0074\") SETTINGS_RSP_UUID = GOPRO_BASE_UUID.format(\"0075\") We’re using the GOPRO_BASE_UUID string imported from the module’s __init__.py to build these. Set Shutter The first command we will be sending is Set Shutter, which at byte level is: Command Bytes Set Shutter Off 0x03 0x01 0x01 0x00 Set Shutter On 0x03 0x01 0x01 0x01 Set Shutter On Set Shutter Off Now, let’s write the bytes to the “Command Request” UUID to turn the shutter on and start encoding! event.clear() await client.write_gatt_char(COMMAND_REQ_UUID, bytearray([3, 1, 1, 1])) await event.wait() Wait to receive the notification response We make sure to clear the synchronization event before writing, then pend on the event until it is set in the notification callback. You should hear the camera beep and it will either take a picture or start recording depending on what mode it is in. Also note that we have received the “Command Status” notification response from the Command Response characteristic since we enabled its notifications in Enable Notifications. This can be seen in the demo log: INFO:root:Setting the shutter on INFO:root:Received response at handle=52: b'02:01:00' INFO:root:Shutter command sent successfully As expected, the response was received on the correct handle and the status was “success”. If you are recording a video, go to the next tab to set the shutter off. We can now set the shutter off: We’re waiting 2 seconds in case you are in video mode so that we can capture a 2 second video. time.sleep(2) event.clear() await client.write_gatt_char(COMMAND_REQ_UUID, bytearray([3, 1, 1, 0])) await event.wait() Wait to receive the notification response This will log in the console as follows: INFO:root:Setting the shutter off INFO:root:Received response at handle=52: b'02:01:00' INFO:root:Shutter command sent successfully Sleep The next command we will be sending is Sleep, which at byte level is: Command Bytes Sleep 0x01 0x05 Now, let’s write the bytes to the “Command Request” UUID to put the camera to sleep! event.clear() await client.write_gatt_char(COMMAND_REQ_UUID, bytearray([0x01, 0x05])) await event.wait() Wait to receive the notification response We make sure to clear the synchronization event before writing, then pend on the event until it is set in the notification callback. You should hear the camera beep display a spinner showing “Powering Off” Also note that we have received the “Command Status” notification response from the Command Response characteristic since we enabled its notifications in Enable Notifications.. This can be seen in the demo log: INFO:root:Putting the camera to sleep INFO:root:Received response at handle=52: b'02:05:00' INFO:root: Command sent successfully As expected, the response was received on the correct handle and the status was “success”. Since the camera has gone to sleep, it must be reconnected to via BLE to communicate again as detailed in the connect tutorial. Load Preset Group The next command we will be sending is Load Preset Group, which is used to toggle between the 3 groups of presets (video, photo, and timelapse). At byte level, the commands are: Command Bytes Load Video Preset Group 0x04 0x3E 0x02 0x03 0xE8 Load Photo Preset Group 0x04 0x3E 0x02 0x03 0xE9 Load Timelapse Preset Group 0x04 0x3E 0x02 0x03 0xEA Now, let’s write the bytes to the “Command Request” UUID to change the preset group to Video! event.clear() await client.write_gatt_char(COMMAND_REQ_UUID, bytearray([0x04, 0x3E, 0x02, 0x03, 0xE8])) await event.wait() Wait to receive the notification response We make sure to clear the synchronization event before writing, then pend on the event until it is set in the notification callback. You should hear the camera beep and move to the Video Preset Group. You can tell this by the logo at the top middle of the screen: Load Preset Group Also note that we have received the “Command Status” notification response from the Command Response characteristic since we enabled its notifications in Enable Notifications.. This can be seen in the demo log: INFO:root:Loading the video preset group... INFO:root:Received response at handle=52: b'02:3e:00' INFO:root:Command sent successfully As expected, the response was received on the correct handle and the status was “success”. Load Preset The next command we will be sending is Load Preset, which is used to select a specific preset that is part of a Preset Group. At byte level, some of the commands for the various preset are: Command Bytes Load Cinematic Preset 0x06 0x40 0x04 0x00 0x00 0x00 0x02 Load Slo-Mo Preset 0x06 0x40 0x04 0x00 0x00 0x00 0x03 Load Burst Photo Preset 0x06 0x40 0x04 0x00 0x01 0x00 0x02 Load Night Photo Preset 0x06 0x40 0x04 0x00 0x01 0x00 0x03 It is possible that the preset ID values will vary in future cameras. The only absolutely correct way to know the preset ID is to read them from the “Get Preset Status” protobuf command. A future lab will discuss protobuf commands. Now, let’s write the bytes to the “Command Request” UUID to change the preset to Cinematic! event.clear() await client.write_gatt_char(COMMAND_REQ_UUID, bytearray([0x06, 0x40, 0x04, 0x00, 0x00, 0x00, 0x02])) await event.wait() Wait to receive the notification response We make sure to clear the synchronization event before writing, then pend on the event until it is set in the notification callback. You should hear the camera beep and switch to the Cinematic Preset (assuming it wasn’t already set). You can verify this by seeing the preset name in the pill at bottom middle of the screen. Load Preset Also note that we have received the “Command Status” notification response from the Command Response characteristic since we enabled its notifications in Enable Notifications.. This can be seen in the demo log: INFO:root:Loading the cinematic preset... INFO:root:Received response at handle=52: b'02:40:00' INFO:root:Command sent successfully As expected, the response was received on the correct handle and the status was “success”. Enable Analytics The next command we will be sending is Enable Analytics, which at byte level is: Command Bytes Enable Analytics 0x01 0x50 This command is used to notify that a Third Party is using the Open GoPro API. It should be called after each connection. The use of this command by third parties will help improve Open GoPro. Now, let’s write the bytes to the “Command Request” UUID to enable analytics. event.clear() await client.write_gatt_char(COMMAND_REQ_UUID, bytearray([0x01, 0x50])) await event.wait() Wait to receive the notification response We make sure to clear the synchronization event before writing, then pend on the event until it is set in the notification callback. Also note that we have received the “Command Status” notification response from the Command Response characteristic since we enabled its notifications in Enable Notifications.. This can be seen in the demo log: INFO:root:Enabling analytics... INFO:root:Received response at handle=52: b'02:50:00' INFO:root:Command sent successfully As expected, the response was received on the correct handle and the status was “success”. Set the Video Resolution The next command we will be sending is Set Video Resolution. This is used to change the value of the Video Resolution setting. It is important to note that this only affects video resolution (not photo). Therefore, the Video Preset Group must be active in order for it to succeed. This can be done either manually through the camera UI or by sending Load Preset Group. This resolution only affects the current video preset. Each video preset can have its own independent values for video resolution. Here are some of the byte level commands for various video resolutions. Command Bytes Set Video Resolution to 1080 0x03 0x02 0x01 0x09 Set Video Resolution to 2.7K 0x03 0x02 0x01 0x04 Set Video Resolution to 4K 0x03 0x02 0x01 0x18 Note that the possible resolution values can vary based on the Open GoPro version that the camera supports. Therefore, it is necessary to check the version. Now, let’s write the bytes to the “Setting Request” UUID to change the video resolution to 1080! event.clear() await client.write_gatt_char(SETTINGS_REQ_UUID, bytearray([0x03, 0x02, 0x01, 0x09])) await event.wait() Wait to receive the notification response We make sure to clear the synchronization event before writing, then pend on the event until it is set in the notification callback. You should hear the camera beep and see the video resolution change to 1080 in the pill in the bottom-middle of the screen: Set Video Resolution Also note that we have received the “Command Status” notification response from the Command Response characteristic since we enabled its notifications in Enable Notifications.. This can be seen in the demo log: INFO:root:Loading the video preset group... INFO:root:Received response at handle=52: b'02:3e:00' INFO:root:Command sent successfully As expected, the response was received on the correct handle and the status was “success”. If the Preset Group was not Video, the status will not be success. Set the Frames Per Second (FPS) The next command we will be sending is Set FPS. This is used to change the value of the FPS setting. It is important to note that this setting is dependent on the video resolution. That is, certain FPS values are not valid with certain resolutions. In general, higher resolutions only allow lower FPS values. Also, the current anti-flicker value may further limit possible FPS values. Check the camera capabilities to see which FPS values are valid for given use cases. Therefore, for this step of the tutorial, it is assumed that the resolution has been set to 1080 as in Set the Video Resolution. Here are some of the byte level commands for various FPS values. Command Bytes Set FPS to 24 0x03 0x03 0x01 0x0A Set FPS to 60 0x03 0x03 0x01 0x05 Set FPS to 240 0x03 0x03 0x01 0x00 Note that the possible FPS values can vary based on the Open GoPro version that the camera supports. Therefore, it is necessary to check the version. Now, let’s write the bytes to the “Setting Request” UUID to change the FPS to 240! event.clear() await client.write_gatt_char(SETTINGS_REQ_UUID, bytearray([0x03, 0x03, 0x01, 0x00])) await event.wait() Wait to receive the notification response We make sure to clear the synchronization event before writing, then pend on the event until it is set in the notification callback. You should hear the camera beep and see the FPS change to 240 in the pill in the bottom-middle of the screen: Set FPS Also note that we have received the “Command Status” notification response from the Command Response characteristic since we enabled its notifications in Enable Notifications.. This can be seen in the demo log: INFO:root:Setting the fps to 240 INFO:root:Received response at handle=57: b'02:03:00' INFO:root:Command sent successfully As expected, the response was received on the correct handle and the status was “success”. If the video resolution was higher, for example 5K, this would fail. Quiz time! 📚 ✏️ Which of the following is not a real preset group? A: Timelapse B: Photo C: Burst D: Video Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is C. There are 3 preset groups (Timelapse, Photo, and Video). These can be set via the Load Preset Group command. Which of the following sets of FPS values are possible at 5K? A: [24, 25, 30] B: [24, 25, 30, 60] C: [24, 25, 30, 60, 120] D: Any FPS is valid in at 5k Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is A. Among these options, only 24 is possible. You’re not actually expected to know this. But you should know where to find the information: https://gopro.github.io/OpenGoPro/blecamera-capabilities True or False: Every camera supports the same combination of resolution and FPS values. A: True B: False Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is B. The only way to know what values are supported is to first check the Open GoPro version. See the relevant version of the BLE or WiFi spec to see what is supported. Troubleshooting See the first tutorial’s troubleshooting section. Good Job! Congratulations 🤙 You can now send any of the other BLE commands detailed in the Open GoPro documentation in a similar manner. To see how to parse more complicate responses, proceed to the next tutorial.",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/tutorials/python/send-ble-commands#"
        },
        {
            "title": "Python Tutorial 3: Parse BLE TLV Responses: ",
            "excerpt": "This document will provide a walk-through tutorial to use bleak to implement the Open GoPro Interface to parse BLE Type-Length-Value (TLV) Responses. Besides TLV, some BLE commands instead return protobuf responses. These will be discussed in a future tutorial. It is required that you have first completed the connect and sending commands tutorials before going through this tutorial. This tutorial will give an overview of types of responses, then give examples of parsing each type before finally providing a Response class that will be used in future tutorials. Requirements It is assumed that the hardware and software requirements from the connect tutorial are present and configured correctly. The scripts that will be used for this tutorial can be found in the Tutorial 3 Folder. Just Show me the Demo(s)!! Each of the examples described below has a corresponding script to demo it. If you don’t want to read this tutorial and just want to see the demo, for example, run: $ python ble_command_get_state.py Python &gt;= 3.8.x must be used as specified in the requirements Note that each script has a command-line help which can be found via: $ python ./ble_command_get_state.py --help usage: ble_command_get_state.py [-h] [-i IDENTIFIER] Connect to a GoPro camera via BLE, then get its statuses and settings. optional arguments: -h, --help show this help message and exit -i IDENTIFIER, --identifier IDENTIFIER Last 4 digits of GoPro serial number, which is the last 4 digits of the default camera SSID. If not used, first discovered GoPro will be connected to Setup We must first connect as was discussed in the connect tutorial. When enabling notifications, one of the notification handlers described in the following sections will be used. Response Overview In the preceding tutorials, we have been using a very simple response handling procedure where the notification handler simply checks that the UUID is the expected UUID and that the status byte of the response is 0 (Success). This has been fine since we were only sending specific commands where this works and we know that the sequence always appears as such (connection sequence left out for brevity): In actuality, responses can be more complicated. As described in the Open GoPro Interface, responses can be be comprised of multiple packets where each packet is &lt;= 20 bytes such as: This requires the implementation of accumulating and parsing algorithms which will be described in [Parsing Multiple Packet TLV Responses]. Parsing a One Packet TLV Response This section will describe how to parse one packet (&lt;= 20 byte) responses. A one-packet response is formatted as such: Header (length) Command / Setting ID Status Response 1 byte 1 byte 1 bytes Length - 2 bytes Command / Setting Responses with Response Length 0 These are the only responses that we have seen thus far through the first 2 tutorials. They return a status but have a 0 length additional response. For example, consider Set Shutter. It returned a response of: 02:01:00 This equates to: Header (length) Command / Setting / Status ID Status Response 1 byte 1 byte 1 bytes Length - 2 bytes 0x02 0x01 == Set Shutter 0x00 == Success (2 -2 = 0 bytes) We can see how this response includes the status but no additional response data. This type of response will be used for most Commands and Setting Responses as seen in the previous tutorial. Complex Command Response There are some commands that do return additional response data. These are called “complex responses.” From the commands reference, we can see that these are: Get Open GoPro Version (ID == 0x51) Get Hardware Info (ID == 0x3C) The ble_command_get_version.py script demonstrates a simple parser for the Open GoPro Get Version command which we will walk through here. It is important to always query the version after connecting in order to know which API is supported. See the relevant version of the BLE and / or WiFi spec for more details about each version. First, we send the command to the Command Request UUID: COMMAND_REQ_UUID = GOPRO_BASE_UUID.format(\"0072\") event.clear() await client.write_gatt_char(COMMAND_REQ_UUID, bytearray([0x01, 0x51])) await event.wait() Wait to receive the notification response The following snippets of code are taken from the notification handler We then receive a response at the expected handle. This is logged as: INFO:root:Getting the Getting the Open GoPro version... INFO:root:Received response at handle=52: b'06:51:00:01:01:01:00' This equates to: Header (length) Command / Setting / Status ID Status Response 1 byte 1 byte 1 bytes Length - 2 bytes 0x06 0x51 == Get Version 0x00 == Success 0x01 0x01 0x01 0x00 We can see that this “complex response” contains 4 additional bytes that need to be parsed. Using the information from the interface description, we know to parse this as: Byte Meaning 0x01 Length of Major Version Number 0x01 Major Version Number 0x01 Length of Minor Version Number 0x00 Minor Version Number We implement this in the notification handler as follows. First, we parse the length, command ID, and status from the first 3 bytes of the response: len = data[0] command_id = data[1] status = data[2] Next we parse the remaining four bytes of the response as individual values formatted as such: Length Value 1 byte Length bytes index = 3 params = [] while index &lt;= len: param_len = data[index] index += 1 params.append(data[index : index + param_len]) index += param_len From the complex response definition, we know these parameters equate to the major and the minor version so let’s print them (and all of the other response information) as such: major, minor = params logger.info(f\"Received a response to {command_id=} with {status=}: version={major[0]}.{minor[0]}\") which shows on the log as: INFO:root:Received a response to command_id=81 with status=0: version=1.0 Quiz time! 📚 ✏️ What is the maximum size of an individual notification response packet? A: 20 bytes B: 256 bytes C: There is no maximum size Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is A. Responses can be composed of multiple packets where each packet is at maximum 20 bytes. What is the maximum amount of packets that one response can be composed of? A: 20 bytes B: 256 bytes C: There is no maximum size Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is C. There is no limit on the amount of packets that can comprise a response. What is the maximum amount of packets that one response can be composed of? A: Always 1 packet B: Always multiple packets. C: Always 1 packet except for complex responses. Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is C. Command responses are almost always 1 packet (just returning the status). The exception are complex responses which can be multiple packets (in the case of Get Hardware Info) How many packets are setting responses comprised of? A: Always 1 packet B: Always multiple packets. C: Always 1 packet except for complex responses. Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is A. Settings Responses only ever contain the command status. Furthermore, there is no concept of complex responses for setting commands. Parsing Multiple Packet TLV Responses This section will describe parsing TLV responses that contain more than one packet. It will first describe how to accumulate such responses and then provide a parsing example. The example script that will be walked through for this section is ble_command_get_state.py. We will be creating a small Response class that will be re-used for future tutorials. Accumulating the Response The first step is to accumulate the multiple packets into one response. Whereas for all tutorials until now, we have just used the header bytes of the response as the length, we now must completely parse the header as it is defined: Byte 1 Byte 2 (optional) Byte 3 (optional) 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 0: Start 00: General Message Length: 5 bits 0: Start 01: Extended (13-bit) Message Length: 13 bits 0: Start 10: Extended (16-bit) Message Length: 16 bits 0: Start 11: Reserved 1: Continuation The basic algorithm here (which is implemented in the Message.accumulate method) is as follows: Continuation bit set? if buf[0] &amp; CONT_MASK: buf.pop(0) else: ... No, continuation bit was not set. So create new response, then get its length. This is a new packet so start with an empty byte array self.bytes = bytearray() hdr = Header((buf[0] &amp; HDR_MASK) &gt;&gt; 5) if hdr is Header.GENERAL: self.bytes_remaining = buf[0] &amp; GEN_LEN_MASK buf = buf[1:] elif hdr is Header.EXT_13: self.bytes_remaining = ((buf[0] &amp; EXT_13_BYTE0_MASK) &lt;&lt; 8) + buf[1] buf = buf[2:] elif hdr is Header.EXT_16: self.bytes_remaining = (buf[1] &lt;&lt; 8) + buf[2] buf = buf[3:] Append current packet to response and decrement bytes remaining. Append payload to buffer and update remaining / complete self.bytes.extend(buf) self.bytes_remaining -= len(buf) In the notification handler, we are then parsing if there are no bytes remaining. if response.is_received: response.parse() We can see this in action when we send the Get All Setting Values Query. Queries aren’t introduced until the next tutorial so for now, just pay attention to the response. We send the command as such: QUERY_REQ_UUID = GOPRO_BASE_UUID.format(\"0076\") event.clear() await client.write_gatt_char(QUERY_REQ_UUID, bytearray([0x01, 0x12])) await event.wait() Wait to receive the notification response Then, in the notification handler, we continuously receive and accumulate packets until we have received the entire response, at which point we notify the writer that the response is ready: def notification_handler(handle: int, data: bytes) -&gt; None: response.accumulate(data) if response.is_received: response.parse() Notify writer that procedure is complete event.set() We also first parse the response but that will be described in the next section. We can see the individual packets being accumulated in the log: INFO:root:Getting the camera's settings... INFO:root:Received response at handle=62: b'21:25:12:00:02:01:09:03:01:01:05:0 INFO:root:self.bytes_remaining=275 INFO:root:Received response at handle=62: b'80:01:00:18:01:00:1e:04:00:00:00:0 INFO:root:self.bytes_remaining=256 INFO:root:Received response at handle=62: b'81:0a:25:01:00:29:01:09:2a:01:05:2 INFO:root:self.bytes_remaining=237 INFO:root:Received response at handle=62: b'82:2f:01:04:30:01:03:36:01:00:3b:0 INFO:root:self.bytes_remaining=218 INFO:root:Received response at handle=62: b'83:04:00:00:00:00:3e:04:00:00:00:0 INFO:root:self.bytes_remaining=199 INFO:root:Received response at handle=62: b'84:00:42:04:00:00:00:00:43:04:00:0 INFO:root:self.bytes_remaining=180 INFO:root:Received response at handle=62: b'85:4f:01:00:53:01:00:54:01:00:55:0 INFO:root:self.bytes_remaining=161 INFO:root:Received response at handle=62: b'86:01:28:5b:01:02:60:01:00:66:01:0 INFO:root:self.bytes_remaining=142 INFO:root:Received response at handle=62: b'87:00:6a:01:00:6f:01:0a:70:01:ff:7 INFO:root:self.bytes_remaining=123 INFO:root:Received response at handle=62: b'88:75:01:00:76:01:04:79:01:00:7a:0 INFO:root:self.bytes_remaining=104 INFO:root:Received response at handle=62: b'89:01:00:7e:01:00:80:01:0c:81:01:0 INFO:root:self.bytes_remaining=85 INFO:root:Received response at handle=62: b'8a:0c:85:01:09:86:01:00:87:01:01:8 INFO:root:self.bytes_remaining=66 INFO:root:Received response at handle=62: b'8b:92:01:00:93:01:00:94:01:02:95:0 INFO:root:self.bytes_remaining=47 INFO:root:Received response at handle=62: b'8c:01:00:9c:01:00:9d:01:00:9e:01:0 INFO:root:self.bytes_remaining=28 INFO:root:Received response at handle=62: b'8d:00:a2:01:00:a3:01:01:a4:01:00:a INFO:root:self.bytes_remaining=9 INFO:root:Received response at handle=62: b'8e:a8:04:00:00:00:00:a9:01:01' INFO:root:self.bytes_remaining=0 INFO:root:Successfully received the response At this point the response has been accumulated. See the next section for how to parse it. Quiz time! 📚 ✏️ How can we know that a response has been completely received? A: The stop bit will be set in the header B: The response has accumulated length bytes C: By checking for the end of frame (EOF) sentinel character Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is B. The length of the entire response is parsed from the first packet. We then accumulate packets, keeping track of the received length, until all of the bytes have been received. A and C are just made up 😜. Query Responses This section is going to describe responses to to BLE status / setting queries. We don’t actually introduce such queries until the next tutorial so for now, only the parsing of the response is important. While multi-packet responses are almost always Query Responses, they can also be from Command Complex responses. In a real-world implementation, it is therefore necessary to check the received UUID to see how to parse. Query Responses contain one or more TLV groups in their Response data. To recap, the generic response format is: Header (length) Query ID Status Response 1-2 bytes 1 byte 1 bytes Length - 2 bytes This means that query responses will contain an array of additional TLV groups in the “Response” field as such: ID1 Length1 Value1 ID2 Length2 Value 2 … IDN LengthN ValueN 1 byte 1 byte Length1 bytes 1 byte 1 byte Length2 bytes … 1 byte 1 byte LengthN bytes Depending on the amount of query results in the response, this response can be one or multiple packets. Therefore, we need to account for the possibility that it may always be more than 1 packet. We can see an example of such parsing in the Response.parse method: We have already parsed the length when we were accumulating the packet. So the next step is to parse the Query ID and Status: self.id = self.bytes[0] self.status = self.bytes[1] We then continuously parse Type (ID) - Length - Value groups until we have consumed the response. We are storing each value in a dict indexed by ID for later access. buf = self.bytes[2:] while len(buf) &gt; 0: Get ID and Length param_id = buf[0] param_len = buf[1] buf = buf[2:] Get the value value = buf[:param_len] Store in dict for later access self.data[param_id] = value Advance the buffer buf = buf[param_len:] In the demo, we then log this entire dict after parsing is complete as such (abbreviated for brevity): INFO:root:Received settings : { \"2\": \"09\", \"3\": \"01\", \"5\": \"00\", \"6\": \"01\", \"13\": \"01\", \"19\": \"00\", \"30\": \"00:00:00:00\", \"31\": \"00\", \"32\": \"00:00:00:0a\", \"41\": \"09\", \"42\": \"05\", \"43\": \"00\", ... \"153\": \"00\", \"154\": \"01\", \"155\": \"00\", \"156\": \"00\", \"157\": \"00\", \"158\": \"01\", \"159\": \"00\", \"160\": \"00\", \"161\": \"00\", \"162\": \"00\", \"163\": \"01\", \"164\": \"00\", \"165\": \"00\", \"166\": \"00\", \"167\": \"04\", \"168\": \"00:00:00:00\", \"169\": \"01\" } We can see what each of these values mean by looking at the Open GoPro Interface. For example: ID 2 == 9 equates to Resolution == 1080 ID 3 == 1 equates to FPS == 120 How many packets are query responses? A: Always 1 packet B: Always multiple packets C: Always 1 packet except for complex responses D: Can be 1 or multiple packets Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is D. Query responses can be one packet (if for example querying a specific setting) or multiple packets (when querying many or all settings as in the example here). See the next tutorial for more information on queries. Which field is not common to all responses? A: length B: status C: ID Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is D. Query responses can be one packet (if for example querying a specific setting) or multiple packets (when querying many or all settings as in the example here). See the next tutorial for more information on queries. Troubleshooting See the first tutorial’s troubleshooting section. Good Job! Congratulations 🤙 You can now parse any TLV response that is received from the GoPro, at least if it is received uninterrupted. There is additional logic required for a complete solution such as checking the UUID the response is received on and storing a dict of response per UUID. At the current time, this endeavor is left for the reader. For a complete example of this, see the Open GoPro Python SDK. To learn more about queries, go to the next tutorial.",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/tutorials/python/parse-ble-responses#"
        },
        {
            "title": "Python Tutorial 4: BLE Queries: ",
            "excerpt": "This document will provide a walk-through tutorial to use bleak to implement the Open GoPro Interface to query the camera’s setting and status information via BLE. “Queries” in this sense are specifically procedures that: are initiated by writing to the Query UUID receive responses via the Query Response UUID. This will be described in more detail below. It is required that you have first completed the connect, sending commands, and parsing responses tutorials before going through this tutorial. This tutorial only considers sending these queries as one-off commands. That is, it does not consider state management / synchronization when sending multiple commands. This will be discussed in a future lab. Requirements It is assumed that the hardware and software requirements from the connect tutorial are present and configured correctly. The scripts that will be used for this tutorial can be found in the Tutorial 4 Folder. Just Show me the Demo(s)!! Each of the commands detailed in this tutorial has a corresponding script to demo it. If you don’t want to read this tutorial and just want to see the demo, for example, run: $ python ble_query_poll_resolution_value.py Python &gt;= 3.8.x must be used as specified in the requirements Note that each script has a command-line help which can be found via: $ python ./ble_command_poll_resolution_value.py --help usage: ble_query_poll_resolution_value.py [-h] [-i IDENTIFIER] Connect to a GoPro camera then get the current resolution. optional arguments: -h, --help show this help message and exit -i IDENTIFIER, --identifier IDENTIFIER Last 4 digits of GoPro serial number, which is the last 4 digits of the default camera SSID. If not used, first discovered GoPro will be connected to Setup We must first connect as was discussed in the connect tutorial. We will also be using the Response class that was defined in the parsing responses tutorial to accumulate and parse notification responses to the Query Response characteristic. Throughout this tutorial, the query information that we will be reading is the Resolution Setting (ID 0x02). Therefore, we have slightly changed the notification handler to update a global resolution variable as it queries the resolution: def notification_handler(handle: int, data: bytes) -&gt; None: response.accumulate(data) if response.is_received: response.parse() if client.services.characteristics[handle].uuid == QUERY_RSP_UUID: resolution = Resolution(response.data[RESOLUTION_ID][0]) Notify writer that the procedure is complete event.set() There are two methods to query status / setting information, each of which will be described in a following section: Polling Query Information Registering for query push notifications Polling Query Information It is possible to poll one or more setting / status values using the following commands: Query ID Request Query 0x12 Get Setting value(s) len:12:xx:xx 0x13 Get Status value(s) len:13:xx:xx where xx are setting / status ID(s) and len is the total length of the query (not including the length). There will be specific examples below. Since they are two separate commands, combination of settings / statuses can not be polled simultaneously. % Here is a generic sequence diagram (the same is true for statuses): The number of notification responses will vary depending on the amount of settings that have been queried. Note that setting values will be combined into one notification until it reaches the maximum notification size (20 bytes). At this point, a new response will be sent. Therefore, it is necessary to accumulate and then parse these responses as was described in parsing query responses Individual Query Poll Here we will walk through an example of polling one setting (Resolution) in ble_query_poll_resolution_value.py. First, we define the UUID’s to write to and receive from: QUERY_REQ_UUID = GOPRO_BASE_UUID.format(\"0076\") QUERY_RSP_UUID = GOPRO_BASE_UUID.format(\"0077\") Then we send the query command: event.clear() await client.write_gatt_char(QUERY_REQ_UUID, bytearray([0x02, 0x12, RESOLUTION_ID])) await event.wait() Wait to receive the notification response When the response is received in the notification handler, we update the global resolution variable: def notification_handler(handle: int, data: bytes) -&gt; None: response.accumulate(data) Notify the writer if we have received the entire response if response.is_received: response.parse() If this is query response, it must contain a resolution value if client.services.characteristics[handle].uuid == QUERY_RSP_UUID: resolution = Resolution(response.data[RESOLUTION_ID][0]) This all shows in the log as such: INFO:root:Getting the current resolution INFO:root:Received response at handle=62: b'05:12:00:02:01:09' INFO:root:self.bytes_remaining=0 INFO:root:Resolution is currently Resolution.RES_1080 For verification purposes, we are then changing the resolution and polling again to verify that the setting has changed: INFO:root:Changing the resolution to Resolution.RES_2_7K... INFO:root:Received response at handle=57: b'02:02:00' INFO:root:self.bytes_remaining=0 INFO:root:Command sent successfully INFO:root:Polling the resolution to see if it has changed... INFO:root:Received response at handle=62: b'05:12:00:02:01:07' INFO:root:self.bytes_remaining=0 INFO:root:Resolution is currently Resolution.RES_2_7K Multiple Simultaneous Query Polls Rather than just polling one setting, it is also possible to poll multiple settings. There is an example of this in ble_poll_multiple_setting_values.py. It is very similar to the previous example except for the following: The query command now includes 3 settings: RESOLUTION_ID = 2 FPS_ID = 3 FOV_ID = 121 await client.write_gatt_char(QUERY_REQ_UUID, bytearray([0x04, 0x12, RESOLUTION_ID, FPS_ID, FOV_ID])) The length (first byte of the command) has been increased to 4 to accommodate the extra settings We are also parsing the response to get all 3 values: def notification_handler(handle: int, data: bytes) -&gt; None: response.accumulate(data) if response.is_received: response.parse() if client.services.characteristics[handle].uuid == QUERY_RSP_UUID: resolution = Resolution(response.data[RESOLUTION_ID][0]) fps = FPS(response.data[FPS_ID][0]) video_fov = VideoFOV(response.data[FOV_ID][0]) When we are storing the updated setting, we are just taking the first byte (i..e index 0). A real-world implementation would need to know the length (and type) of the setting / status response by the ID. For example, sometimes settings / statuses are bytes, words, strings, etc. They are then printed to the log which will look like the following: INFO:root:Received response at handle=62: b'0b:12:00:02:01:07:03:01:01:79:01:00' INFO:root:self.bytes_remaining=0 INFO:root:Resolution is currently Resolution.RES_2_7K INFO:root:Video FOV is currently VideoFOV.FOV_WIDE INFO:root:FPS is currently FPS.FPS_120 Query All It is also possible to query all settings / statuses by not passing any ID’s into the the query command, i.e.: Query ID Request Query 0x12 Get All Settings 01:12 0x13 Get All Statuses 01:13 An example of this can be seen in the ble_command_get_state.py script described in the parsing query responses tutorial Quiz time! 📚 ✏️ How can we poll the encoding status and the resolution setting using one command? A: Concatenate a ‘Get Setting Value’ command and a ‘Get Status’ command with the relevant ID’s B: Concatenate the ‘Get All Setting’ and ‘Get All Status’ commands. C: It is not possible Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is C. It is not possible to concatenate commands. This would result in an unknown sequence of bytes from the camera’s perspective. So it is not possible to get a setting value and a status value in one command. The Get Setting command (with resolution ID) and Get Status command(with encoding ID) must be sent sequentially in order to get this information. Registering for Query Push Notifications Rather than polling the query information, it is also possible to use an interrupt scheme to register for push notifications when the relevant query information changes. The relevant commands are: Query ID Request Query 0x52 Register updates for setting(s) len:52:xx:xx 0x53 Register updates for status(es) len:53:xx:xx 0x72 Unregister updates for setting(s) len:72:xx:xx 0x73 Unregister updates for status(es) len:73:xx:xx where xx are setting / status ID(s) and len is the total length of the query (not including the length). The Query ID’s for push notification responses are as follows: Query ID Response 0x92 Setting Value Push Notification 0x93 Status Value Push Notification Here is a generic sequence diagram of how this looks (the same is true for statuses): That is, after registering for push notifications for a given query, notification responses will continuously be sent whenever the query changes until the client unregisters for push notifications for the given query. The initial response to the Register command also contains the current setting / status value. We will walk through the ble_query_register_resolution_value_updates.py script to demonstrate this: First, we define the UUID’s to write to and receive from: SETTINGS_REQ_UUID = GOPRO_BASE_UUID.format(\"0074\") SETTINGS_RSP_UUID = GOPRO_BASE_UUID.format(\"0075\") QUERY_REQ_UUID = GOPRO_BASE_UUID.format(\"0076\") QUERY_RSP_UUID = GOPRO_BASE_UUID.format(\"0077\") Then we register for updates when the resolution setting changes: event.clear() await client.write_gatt_char(QUERY_REQ_UUID, bytearray([0x02, 0x52, RESOLUTION_ID])) await event.wait() Wait to receive the notification response and parse its response (which includes the current resolution value). This is very similar to the polling example with the exception that the Query ID is now 0x52 (Register Updates for Settings). This can be seen in the raw byte data as well as by inspecting response.id. def notification_handler(handle: int, data: bytes) -&gt; None: logger.info(f'Received response at {handle=}: {hexlify(data, \":\")!r}') response.accumulate(data) Notify the writer if we have received the entire response if response.is_received: response.parse() If this is query response, it must contain a resolution value if client.services.characteristics[handle].uuid == QUERY_RSP_UUID: global resolution resolution = Resolution(response.data[RESOLUTION_ID][0]) This will show in the log as such: INFO:root:Registering for resolution updates INFO:root:Received response at handle=62: b'05:52:00:02:01:07' INFO:root:self.bytes_remaining=0 INFO:root:Successfully registered for resolution value updates. INFO:root:Resolution is currently Resolution.RES_2_7K We are now successfully registered for resolution value updates and will receive push notifications whenever the resolution changes. We verify this is the demo by then changing the resolution. This will show in the log as: INFO:root:Successfully changed the resolution INFO:root:Received response at handle=62: b'05:92:00:02:01:09' INFO:root:self.bytes_remaining=0 INFO:root:Resolution is now Resolution.RES_1080 In this case, the Query ID is 0x92 (Setting Value Push Notification) as expected. Multiple push notifications can be registered / received in a similar manner that multiple queries were polled above Quiz time! 📚 ✏️ True or False: We can still poll a given query value while we are currently registered to receive push notifications for it. A: True B: False Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is A. While there is probably not a good reason to do so, there is nothing preventing polling in this manner. True or False: A push notification for a registered setting will only ever contain query information about one setting ID. A: True B: False Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is B. It is possible for push notifications to contain multiple setting ID’s if both setting ID’s have push notifications registered and both settings change at the same time. Troubleshooting See the first tutorial’s troubleshooting section. Good Job! Congratulations 🤙 You can now query any of the settings / statuses from the camera using one of the above patterns. If you have been following these tutorials in order, here is an extra 🥇🍾 Congratulations 🍰👍 because you have completed all of the BLE tutorials. Next, to get started with WiFI (specifically to enable and connect to it), proceed to the next tutorial.",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/tutorials/python/ble-queries#"
        },
        {
            "title": "Python Tutorial 5: Connect WiFi: ",
            "excerpt": "This document will provide a walk-through tutorial to use bleak to implement the Open GoPro Interface to enable the GoPro’s WiFi Access Point (AP) so that it can be connected to. It will also provide an example of connecting to the WiFi AP. It is recommended that you have first completed the connecting, sending commands, and parsing responses tutorials before proceeding. Requirements It is assumed that the hardware and software requirements from the connect tutorial are present and configured correctly. The scripts that will be used for this tutorial can be found in the Tutorial 5 Folder. Just Show me the Demo(s)!! There are two relevant scripts that will be discussed here: wifi_enable.py wifi_enable_and_connect.py If you don’t want to read this tutorial and just want to see the demo, for example, run: $ python wifi_enable_and_connect.py Python &gt;= 3.8.x must be used as specified in the requirements Note that each script has a command-line help which can be found via: python wifi_enable_and_connect.py --help usage: wifi_enable_and_connect.py [-h] [-i IDENTIFIER] Connect to a GoPro camera via BLE, get WiFi info, enable WiFi and connect. optional arguments: -h, --help show this help message and exit -i IDENTIFIER, --identifier IDENTIFIER Last 4 digits of GoPro serial number, which is the last 4 digits of the default camera SSID. If not used, first discovered GoPro will be connected to Setup We must first connect to BLE as was discussed in the connect tutorial. We are also using the same notification handler as was used in the sending commands tutorial Connecting to WiFi AP Now that we are connected via BLE, paired, and have enabled notifications, we can send the command to enable the WiFi AP. Here is an outline of the steps to do so: Essentially we will be finding the WiFi AP information (SSID and password) via BLE, enabling the WiFi AP via BLE, then connecting to the WiFi AP. Find WiFi Information Note that the process to get this information is different than all procedures described up to this point. Whereas the previous command, setting, and query procedures all followed the Write Request-Notification Response pattern, the WiFi Information is retrieved via direct Read Requests to BLE characteristics. Get WiFi SSID The WiFi SSID can be found by reading from the WiFi AP SSID characteristic of the WiFi Access Point service. First, we need to define the attribute to read from: WIFI_AP_SSID_UUID = GOPRO_BASE_UUID.format(\"0002\") Now, let’s send the read request to get the SSID (and decode it into a string). ssid = await client.read_gatt_char(WIFI_AP_SSID_UUID) ssid = ssid.decode() There is no need for a synchronization event as the information is available when the read_gatt_char method returns. In the demo, this information is logged as such: INFO:root:Reading the WiFi AP SSID INFO:root:SSID is GP24500456 Get WiFi Password The WiFi password can be found by reading from the WiFi AP password characteristic of the WiFi Access Point service. First, we need to define the attribute to read from: WIFI_AP_PASSWORD_UUID = GOPRO_BASE_UUID.format(\"0003\") Now, let’s send the read request to get the password (and decode it into a string). password = await client.read_gatt_char(WIFI_AP_PASSWORD_UUID) password = password.decode() There is no need for a synchronization event as the information is available when the read_gatt_char method returns. In the demo, this information is logged as such: INFO:root:Reading the WiFi AP password INFO:root:Password is g@6-Tj9-C7K Enable WiFi AP Before we can connect to the WiFi AP, we have to make sure it is enabled. This is accomplished by using the “AP Control” command: Command Bytes Ap Control Enable 0x03 0x17 0x01 0x01 Ap Control Disable 0x03 0x17 0x01 0x00 This is done in the same manner that we did in the sending commands tutorial. Now, let’s write the bytes to the “Command Request UUID” to enable the WiFi AP! event.clear() await client.write_gatt_char(COMMAND_REQ_UUID, bytearray([0x03, 0x17, 0x01, 0x01])) await event.wait() Wait to receive the notification response We make sure to clear the synchronization event before writing, then pend on the event until it is set in the notification callback. Note that we have received the “Command Status” notification response from the Command Response characteristic since we enabled it’s notifications in Enable Notifications. This can be seen in the demo log: INFO:root:Enabling the WiFi AP INFO:root:Received response at handle=52: b'02:17:00' INFO:root:Command sent successfully INFO:root:WiFi AP is enabled As expected, the response was received on the correct handle and the status was “success”. Establish Connection to WiFi AP If you have been following through the ble_enable_wifi.py script, you will notice that it ends here such that we know the WiFi SSID and password and the WiFi AP is enabled and ready to connect to. This is because there are many different methods of connecting to the WiFi AP depending on your OS and the framework you are using to develop. You could, for example, simply use your OS’s WiFi GUI to connect. We do provide a programmatic example of this in the ble_enable_wifi_and_connect.py script. This script uses the cross-platform Wireless module from the Open GoPro Python SDK. Note that this has been imported as such: from open_gopro.wifi.adapters import Wireless In order to do so, perform the following after the above steps have been completed: wifi = Wireless() wifi.connect(ssid, password) This will log something similar to the following (it will vary slightly based on your OS): INFO:root:Connecting to GoPro WiFi AP INFO:open_gopro.wifi_controller:Attempting to establish WiFi connection to GP24500456... INFO:open_gopro.wifi_controller:Wifi connection established! INFO:root:Wifi Connected! Quiz time! 📚 ✏️ How is the WiFi password response received? A: As a read response from the WiFi AP Password characteristic B: As write responses to the WiFi Request characteristic C: As notifications of the Command Response characteristic Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is A. This (and WiFi AP SSID) is an exception to the rule. Usually responses are received as notifications to a response characteristic. However, in this case, it is received as a direct read response (since we are reading from the characteristic and not writing to it). Which of the following statements about the GoPro WiFi AP is true? A: It only needs to be enabled once and it will then always remain on B: The WiFi password will never change C: The WiFi SSID will never change Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is D. Trick question! They are all false. While the WiFi AP will remain on for some time, it can and will eventually turn off so it is always recommended to first connect via BLE and ensure that it is enabled. The password and SSID will almost never change. However, they will change if the connections are reset via Connections-&gt;Reset Connections. Troubleshooting See the first tutorial’s troubleshooting section. Good Job! Congratulations 🤙 You are now connected to the GoPro’s Wifi AP and can send any of the HTTP commands defined in the Open GoPro Interface. Proceed to the next tutorial.",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/tutorials/python/connect-wifi#"
        },
        {
            "title": "Python Tutorial 6: Send WiFi Commands: ",
            "excerpt": "This document will provide a walk-through tutorial to use the Python requests package to send Open GoPro HTTP commands to the GoPro. It is required that you have first completed the Connecting to Wifi tutorial. This tutorial only considers sending these commands as one-off commands. That is, it does not consider state management / synchronization when sending multiple commands. This will be discussed in a future lab. There are two types of responses that can be received from the HTTP commands: JSON and binary. This section will deal with commands that return JSON responses. For commands with binary responses (as well as commands with JSON responses that work with the media list), see the next tutorial. Requirements It is assumed that the hardware and software requirements from the connect tutorial are present and configured correctly. The scripts that will be used for this tutorial can be found in the Tutorial 6 Folder. Just Show me the Demo(s)!! Each of the commands detailed below has a corresponding script to demo it. If you don’t want to read this tutorial and just want to see the demo, for example, run: $ python wifi_command_zoom.py Python &gt;= 3.8.x must be used as specified in the requirements Note that each script has a command-line help which can be found via: $ python wifi_command_zoom.py --help usage: wifi_command_zoom.py [-h] [-z ZOOM] Set the digital zoom level. optional arguments: -h, --help show this help message and exit -z ZOOM, --zoom ZOOM Zoom percentage (0-100) Setup We must first connect to The GoPro’s WiFi Access Point (AP) as was discussed in the Connecting to Wifi tutorial. Sending HTTP Commands with JSON Responses Now that we are are connected via WiFi, we will use the requests module to send the various HTTP commands. Both Command Requests and Setting Requests follow the same procedure: Send HTTP GET command to appropriate endpoint Receive confirmation from GoPro (via HTTP response) that request was received. GoPro reacts to command The HTTP response only indicates that the request was received correctly. The relevant behavior of the GoPro must be observed to verify when the command’s effects have been applied. We are building the endpoints using the GOPRO_BASE_URL defined in the tutorial package’s __init__.py Get Open GoPro Version The first command we will be sending is Get Version. This should be the first command you send after connecting. It is imperative to know the Open GoPro version that the connected camera supports as setting values, endpoints, and more differ between versions Let’s build the endpoint first send the Keep Alive signal: url = GOPRO_BASE_URL + f\"/gopro/version Now we send the GET request and check the response for errors. Any errors will raise an exception. response = requests.get(url) response.raise_for_status() Lastly, we print the response’s JSON data (nicely formatted with indent 4 using the json module): logger.info(f\"Response: {json.dumps(response.json(), indent=4)}\") This will log as such: INFO:root:Getting the Open GoPro version: sending http://10.5.5.9:8080/gopro/version INFO:root:Command sent successfully INFO:root:Response: { \"version\": \"2.0\" } In this case, this camera supports version 2.0 of the Open GoPro spec. We will an example of why this is important in the Set Setting section below. Digital Zoom The next command we will be sending is Digital Zoom. The camera must be in the Photo Preset Group for this command to succeed. The commands writes to the following endpoint: /gopro/camera/digital_zoom?percent=50 Let’s build the endpoint (in this example from the script, zoom is a command line argument that defaults to 50): url = GOPRO_BASE_URL + f\"gopro/camera/digital_zoom?percent={zoom}\" Now we send the GET request and check the response for errors. Any errors will raise an exception. response = requests.get(url) response.raise_for_status() Lastly, we print the response’s JSON data (nicely formatted with indent 4 using the json module): logger.info(f\"Response: {json.dumps(response.json(), indent=4)}\") This will log as such: INFO:root:Setting digital zoom to 50%: sending http://10.5.5.9:8080/gopro/camera/digital_zoom?percent=50 INFO:root:Command sent successfully INFO:root:Response: {} The response JSON is empty. This is expected in the case of a success. Get State Send Request Parse Response The next command we will be sending is Get State. This command will return all of the current settings and values. It is basically a combination of the Get All Settings and Get All Statuses commands that were sent via BLE. Since there is no way to query individual settings / statuses via WiFi (or register for asynchronous notifications when they change), this is the only option to query setting / status information via WiFi. The command writes to the following endpoint: /gopro/camera/state Let’s first build the endpoint: url = GOPRO_BASE_URL + \"/gopro/camera/state\" Now we send the GET request and check the response for errors. Any errors will raise an exception. response = requests.get(url) response.raise_for_status() Lastly, we print the response’s JSON data (nicely formatted with indent 4 using the json module): logger.info(f\"Response: {json.dumps(response.json(), indent=4)}\") Go to the next tab for examples of viewing and parsing the response. The response will log as such (abbreviated for brevity): INFO:root:Getting GoPro's status and settings: sending http://10.5.5.9:8080/gopro/camera/state INFO:root:Command sent successfully INFO:root:Response: { \"status\": { \"1\": 1, \"2\": 2, \"3\": 0, \"4\": 255, \"6\": 0, \"8\": 0, \"9\": 0, \"10\": 0, \"11\": 0, \"13\": 0, \"14\": 0, \"17\": 1, ... \"settings\": { \"2\": 9, \"3\": 1, \"5\": 0, \"6\": 1, \"13\": 1, \"19\": 0, \"24\": 0, \"30\": 0, \"31\": 0, \"32\": 10, \"41\": 9, \"42\": 5, We can see what each of these values mean by looking at the Open GoPro Interface. For example (for settings): ID 2 == 9 equates to Resolution == 1080 ID 3 == 1 equates to FPS == 120 Preview Stream Send Request View Stream The next command we will be sending is Preview Stream. This command will enable (or disable) the preview stream . It is then possible to view the preview stream from a media player. The commands write to the following endpoints: Command Endpoint start preview stream /gopro/camera/stream/start stop preview stream /gopro/camera/stream/stop Let’s first build the endpoint: url = GOPRO_BASE_URL + \"/gopro/camera/stream/start\" Now we send the GET request and check the response for errors. Any errors will raise an exception. response = requests.get(url) response.raise_for_status() Lastly, we print the response’s JSON data (nicely formatted with indent 4 using the json module): logger.info(f\"Response: {json.dumps(response.json(), indent=4)}\") This will log as such: INFO:root:Starting the preview stream: sending http://10.5.5.9:8080/gopro/camera/stream/start INFO:root:Command sent successfully INFO:root:Response: {} The response JSON is empty. This is expected in the case of a success. Go to the next tab for an example of viewing the stream. Once enabled, the stream can be viewed at udp://@:8554. Here is an example of viewing this using VLC: The screen may slightly vary depending on your OS %} Select Media–&gt;Open Network Stream Enter the path as such: Configure Preview Stream Select play The preview stream should now be visible. Load Preset Group The next command we will be sending is Load Preset Group. which is used to toggle between the 3 groups of presets (video, photo, and timelapse). Let’s build the endpoint first to load the video preset group (the id comes from the command table linked above): url = GOPRO_BASE_URL + \"/gopro/camera/presets/set_group?id=1000\" Now we send the GET request and check the response for errors. Any errors will raise an exception. response = requests.get(url) response.raise_for_status() Lastly, we print the response’s JSON data (nicely formatted with indent 4 using the json module): logger.info(f\"Response: {json.dumps(response.json(), indent=4)}\") This will log as such: INFO:root:Loading the video preset group: sending http://10.5.5.9:8080/gopro/camera/presets/set_group?id=1000 INFO:root:Command sent successfully INFO:root:Response: {} The response JSON is empty. This is expected in the case of a success. You should hear the camera beep and move to the Video Preset Group. You can tell this by the logo at the top middle of the screen: Preset Group Load Preset The next command we will be sending is Load Preset. which is used to select a specific preset that is part of a Preset Group. Let’s build the endpoint first to load the Cinematic Preset (the id comes from the command table linked above): url = GOPRO_BASE_URL + \"/gopro/camera/presets/load?id=2\" Now we send the GET request and check the response for errors. Any errors will raise an exception. response = requests.get(url) response.raise_for_status() Lastly, we print the response’s JSON data (nicely formatted with indent 4 using the json module): logger.info(f\"Response: {json.dumps(response.json(), indent=4)}\") This will log as such: INFO:root:Loading the cinematic preset: sending http://10.5.5.9:8080/gopro/camera/presets/load?id=2 INFO:root:Command sent successfully INFO:root:Response: {} The response JSON is empty. This is expected in the case of a success. You should hear the camera beep and switch to the Cinematic Preset (assuming it wasn’t already set). You can verify this by seeing the preset name in the pill at bottom middle of the screen. Load Preset Get Preset Status Send Request Parse Response The next command we will be sending is Get Presets Status. This command is used to get the list of all currently available presets as well as the settings that comprise each preset. This includes both default and user-defined presets. Let’s first build the endpoint: url = GOPRO_BASE_URL + \"/gopro/camera/presets/get\" Now we send the GET request and check the response for errors. Any errors will raise an exception. response = requests.get(url) response.raise_for_status() Lastly, we print the response’s JSON data (nicely formatted with indent 4 using the json module): logger.info(f\"Response: {json.dumps(response.json(), indent=4)}\") Go to the next tab for examples of viewing and parsing the response. The response will log as such (abbreviated for brevity): INFO:root:Getting the current preset status: sending http://10.5.5.9:8080/gopro/camera/presets/get INFO:root:Command sent successfully INFO:root:Response: { \"presetGroupArray\": [ { \"id\": \"PRESET_GROUP_ID_VIDEO\", \"presetArray\": [ { \"id\": 6, \"mode\": \"FLAT_MODE_LOOPING\", \"titleId\": \"PRESET_TITLE_LOOPING\", \"userDefined\": true, \"icon\": \"PRESET_ICON_LOOPING\", \"settingArray\": [ { \"id\": 2, \"value\": 9, \"isCaption\": true }, { \"id\": 3, \"value\": 5, \"isCaption\": true }, { \"id\": 6, \"value\": 1, \"isCaption\": true }, { \"id\": 121, \"value\": 0, \"isCaption\": true } ], \"isModified\": false }, { \"id\": 0, \"mode\": \"FLAT_MODE_VIDEO\", \"titleId\": \"PRESET_TITLE_STANDARD\", \"userDefined\": false, \"icon\": \"PRESET_ICON_VIDEO\", \"settingArray\": [ { \"id\": 2, \"value\": 24, \"isCaption\": true }, { \"id\": 3, \"value\": 8, \"isCaption\": true }, { \"id\": 121, \"value\": 0, \"isCaption\": true } ], \"isModified\": true }, The JSON presetGroupArray tag is a list of presets where each preset is comprised of an ID, array of settings, and other descriptive information. In the example above, we can see that there is a user-defined looping preset and a default video preset. For more information on creating / using custom presets, see the GoPro Community Article. A future lab may be created to demonstrate parsing this JSON directly into a protobuf-compiled object. The settings shown above are parsed the same as they were in the Get State command above As a reader exercise, try creating a custom preset on the camera and then using this command to view its information. Keep Alive The next command we will be sending is Keep Alive. which is used to prevent the camera from powering down. Unless changed by the user, GoPro cameras will automatically power off after some time (e.g. 5min, 15min, 30min). The Auto Power Down watchdog timer can be reset by periodically sending this message. Let’s build the endpoint first send the Keep Alive signal: url = GOPRO_BASE_URL + f\"/gopro/camera/keep_alive\" Now we send the GET request and check the response for errors. Any errors will raise an exception. response = requests.get(url) response.raise_for_status() Lastly, we print the response’s JSON data (nicely formatted with indent 4 using the json module): logger.info(f\"Response: {json.dumps(response.json(), indent=4)}\") This will log as such: INFO:root:Sending the keep alive signal: sending http://10.5.5.9:8080/gopro/camera/keep_alive INFO:root:Command sent successfully INFO:root:Response: {} It is recommended to send a keep-alive at least once every 120 seconds. Set Shutter The next command we will be sending is Set Shutter. which is used to start and stop encoding. Let’s build the endpoint first send the Set Shutter signal: url = GOPRO_BASE_URL + f\"/gopro/camera/shutter/start\" Now we send the GET request and check the response for errors. Any errors will raise an exception. response = requests.get(url) response.raise_for_status() This command does not return a JSON response so we don’t print the response This will log as such: INFO:root:Turning the shutter on: sending http://10.5.5.9:8080/gopro/camera/shutter/start INFO:root:Command sent successfully We then wait a few seconds and repeat the above procedure to set the shutter off. This time we use the following URL: url = GOPRO_BASE_URL + f\"/gopro/camera/shutter/stop\" The shutter can not be set on if the camera is encoding or set off if the camera is not encoding. An attempt to do so will result in an error response. Set Setting The next command will be sending is Set Setting. This end point is used to update all of the settings on the camera. It is analogous to BLE commands like Set Video Resolution. It is important to note that many settings are dependent on the video resolution (and other settings). For example, certain FPS values are not valid with certain resolutions. In general, higher resolutions only allow lower FPS values. Check the camera capabilities to see which settings are valid for given use cases. The following endpoint is different between Open GoPro 1.0 and 2.0. Let’s build the endpoint first to set the Video Resolution to 1080 (the setting_id and opt_value comes from the command table linked above). Click the relevant tab for the desired Open GoPro Version. Version 1.0 Version 2.0 url = GOPRO_BASE_URL + f\"/gopro/camera/setting?setting_id=2&amp;opt_value=9\" url = GOPRO_BASE_URL + f\"/gopro/camera/setting?setting=2&amp;option=9\" Now we send the GET request and check the response for errors. Any errors will raise an exception. response = requests.get(url) response.raise_for_status() Lastly, we print the response’s JSON data (nicely formatted with indent 4 using the json module): logger.info(f\"Response: {json.dumps(response.json(), indent=4)}\") This will log as such: INFO:root:Setting the video resolution to 1080: sending http://10.5.5.9:8080/gopro/camera/setting?setting_id=2&amp;opt_value=9 INFO:root:Command sent successfully INFO:root:Response: {} The response JSON is empty. This is expected in the case of a success. You should hear the camera beep and see the video resolution change to 1080 in the pill in the bottom-middle of the screen: Video Resolution As a reader exercise, try using the [Get State] command to verify that the resolution has changed. Quiz time! 📚 ✏️ What is the significance of empty JSON in an HTTP response? A: Always an error! The command was not received correctly. B: If the status is ok (200), this is expected. C: This is expected for errors (code other than 200) but not expected for ok (200). Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is B. It is common for the JSON response to be empty if the command was received successfully but there is no additional information to return at the current time. Which of the of the following is not a real preset group? A: Timelapse B: Photo C: Burst D: Video Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is C. There are 3 preset groups (Timelapse, Photo, and Video). These can be set via the Load Preset Group command. What of the following sets of FPS values are possible at 5K? A: [24, 25, 30] B: [24, 25, 30, 60] C: [24, 25, 30, 60, 120] D: Any FPS is valid in at 5k Submit Answer Correct!! 😃 Incorrect!! 😭 The correct answer is A. Among these options, only 24 is possible. You’re not actually expected to know this. But you should know where to find the information. Troubleshooting HTTP Logging Wireshark can be used to view the HTTP commands and responses between the PC and the GoPro. Start a Wireshark capture on the WiFi adapter that is used to connect to the GoPro Filter for the GoPro IP address (10.5.5.9) Wireshark Good Job! Congratulations 🤙 You can now send any of the HTTP commands defined in the Open GoPro Interface that return JSON responses. You may have noted that we did not discuss one of these (Get Media List) in this tutorial. Proceed to the next tutorial to see how to get and perform operations using the media list.",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/tutorials/python/send-wifi-commands#"
        },
        {
            "title": "Python Tutorial 7: Camera Media List: ",
            "excerpt": "This document will provide a walk-through tutorial to use the Python requests package to send Open GoPro HTTP commands to the GoPro, specifically to get the media list and perform operations on it (downloading pictures, videos, etc.) It is required that you have first completed the Connecting to Wifi and Sending WiFi Commands tutorials. This tutorial only considers sending these commands as one-off commands. That is, it does not consider state management / synchronization when sending multiple commands. This will be discussed in a future lab. Requirements It is assumed that the hardware and software requirements from the connect tutorial are present and configured correctly. The scripts that will be used for this tutorial can be found in the Tutorial 7 Folder. Just Show me the Demo(s)!! Each of the operations detailed below has a corresponding script to demo it. If you don’t want to read this tutorial and just want to see the demo, for example, run: $ python wifi_media_download_file.py Python &gt;= 3.8.x must be used as specified in the requirements Note that each script has a command-line help which can be found via: $ python wifi_media_download_file.py --help usage: wifi_media_download_file.py [-h] Find a photo on the camera and download it to the computer. optional arguments: -h, --help show this help message and exit Setup We must first connect to The GoPro’s WiFi Access Point (AP) as was discussed in the Connecting to Wifi tutorial. Get Media List Now that we are are connected via WiFi, we will get the media list using the same procedure to send HTTP commands as in the previous tutorial. Send Request Parse Response We get the media list via the Get Media List command. This command will return a JSON structure of all of the media files (pictures, videos) on the camera with corresponding information about each media file. Let’s first build the endpoint: url = GOPRO_BASE_URL + \"/gopro/media/list\" Now we send the GET request and check the response for errors. Any errors will raise an exception. response = requests.get(url) response.raise_for_status() Lastly, we print the response’s JSON data (nicely formatted with indent 4 using the json module): logger.info(f\"Response: {json.dumps(response.json(), indent=4)}\") Go to the next tab for examples of viewing and parsing the response. The response will log as such (abbreviated for brevity): INFO:root:Getting the media list: sending http://10.5.5.9:8080/gopro/media/list INFO:root:Command sent successfully INFO:root:Response: { \"id\": \"2510746051348624995\", \"media\": [ { \"d\": \"100GOPRO\", \"fs\": [ { \"n\": \"GOPR0987.JPG\", \"cre\": \"1618583762\", \"mod\": \"1618583762\", \"s\": \"5013927\" }, { \"n\": \"GOPR0988.JPG\", \"cre\": \"1618583764\", \"mod\": \"1618583764\", \"s\": \"5009491\" }, { \"n\": \"GOPR0989.JPG\", \"cre\": \"1618583766\", \"mod\": \"1618583766\", \"s\": \"5031861\" }, { \"n\": \"GX010990.MP4\", \"cre\": \"1451608343\", \"mod\": \"1451608343\", \"glrv\": \"806586\", \"ls\": \"-1\", \"s\": \"10725219\" }, The media list format is defined in the Open GoPro Specification. We won’t be rehashing that here but will provide examples below of using the media list. One common functionality is to get the list of media file names, which can be done as such: print([x[\"n\"] for x in media_list[\"media\"][0][\"fs\"]]) That is, access the list at the fs tag at the first element of the media tag, then make a list of all of the names (n tag of each element) in the fs list. Media List Operations Whereas all of the WiFi commands described until now have returned JSON responses, most of the media list operations return binary data. From an HTTP perspective, the behavior is the same. However, the GET response will contain a large binary chunk of information so we will loop through it with the requests library as such, writing up to 8 kB at a time: Download Media File The next command we will be sending is Download Media. Specifically, we will be downloading a photo. The camera must have at least one photo in its media list in order for this to work. First, we get the media list as in Get Media List . Then we search through the list of file names in the media list looking for a photo (i.e. a file whose name ends in .jpg). Once we find a photo, we proceed: media_list = get_media_list() photo: Optional[str] = None for media_file in [x[\"n\"] for x in media_list[\"media\"][0][\"fs\"]]: if media_file.lower().endswith(\".jpg\"): logger.info(f\"found a photo: {media_file}\") photo = media_file break Now let’s build the endpoint to download the photo whose name we just found: url = GOPRO_BASE_URL + f\"videos/DCIM/100GOPRO/{photo}\" The endpoint will start with “videos” for both photos and videos Next we send the GET request and check the response for errors. Any errors will raise an exception. with requests.get(url, stream=True) as request: request.raise_for_status() Lastly, we iterate through the binary content in 8 kB chunks, writing to a local file: file = photo.split(\".\")[0] + \".jpg\" with open(file, \"wb\") as f: logger.info(f\"receiving binary stream to {file}...\") for chunk in request.iter_content(chunk_size=8192): f.write(chunk) This will log as such: INFO:root:found a photo: GOPR0987.JPG INFO:root:Downloading GOPR0987.JPG INFO:root:Sending: http://10.5.5.9:8080/videos/DCIM/100GOPRO/GOPR0987.JPG INFO:root:receiving binary stream to GOPR0987.jpg... Once complete, the GOPR0987.jpg file will be available from where the demo script was called. Get Media GPMF The next command we will be sending is Get Media GPMF. More information about GPMF can be found here. Specifically, we will be downloading the GPMF for a photo. The camera must have at least one photo in its media list in order for this to work. First, we get the media list as in Get Media List . Then we search through the list of file names in the media list looking for a photo (i.e. a file whose name ends in .jpg). Once we find a photo, we proceed: media_list = get_media_list() photo: Optional[str] = None for media_file in [x[\"n\"] for x in media_list[\"media\"][0][\"fs\"]]: if media_file.lower().endswith(\".jpg\"): logger.info(f\"found a photo: {media_file}\") photo = media_file break Now let’s build the endpoint to download the GPMF for the photo whose name we just found: url = GOPRO_BASE_URL + f\"/gopro/media/gpmf?path=100GOPRO/{photo}\" Next we send the GET request and check the response for errors. Any errors will raise an exception. with requests.get(url, stream=True) as request: request.raise_for_status() Lastly, we iterate through the binary content in 8 kB chunks, writing to a local file: file = photo.split(\".\")[0] + \".jpg\" with open(file, \"wb\") as f: logger.info(f\"receiving binary stream to {file}...\") for chunk in request.iter_content(chunk_size=8192): f.write(chunk) This will log as such: INFO:root:found a photo: GOPR0987.JPG INFO:root:Getting the GPMF for GOPR0987.JPG INFO:root:Sending: http://10.5.5.9:8080/gopro/media/gpmf?path=100GOPRO/GOPR0987.JPG INFO:root:receiving binary stream to GOPR0987.gpmf... Once complete, the GOPR0987.gpmf file will be available from where the demo script was called. Get Media Screennail The next command we will be sending is Get Media Screennail . Specifically, we will be getting the screennail for a photo. The camera must have at least one photo in its media list in order for this to work. There is a separate command (shown below) to get a media “thumbnbail” First, we get the media list as in Get Media List . Then we search through the list of file names in the media list looking for a photo (i.e. a file whose name ends in .jpg). Once we find a photo, we proceed: media_list = get_media_list() photo: Optional[str] = None for media_file in [x[\"n\"] for x in media_list[\"media\"][0][\"fs\"]]: if media_file.lower().endswith(\".jpg\"): logger.info(f\"found a photo: {media_file}\") photo = media_file break Now let’s build the endpoint to download the screennail for the photo whose name we just found: url = GOPRO_BASE_URL + f\"/gopro/media/screennail?path=100GOPRO/{photo}\" Next we send the GET request and check the response for errors. Any errors will raise an exception. with requests.get(url, stream=True) as request: request.raise_for_status() Lastly, we iterate through the binary content in 8 kB chunks, writing to a local file: file = photo.split(\".\")[0] + \".jpg\" with open(file, \"wb\") as f: logger.info(f\"receiving binary stream to {file}...\") for chunk in request.iter_content(chunk_size=8192): f.write(chunk) This will log as such: INFO:root:found a photo: GOPR0987.JPG INFO:root:Getting the screennail for GOPR0987.JPG INFO:root:Sending: http://10.5.5.9:8080/gopro/media/screennail?path=100GOPRO/GOPR0987.JPG INFO:root:receiving binary stream to GOPR0987_screennail.jpg... Once complete, the GOPR0987_screennail.jpg file will be available from where the demo script was called. Get Media Thumbnail The next command we will be sending is Get Media thumbnail . Specifically, we will be getting the thumbnail for a photo. The camera must have at least one photo in its media list in order for this to work. There is a separate command (shown above) to get a media “screennail” First, we get the media list as in Get Media List . Then we search through the list of file names in the media list looking for a photo (i.e. a file whose name ends in .jpg). Once we find a photo, we proceed: media_list = get_media_list() photo: Optional[str] = None for media_file in [x[\"n\"] for x in media_list[\"media\"][0][\"fs\"]]: if media_file.lower().endswith(\".jpg\"): logger.info(f\"found a photo: {media_file}\") photo = media_file break Now let’s build the endpoint to download the thumbnail for the photo whose name we just found: url = GOPRO_BASE_URL + f\"/gopro/media/thumbnail?path=100GOPRO/{photo}\" Next we send the GET request and check the response for errors. Any errors will raise an exception. with requests.get(url, stream=True) as request: request.raise_for_status() Lastly, we iterate through the binary content in 8 kB chunks, writing to a local file: file = photo.split(\".\")[0] + \".jpg\" with open(file, \"wb\") as f: logger.info(f\"receiving binary stream to {file}...\") for chunk in request.iter_content(chunk_size=8192): f.write(chunk) This will log as such: INFO:root:found a photo: GOPR0987.JPG INFO:root:Getting the thumbnail for GOPR0987.JPG INFO:root:Sending: http://10.5.5.9:8080/gopro/media/thumbnail?path=100GOPRO/GOPR0987.JPG INFO:root:receiving binary stream to GOPR0987_thumbnail.jpg... Once complete, the GOPR0987_thumbnail.jpg file will be available from where the demo script was called. Troubleshooting See the previous tutorial’s troubleshooting section. Good Job! Congratulations 🤙 You can now query the GoPro’s media list and retrieve binary information for media file. This is currently last tutorial. Stay tuned for more 👍 At this point you should be able to start creating a useful example using the Open GoPro Interface. For some inspiration check out some of the demos.",
            "categories": [],
            "tags": [],
            "url": "/OpenGoPro/tutorials/python/camera-media-list#"
        },]